<HTML>
    <HEAD>
      <TITLE>Asterisk.org: Developer Documentation (24 May 2007)</TITLE>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<div><font size="2" align="right">Thu May 24 22:26:41 2007</font></div>

<h2>Asterisk developer's documentation</h2>
<hr/>
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir__2Fusr_2Flocal_2Fsrc_2Fasterisk_2Esvn_2Fastum_2Fmain_2F.html">main</a></div>
<h1>dlfcn.c</h1><a href="dlfcn_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">Copyright (c) 2002 Jorge Acereda  &lt;jacereda@users.sourceforge.net&gt; &amp;</span>
<a name="l00003"></a>00003 <span class="comment">                   Peter O'Gorman &lt;ogorman@users.sourceforge.net&gt;</span>
<a name="l00004"></a>00004 <span class="comment">                   </span>
<a name="l00005"></a>00005 <span class="comment">Portions may be copyright others, see the AUTHORS file included with this</span>
<a name="l00006"></a>00006 <span class="comment">distribution.                  </span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">Maintained by Peter O'Gorman &lt;ogorman@users.sourceforge.net&gt;</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">Bug Reports and other queries should go to &lt;ogorman@users.sourceforge.net&gt;</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">Permission is hereby granted, free of charge, to any person obtaining</span>
<a name="l00013"></a>00013 <span class="comment">a copy of this software and associated documentation files (the</span>
<a name="l00014"></a>00014 <span class="comment">"Software"), to deal in the Software without restriction, including</span>
<a name="l00015"></a>00015 <span class="comment">without limitation the rights to use, copy, modify, merge, publish,</span>
<a name="l00016"></a>00016 <span class="comment">distribute, sublicense, and/or sell copies of the Software, and to</span>
<a name="l00017"></a>00017 <span class="comment">permit persons to whom the Software is furnished to do so, subject to</span>
<a name="l00018"></a>00018 <span class="comment">the following conditions:</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">The above copyright notice and this permission notice shall be</span>
<a name="l00021"></a>00021 <span class="comment">included in all copies or substantial portions of the Software.</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,</span>
<a name="l00024"></a>00024 <span class="comment">EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<a name="l00025"></a>00025 <span class="comment">MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<a name="l00026"></a>00026 <span class="comment">NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</span>
<a name="l00027"></a>00027 <span class="comment">LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<a name="l00028"></a>00028 <span class="comment">OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span>
<a name="l00029"></a>00029 <span class="comment">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<a name="l00030"></a>00030 <span class="comment">*/</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;limits.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;mach-o/dyld.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;mach-o/nlist.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;mach-o/getsect.h&gt;</span>
<a name="l00043"></a>00043 <span class="comment">/* Just playing to see if it would compile with the freebsd headers, it does,</span>
<a name="l00044"></a>00044 <span class="comment"> * but because of the different values for RTLD_LOCAL etc, it would break binary</span>
<a name="l00045"></a>00045 <span class="comment"> * compat... oh well</span>
<a name="l00046"></a>00046 <span class="comment"> */</span>
<a name="l00047"></a>00047 <span class="preprocessor">#ifndef __BSD_VISIBLE</span>
<a name="l00048"></a><a class="code" href="dlfcn_8c.html#417d50b03cc7e465a0d7e8510f183a1b">00048</a> <span class="preprocessor"></span><span class="preprocessor">#define __BSD_VISIBLE 1</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 <span class="preprocessor">#include "<a class="code" href="dlfcn-compat_8h.html">asterisk/dlfcn-compat.h</a>"</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="preprocessor">#ifndef dl_restrict</span>
<a name="l00054"></a><a class="code" href="dlfcn_8c.html#e3405fce965daa65a1561ec53eafb46b">00054</a> <span class="preprocessor"></span><span class="preprocessor">#define dl_restrict __restrict</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="comment">/* This is not available on 10.1 */</span>
<a name="l00057"></a>00057 <span class="preprocessor">#ifndef LC_LOAD_WEAK_DYLIB</span>
<a name="l00058"></a><a class="code" href="dlfcn_8c.html#fa155e16fdd5262004d5e3f58b998545">00058</a> <span class="preprocessor"></span><span class="preprocessor">#define  LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span>
<a name="l00061"></a>00061 <span class="comment">/* With this stuff here, this thing may actually compile/run on 10.0 systems</span>
<a name="l00062"></a>00062 <span class="comment"> * Not that I have a 10.0 system to test it on anylonger</span>
<a name="l00063"></a>00063 <span class="comment"> */</span>
<a name="l00064"></a>00064 <span class="preprocessor">#ifndef LC_REQ_DYLD</span>
<a name="l00065"></a><a class="code" href="dlfcn_8c.html#ac5f51f867038347e9ac45defd1b26a9">00065</a> <span class="preprocessor"></span><span class="preprocessor">#define LC_REQ_DYLD 0x80000000</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#ifndef NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED</span>
<a name="l00068"></a><a class="code" href="dlfcn_8c.html#87a157769830554a61b43585b3f66e05">00068</a> <span class="preprocessor"></span><span class="preprocessor">#define NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED 0x4</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#ifndef NSADDIMAGE_OPTION_RETURN_ON_ERROR</span>
<a name="l00071"></a><a class="code" href="dlfcn_8c.html#8bef999e98f5b17a42537ade68c2db1d">00071</a> <span class="preprocessor"></span><span class="preprocessor">#define NSADDIMAGE_OPTION_RETURN_ON_ERROR 0x1</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_BIND</span>
<a name="l00074"></a><a class="code" href="dlfcn_8c.html#cc050e8021ee1d5275232968a4c8e381">00074</a> <span class="preprocessor"></span><span class="preprocessor">#define NSLOOKUPSYMBOLINIMAGE_OPTION_BIND 0x0</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#ifndef NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR</span>
<a name="l00077"></a><a class="code" href="dlfcn_8c.html#093a56fc66d422a12e681349f7fc31ee">00077</a> <span class="preprocessor"></span><span class="preprocessor">#define NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR 0x4</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="comment">/* These symbols will be looked for in dyld */</span>
<a name="l00080"></a><a class="code" href="dlfcn_8c.html#83168d8db5a85df2b3e7898c1230942f">00080</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>mach_header *(*dyld_NSAddImage) (<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">unsigned</span> long) = 0;
<a name="l00081"></a><a class="code" href="dlfcn_8c.html#8efc76b493fa04cbcff731ebe67cb41f">00081</a> <span class="keyword">static</span> <span class="keywordtype">int</span> (*<a class="code" href="dlfcn_8c.html#8efc76b493fa04cbcff731ebe67cb41f">dyld_NSIsSymbolNameDefinedInImage</a>) (<span class="keyword">const</span> <span class="keyword">struct </span>mach_header *, <span class="keyword">const</span> <span class="keywordtype">char</span> *) = 0;
<a name="l00082"></a>00082 <span class="keyword">static</span> NSSymbol(*<a class="code" href="dlfcn_8c.html#9fc4abd8c5aaaa341566cf1cac760b38">dyld_NSLookupSymbolInImage</a>)
<a name="l00083"></a><a class="code" href="dlfcn_8c.html#9fc4abd8c5aaaa341566cf1cac760b38">00083</a>    (<span class="keyword">const</span> <span class="keyword">struct </span>mach_header *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">unsigned</span> long) = 0;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="comment">/* Define this to make dlcompat reuse data block. This way in theory we save</span>
<a name="l00086"></a>00086 <span class="comment"> * a little bit of overhead. However we then couldn't correctly catch excess</span>
<a name="l00087"></a>00087 <span class="comment"> * calls to dlclose(). Hence we don't use this feature</span>
<a name="l00088"></a>00088 <span class="comment"> */</span>
<a name="l00089"></a>00089 #undef REUSE_STATUS
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="comment">/* Size of the internal error message buffer (used by dlerror()) */</span>
<a name="l00092"></a><a class="code" href="dlfcn_8c.html#13e7fe79d8e74ad50d94f63a2555d768">00092</a> #define <a class="code" href="dlfcn_8c.html#13e7fe79d8e74ad50d94f63a2555d768">ERR_STR_LEN</a>        251
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment">/* Maximum number of search paths supported by getSearchPath */</span>
<a name="l00095"></a><a class="code" href="dlfcn_8c.html#2de067226d09024de7279a081ca98e05">00095</a> #define <a class="code" href="dlfcn_8c.html#2de067226d09024de7279a081ca98e05">MAX_SEARCH_PATHS</a>   32
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 
<a name="l00098"></a><a class="code" href="dlfcn_8c.html#833480468fa097cbd87d801ddbb89555">00098</a> #define <a class="code" href="dlfcn_8c.html#833480468fa097cbd87d801ddbb89555">MAGIC_DYLIB_OFI</a> ((NSObjectFileImage) 'DYOF')
<a name="l00099"></a><a class="code" href="dlfcn_8c.html#7a6b0bdbbd9df80fd3f1044b33625543">00099</a> <span class="preprocessor">#define MAGIC_DYLIB_MOD ((NSModule) 'DYMO')</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>
<a name="l00101"></a>00101 <span class="comment">/* internal flags */</span>
<a name="l00102"></a><a class="code" href="dlfcn_8c.html#623f5284ca0d69050730d335ec3322c8">00102</a> <span class="preprocessor">#define DL_IN_LIST 0x01</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span>
<a name="l00104"></a>00104 <span class="comment">/* our mutex */</span>
<a name="l00105"></a><a class="code" href="dlfcn_8c.html#35bc2d3415a9f63bc5686e02a0f03883">00105</a> <span class="keyword">static</span> <a class="code" href="lock_8h.html#ca936d821c45d47a4dec64e836fc8ea6">pthread_mutex_t</a> <a class="code" href="dlfcn_8c.html#35bc2d3415a9f63bc5686e02a0f03883">dlcompat_mutex</a>;
<a name="l00106"></a>00106 <span class="comment">/* Our thread specific storage</span>
<a name="l00107"></a>00107 <span class="comment"> */</span>
<a name="l00108"></a><a class="code" href="dlfcn_8c.html#446c9e2cac70c4a3977923451eea13da">00108</a> <span class="keyword">static</span> pthread_key_t <a class="code" href="dlfcn_8c.html#446c9e2cac70c4a3977923451eea13da">dlerror_key</a>;
<a name="l00109"></a>00109 
<a name="l00110"></a><a class="code" href="structdlthread.html">00110</a> <span class="keyword">struct </span><a class="code" href="structdlthread.html">dlthread</a>
<a name="l00111"></a>00111 {
<a name="l00112"></a><a class="code" href="structdlthread.html#bd85d310fd6d0c567721fcfae6a5b559">00112</a>    <span class="keywordtype">int</span> <a class="code" href="structdlthread.html#bd85d310fd6d0c567721fcfae6a5b559">lockcnt</a>;
<a name="l00113"></a><a class="code" href="structdlthread.html#1d0e9ad7d1908eaf205e819f3255f92c">00113</a>    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structdlthread.html#1d0e9ad7d1908eaf205e819f3255f92c">errset</a>;
<a name="l00114"></a><a class="code" href="structdlthread.html#ac8ef2b34ca04ea40d46ffb53ef323f8">00114</a>    <span class="keywordtype">char</span> <a class="code" href="structdlthread.html#ac8ef2b34ca04ea40d46ffb53ef323f8">errstr</a>[<a class="code" href="dlfcn_8c.html#13e7fe79d8e74ad50d94f63a2555d768">ERR_STR_LEN</a>];
<a name="l00115"></a>00115 };
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 <span class="comment">/* This is our central data structure. Whenever a module is loaded via</span>
<a name="l00118"></a>00118 <span class="comment"> * dlopen(), we create such a struct.</span>
<a name="l00119"></a>00119 <span class="comment"> */</span>
<a name="l00120"></a><a class="code" href="structdlstatus.html">00120</a> <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a>
<a name="l00121"></a>00121 {
<a name="l00122"></a><a class="code" href="structdlstatus.html#d0cab90d8d20d57e2f2b9be52f7dd25d">00122</a>    <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *<a class="code" href="structdlstatus.html#d0cab90d8d20d57e2f2b9be52f7dd25d">next</a>;     <span class="comment">/* pointer to next element in the linked list */</span>
<a name="l00123"></a><a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">00123</a>    NSModule <a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>;
<a name="l00124"></a><a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">00124</a>    <span class="keyword">const</span> <span class="keyword">struct </span>mach_header *<a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">lib</a>;
<a name="l00125"></a><a class="code" href="structdlstatus.html#5740713f144552f73502d802bc23dd35">00125</a>    <span class="keywordtype">int</span> <a class="code" href="structdlstatus.html#5740713f144552f73502d802bc23dd35">refs</a>;               <span class="comment">/* reference count */</span>
<a name="l00126"></a><a class="code" href="structdlstatus.html#15d61712450a686a7f365adf4fef581f">00126</a>    <span class="keywordtype">int</span> <a class="code" href="structdlstatus.html#15d61712450a686a7f365adf4fef581f">mode</a>;               <span class="comment">/* mode in which this module was loaded */</span>
<a name="l00127"></a><a class="code" href="structdlstatus.html#913f9c49dcb544e2087cee284f4a00b7">00127</a>    dev_t <a class="code" href="structdlstatus.html#913f9c49dcb544e2087cee284f4a00b7">device</a>;
<a name="l00128"></a><a class="code" href="structdlstatus.html#9103befcd86a4d5623156d9a3044d3eb">00128</a>    ino_t <a class="code" href="structdlstatus.html#9103befcd86a4d5623156d9a3044d3eb">inode</a>;
<a name="l00129"></a><a class="code" href="structdlstatus.html#4e5868d676cb634aa75b125a0f741abf">00129</a>    <span class="keywordtype">int</span> <a class="code" href="structdlstatus.html#4e5868d676cb634aa75b125a0f741abf">flags</a>;              <span class="comment">/* Any internal flags we may need */</span>
<a name="l00130"></a>00130 };
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 <span class="comment">/* Head node of the dlstatus list */</span>
<a name="l00133"></a><a class="code" href="dlfcn_8c.html#86560ade58b777fa6f8f47ff729fee69">00133</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> mainStatus = { 0, <a class="code" href="dlfcn_8c.html#7a6b0bdbbd9df80fd3f1044b33625543">MAGIC_DYLIB_MOD</a>, NULL, -1, <a class="code" href="dlfcn-compat_8h.html#d565d5d83850e65f4dc43e403df7a3db">RTLD_GLOBAL</a>, 0, 0, 0 };
<a name="l00134"></a><a class="code" href="dlfcn_8c.html#263ae105fbf479a73d0cacf0db8538dd">00134</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *<a class="code" href="dlfcn_8c.html#263ae105fbf479a73d0cacf0db8538dd">stqueue</a> = &amp;mainStatus;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="comment">/* Storage for the last error message (used by dlerror()) */</span>
<a name="l00138"></a>00138 <span class="comment">/* static char err_str[ERR_STR_LEN]; */</span>
<a name="l00139"></a>00139 <span class="comment">/* static int err_filled = 0; */</span>
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="comment">/* Prototypes to internal functions */</span>
<a name="l00142"></a>00142 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="manager_8h.html#7631454338ff70b1a6b1262f5f36beac">fmt</a>, ...);
<a name="l00143"></a>00143 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, ...);
<a name="l00144"></a>00144 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#9ca53afb0b5ad93c065fa8cd9608020e">safegetenv</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aesopt_8h.html#8d6242bc80162ac99dd4d368eabe77cc">s</a>);
<a name="l00145"></a>00145 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#e3b786dcfbda95c5708dc4e648cb3fd8">searchList</a>(<span class="keywordtype">void</span>);
<a name="l00146"></a>00146 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#d51feb8815c9b0ac6afdcc317a0feded">getSearchPath</a>(<span class="keywordtype">int</span> i);
<a name="l00147"></a>00147 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#b0b1ae2c747ce1724f672c6b823a6e80">getFullPath</a>(<span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="manager_8h.html#8c7dd922ad47494fc02c388e12c00eac">file</a>);
<a name="l00148"></a>00148 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>stat *<a class="code" href="dlfcn_8c.html#5ce6066f9cbcf99b3cc6d47bc288daa8">findFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="manager_8h.html#8c7dd922ad47494fc02c388e12c00eac">file</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> **fullPath);
<a name="l00149"></a>00149 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dlfcn_8c.html#94cc9569b7b9d1547f14f2ce0e5512cd">isValidStatus</a>(<span class="keyword">struct</span> <a class="code" href="structdlstatus.html">dlstatus</a> *status);
<a name="l00150"></a>00150 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">isFlagSet</a>(<span class="keywordtype">int</span> mode, <span class="keywordtype">int</span> flag);
<a name="l00151"></a>00151 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *<a class="code" href="dlfcn_8c.html#302bcae6e1b779aec6b07c4891b9283f">lookupStatus</a>(<span class="keyword">const</span> <span class="keyword">struct</span> stat *sbuf);
<a name="l00152"></a>00152 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#873dbb061fe03446f7abde7d232472c5">insertStatus</a>(<span class="keyword">struct</span> <a class="code" href="structdlstatus.html">dlstatus</a> *dls, <span class="keyword">const</span> <span class="keyword">struct</span> stat *sbuf);
<a name="l00153"></a>00153 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dlfcn_8c.html#55fad2fd5c7e0789f8c4b9d5e7ff4ffc">promoteLocalToGlobal</a>(<span class="keyword">struct</span> <a class="code" href="structdlstatus.html">dlstatus</a> *dls);
<a name="l00154"></a>00154 <span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="dlfcn_8c.html#f9549c9322f3ac5e9f28e0bb7552f8a1">reference</a>(<span class="keyword">struct</span> <a class="code" href="structdlstatus.html">dlstatus</a> *dls, <span class="keywordtype">int</span> <a class="code" href="structdlstatus.html#15d61712450a686a7f365adf4fef581f">mode</a>);
<a name="l00155"></a>00155 <span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="dlfcn_8c.html#fbd7fb3690c8eff254f2690e831547b0">dlsymIntern</a>(<span class="keyword">struct</span> <a class="code" href="structdlstatus.html">dlstatus</a> *dls, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol, <span class="keywordtype">int</span> canSetError);
<a name="l00156"></a>00156 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *<a class="code" href="dlfcn_8c.html#f9967e34823d8729bf12f0fad36a885d">allocStatus</a>(<span class="keywordtype">void</span>);
<a name="l00157"></a>00157 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *<a class="code" href="dlfcn_8c.html#3ccd00c1b00c0a0c2098a526ed71fe32">loadModule</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keyword">const</span> <span class="keyword">struct</span> stat *sbuf, <span class="keywordtype">int</span> <a class="code" href="structdlstatus.html#15d61712450a686a7f365adf4fef581f">mode</a>);
<a name="l00158"></a>00158 <span class="keyword">static</span> NSSymbol *<a class="code" href="dlfcn_8c.html#998125cc2be835ee34124f5221bdafce">search_linked_libs</a>(<span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol);
<a name="l00159"></a>00159 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#0b7d7a9f21dd25d6dc50d712552f343a">get_lib_name</a>(<span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh);
<a name="l00160"></a>00160 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>mach_header *<a class="code" href="dlfcn_8c.html#980566f5f6d3ca4e4f01c5d3cced8327">get_mach_header_from_NSModule</a>(NSModule * mod);
<a name="l00161"></a>00161 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#83f7d76f85298415785439b62103645f">dlcompat_init_func</a>(<span class="keywordtype">void</span>);
<a name="l00162"></a>00162 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#3173031af7d4b847c50f22264d505a2a">dolock</a>(<span class="keywordtype">void</span>);
<a name="l00163"></a>00163 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>(<span class="keywordtype">void</span>);
<a name="l00164"></a>00164 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#ce385803b09da205cc80aafca2fb1d11">dlerrorfree</a>(<span class="keywordtype">void</span> *data);
<a name="l00165"></a>00165 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#f79dfe72a8a68fc21a7a43fdebe8771e">resetdlerror</a>(<span class="keywordtype">void</span>);
<a name="l00166"></a>00166 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>mach_header *<a class="code" href="dlfcn_8c.html#34ff4ec7602f0ad36f2c5c5429ded9d0">my_find_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="callerid_8c.html#b068931cc450442b63f5b3d276ea4297">name</a>);
<a name="l00167"></a>00167 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>mach_header *<a class="code" href="dlfcn_8c.html#edd4c3613a03834168b85d9192559af3">image_for_address</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *address);
<a name="l00168"></a>00168 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#03f64046de974f91c1e196b315f17a6f">dlcompat_cleanup</a>(<span class="keywordtype">void</span>);
<a name="l00169"></a>00169 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#c19c49edbff5e86e5280ee9f4c132344">dyld_error_str</a>(<span class="keywordtype">void</span>);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="preprocessor">#if FINK_BUILD</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="comment">/* Two Global Functions */</span>
<a name="l00173"></a>00173 <span class="keywordtype">void</span> *dlsym_prepend_underscore(<span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol);
<a name="l00174"></a>00174 <span class="keywordtype">void</span> *dlsym_auto_underscore(<span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="comment">/* And their _intern counterparts */</span>
<a name="l00177"></a>00177 <span class="keyword">static</span> <span class="keywordtype">void</span> *dlsym_prepend_underscore_intern(<span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol);
<a name="l00178"></a>00178 <span class="keyword">static</span> <span class="keywordtype">void</span> *dlsym_auto_underscore_intern(<span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol);
<a name="l00179"></a>00179 <span class="preprocessor">#endif</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span>
<a name="l00181"></a>00181 <span class="comment">/* Functions */</span>
<a name="l00182"></a>00182 
<a name="l00183"></a><a class="code" href="dlfcn_8c.html#1de850617a0e5f1b0585915acf78781b">00183</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="manager_8h.html#7631454338ff70b1a6b1262f5f36beac">fmt</a>, ...)
<a name="l00184"></a>00184 {
<a name="l00185"></a>00185 <span class="preprocessor">#if DEBUG &gt; 1</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span>   va_list arg;
<a name="l00187"></a>00187    va_start(arg, fmt);
<a name="l00188"></a>00188    fprintf(stderr, <span class="stringliteral">"DLDEBUG: "</span>);
<a name="l00189"></a>00189    vfprintf(stderr, fmt, arg);
<a name="l00190"></a>00190    fprintf(stderr, <span class="stringliteral">"\n"</span>);
<a name="l00191"></a>00191    fflush(stderr);
<a name="l00192"></a>00192    va_end(arg);
<a name="l00193"></a>00193 <span class="preprocessor">#endif</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>}
<a name="l00195"></a>00195 
<a name="l00196"></a><a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">00196</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, ...)
<a name="l00197"></a>00197 {
<a name="l00198"></a>00198    va_list arg;
<a name="l00199"></a>00199    <span class="keyword">struct </span><a class="code" href="structdlthread.html">dlthread</a>  *tss;
<a name="l00200"></a>00200    <span class="keywordtype">char</span> * err_str;
<a name="l00201"></a>00201    va_start(arg, str);
<a name="l00202"></a>00202    tss = pthread_getspecific(dlerror_key);
<a name="l00203"></a>00203    err_str = tss-&gt;<a class="code" href="structdlthread.html#ac8ef2b34ca04ea40d46ffb53ef323f8">errstr</a>;
<a name="l00204"></a>00204    strncpy(err_str, <span class="stringliteral">"dlcompat: "</span>, <a class="code" href="dlfcn_8c.html#13e7fe79d8e74ad50d94f63a2555d768">ERR_STR_LEN</a>);
<a name="l00205"></a>00205    vsnprintf(err_str + 10, <a class="code" href="dlfcn_8c.html#13e7fe79d8e74ad50d94f63a2555d768">ERR_STR_LEN</a> - 10, str, arg);
<a name="l00206"></a>00206    va_end(arg);
<a name="l00207"></a>00207    <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"ERROR: %s\n"</span>, err_str);
<a name="l00208"></a>00208    tss-&gt;<a class="code" href="structdlthread.html#1d0e9ad7d1908eaf205e819f3255f92c">errset</a> = 1;
<a name="l00209"></a>00209 }
<a name="l00210"></a>00210 
<a name="l00211"></a><a class="code" href="dlfcn_8c.html#a0054ad56afd71085b56813f21a1544c">00211</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#a0054ad56afd71085b56813f21a1544c">warning</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str)
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213 <span class="preprocessor">#if DEBUG &gt; 0</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span>   fprintf(stderr, <span class="stringliteral">"WARNING: dlcompat: %s\n"</span>, str);
<a name="l00215"></a>00215 <span class="preprocessor">#endif</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span>}
<a name="l00217"></a>00217 
<a name="l00218"></a><a class="code" href="dlfcn_8c.html#9ca53afb0b5ad93c065fa8cd9608020e">00218</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#9ca53afb0b5ad93c065fa8cd9608020e">safegetenv</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="aesopt_8h.html#8d6242bc80162ac99dd4d368eabe77cc">s</a>)
<a name="l00219"></a>00219 {
<a name="l00220"></a>00220    <span class="keyword">const</span> <span class="keywordtype">char</span> *ss = getenv(s);
<a name="l00221"></a>00221    <span class="keywordflow">return</span> ss ? ss : <span class="stringliteral">""</span>;
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="comment">/* because this is only used for debugging and error reporting functions, we</span>
<a name="l00225"></a>00225 <span class="comment"> * don't really care about how elegant it is... it could use the load</span>
<a name="l00226"></a>00226 <span class="comment"> * commands to find the install name of the library, but...</span>
<a name="l00227"></a>00227 <span class="comment"> */</span>
<a name="l00228"></a><a class="code" href="dlfcn_8c.html#0b7d7a9f21dd25d6dc50d712552f343a">00228</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#0b7d7a9f21dd25d6dc50d712552f343a">get_lib_name</a>(<span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh)
<a name="l00229"></a>00229 {
<a name="l00230"></a>00230    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> count = _dyld_image_count();
<a name="l00231"></a>00231    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;
<a name="l00232"></a>00232    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structval.html">val</a> = NULL;
<a name="l00233"></a>00233    <span class="keywordflow">if</span> (mh)
<a name="l00234"></a>00234    {
<a name="l00235"></a>00235       <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
<a name="l00236"></a>00236       {
<a name="l00237"></a>00237          <span class="keywordflow">if</span> (mh == _dyld_get_image_header(i))
<a name="l00238"></a>00238          {
<a name="l00239"></a>00239             val = _dyld_get_image_name(i);
<a name="l00240"></a>00240             <span class="keywordflow">break</span>;
<a name="l00241"></a>00241          }
<a name="l00242"></a>00242       }
<a name="l00243"></a>00243    }
<a name="l00244"></a>00244    <span class="keywordflow">return</span> val;
<a name="l00245"></a>00245 }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 <span class="comment">/* Returns the mach_header for the module bu going through all the loaded images</span>
<a name="l00248"></a>00248 <span class="comment"> * and finding the one with the same name as the module. There really ought to be</span>
<a name="l00249"></a>00249 <span class="comment"> * an api for doing this, would be faster, but there isn't one right now</span>
<a name="l00250"></a>00250 <span class="comment"> */</span>
<a name="l00251"></a><a class="code" href="dlfcn_8c.html#980566f5f6d3ca4e4f01c5d3cced8327">00251</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>mach_header *<a class="code" href="dlfcn_8c.html#980566f5f6d3ca4e4f01c5d3cced8327">get_mach_header_from_NSModule</a>(NSModule * mod)
<a name="l00252"></a>00252 {
<a name="l00253"></a>00253    <span class="keyword">const</span> <span class="keywordtype">char</span> *mod_name = NSNameOfModule(mod);
<a name="l00254"></a>00254    <span class="keyword">struct </span>mach_header *mh = NULL;
<a name="l00255"></a>00255    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> count = _dyld_image_count();
<a name="l00256"></a>00256    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;
<a name="l00257"></a>00257    <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"Module name: %s"</span>, mod_name);
<a name="l00258"></a>00258    <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
<a name="l00259"></a>00259    {
<a name="l00260"></a>00260       <span class="keywordflow">if</span> (!strcmp(mod_name, _dyld_get_image_name(i)))
<a name="l00261"></a>00261       {
<a name="l00262"></a>00262          mh = _dyld_get_image_header(i);
<a name="l00263"></a>00263          <span class="keywordflow">break</span>;
<a name="l00264"></a>00264       }
<a name="l00265"></a>00265    }
<a name="l00266"></a>00266    <span class="keywordflow">return</span> mh;
<a name="l00267"></a>00267 }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="comment">/* Compute and return a list of all directories that we should search when</span>
<a name="l00271"></a>00271 <span class="comment"> * trying to locate a module. We first look at the values of LD_LIBRARY_PATH</span>
<a name="l00272"></a>00272 <span class="comment"> * and DYLD_LIBRARY_PATH, and then finally fall back to looking into</span>
<a name="l00273"></a>00273 <span class="comment"> * /usr/lib and /lib. Since both of the environments variables can contain a</span>
<a name="l00274"></a>00274 <span class="comment"> * list of colon separated paths, we simply concat them and the two other paths</span>
<a name="l00275"></a>00275 <span class="comment"> * into one big string, which we then can easily parse.</span>
<a name="l00276"></a>00276 <span class="comment"> * Splitting this string into the actual path list is done by getSearchPath()</span>
<a name="l00277"></a>00277 <span class="comment"> */</span>
<a name="l00278"></a><a class="code" href="dlfcn_8c.html#e3b786dcfbda95c5708dc4e648cb3fd8">00278</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#e3b786dcfbda95c5708dc4e648cb3fd8">searchList</a>()
<a name="l00279"></a>00279 {
<a name="l00280"></a>00280    size_t buf_size;
<a name="l00281"></a>00281    <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="adsistub_8c.html#cb7e52b21171fb9a53b498202607f0bd">buf</a>=NULL;
<a name="l00282"></a>00282    <span class="keyword">const</span> <span class="keywordtype">char</span> *ldlp = <a class="code" href="dlfcn_8c.html#9ca53afb0b5ad93c065fa8cd9608020e">safegetenv</a>(<span class="stringliteral">"LD_LIBRARY_PATH"</span>);
<a name="l00283"></a>00283    <span class="keyword">const</span> <span class="keywordtype">char</span> *dyldlp = <a class="code" href="dlfcn_8c.html#9ca53afb0b5ad93c065fa8cd9608020e">safegetenv</a>(<span class="stringliteral">"DYLD_LIBRARY_PATH"</span>);
<a name="l00284"></a>00284    <span class="keyword">const</span> <span class="keywordtype">char</span> *stdpath = getenv(<span class="stringliteral">"DYLD_FALLBACK_LIBRARY_PATH"</span>);
<a name="l00285"></a>00285    <span class="keywordflow">if</span> (!stdpath)
<a name="l00286"></a>00286       stdpath = <span class="stringliteral">"/usr/local/lib:/lib:/usr/lib"</span>;
<a name="l00287"></a>00287    <span class="keywordflow">if</span> (!buf)
<a name="l00288"></a>00288    {  
<a name="l00289"></a>00289       buf_size = strlen(ldlp) + strlen(dyldlp) + strlen(stdpath) + 4;
<a name="l00290"></a>00290       buf = <a class="code" href="astmm_8h.html#df74d22342f0da6246131193b1993a41">malloc</a>(buf_size);
<a name="l00291"></a>00291       snprintf(buf, buf_size, <span class="stringliteral">"%s%s%s%s%s%c"</span>, dyldlp, (dyldlp[0] ? <span class="stringliteral">":"</span> : <span class="stringliteral">""</span>), ldlp, (ldlp[0] ? <span class="stringliteral">":"</span> : <span class="stringliteral">""</span>),
<a name="l00292"></a>00292              stdpath, <span class="charliteral">'\0'</span>);
<a name="l00293"></a>00293    }
<a name="l00294"></a>00294    <span class="keywordflow">return</span> buf;
<a name="l00295"></a>00295 }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297 <span class="comment">/* Returns the ith search path from the list as computed by searchList() */</span>
<a name="l00298"></a><a class="code" href="dlfcn_8c.html#d51feb8815c9b0ac6afdcc317a0feded">00298</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#d51feb8815c9b0ac6afdcc317a0feded">getSearchPath</a>(<span class="keywordtype">int</span> i)
<a name="l00299"></a>00299 {
<a name="l00300"></a>00300    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *list = 0;
<a name="l00301"></a>00301    <span class="keyword">static</span> <span class="keywordtype">char</span> **path = (<span class="keywordtype">char</span> **)0;
<a name="l00302"></a>00302    <span class="keyword">static</span> <span class="keywordtype">int</span> end = 0;
<a name="l00303"></a>00303    <span class="keyword">static</span> <span class="keywordtype">int</span> numsize = <a class="code" href="dlfcn_8c.html#2de067226d09024de7279a081ca98e05">MAX_SEARCH_PATHS</a>;
<a name="l00304"></a>00304    <span class="keyword">static</span> <span class="keywordtype">char</span> **tmp;
<a name="l00305"></a>00305    <span class="comment">/* So we can call free() in the "destructor" we use i=-1 to return the alloc'd array */</span>
<a name="l00306"></a>00306    <span class="keywordflow">if</span> (i == -1)
<a name="l00307"></a>00307    {
<a name="l00308"></a>00308       <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>*)path;
<a name="l00309"></a>00309    }
<a name="l00310"></a>00310    <span class="keywordflow">if</span> (!path)
<a name="l00311"></a>00311    {
<a name="l00312"></a>00312       path = (<span class="keywordtype">char</span> **)<a class="code" href="astmm_8h.html#b9d011ff8b105f2850962f2003da06d9">calloc</a>(<a class="code" href="dlfcn_8c.html#2de067226d09024de7279a081ca98e05">MAX_SEARCH_PATHS</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> **));
<a name="l00313"></a>00313    }
<a name="l00314"></a>00314    <span class="keywordflow">if</span> (!list &amp;&amp; !end)
<a name="l00315"></a>00315       list = <a class="code" href="dlfcn_8c.html#e3b786dcfbda95c5708dc4e648cb3fd8">searchList</a>();
<a name="l00316"></a>00316    <span class="keywordflow">if</span> (i &gt;= (numsize))
<a name="l00317"></a>00317    {
<a name="l00318"></a>00318       <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"Increasing size for long PATH"</span>);
<a name="l00319"></a>00319       tmp = (<span class="keywordtype">char</span> **)<a class="code" href="astmm_8h.html#b9d011ff8b105f2850962f2003da06d9">calloc</a>((<a class="code" href="dlfcn_8c.html#2de067226d09024de7279a081ca98e05">MAX_SEARCH_PATHS</a> + numsize), <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> **));
<a name="l00320"></a>00320       <span class="keywordflow">if</span> (tmp)
<a name="l00321"></a>00321       {
<a name="l00322"></a>00322          memcpy(tmp, path, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> **) * numsize);
<a name="l00323"></a>00323          <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>(path);
<a name="l00324"></a>00324          path = tmp;
<a name="l00325"></a>00325          numsize += <a class="code" href="dlfcn_8c.html#2de067226d09024de7279a081ca98e05">MAX_SEARCH_PATHS</a>;
<a name="l00326"></a>00326       }
<a name="l00327"></a>00327       <span class="keywordflow">else</span>
<a name="l00328"></a>00328       {
<a name="l00329"></a>00329          <span class="keywordflow">return</span> 0;
<a name="l00330"></a>00330       }
<a name="l00331"></a>00331    }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333    <span class="keywordflow">while</span> (!path[i] &amp;&amp; !end)
<a name="l00334"></a>00334    {
<a name="l00335"></a>00335       path[i] = <a class="code" href="strcompat_8c.html#a541370456ac872bdb4bdcc462fc6a6e">strsep</a>((<span class="keywordtype">char</span> **)&amp;list, <span class="stringliteral">":"</span>);
<a name="l00336"></a>00336 
<a name="l00337"></a>00337       <span class="keywordflow">if</span> (path[i][0] == 0)
<a name="l00338"></a>00338          path[i] = 0;
<a name="l00339"></a>00339       end = (list == 0);
<a name="l00340"></a>00340    }
<a name="l00341"></a>00341    <span class="keywordflow">return</span> path[i];
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a><a class="code" href="dlfcn_8c.html#b0b1ae2c747ce1724f672c6b823a6e80">00344</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#b0b1ae2c747ce1724f672c6b823a6e80">getFullPath</a>(<span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="manager_8h.html#8c7dd922ad47494fc02c388e12c00eac">file</a>)
<a name="l00345"></a>00345 {
<a name="l00346"></a>00346    <span class="keyword">static</span> <span class="keywordtype">char</span> <a class="code" href="adsistub_8c.html#cb7e52b21171fb9a53b498202607f0bd">buf</a>[PATH_MAX];
<a name="l00347"></a>00347    <span class="keyword">const</span> <span class="keywordtype">char</span> *path = <a class="code" href="dlfcn_8c.html#d51feb8815c9b0ac6afdcc317a0feded">getSearchPath</a>(i);
<a name="l00348"></a>00348    <span class="keywordflow">if</span> (path)
<a name="l00349"></a>00349    {
<a name="l00350"></a>00350       snprintf(buf, PATH_MAX, <span class="stringliteral">"%s/%s"</span>, path, file);
<a name="l00351"></a>00351    }
<a name="l00352"></a>00352    <span class="keywordflow">return</span> path ? buf : 0;
<a name="l00353"></a>00353 }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="comment">/* Given a file name, try to determine the full path for that file. Starts</span>
<a name="l00356"></a>00356 <span class="comment"> * its search in the current directory, and then tries all paths in the </span>
<a name="l00357"></a>00357 <span class="comment"> * search list in the order they are specified there.</span>
<a name="l00358"></a>00358 <span class="comment"> */</span>
<a name="l00359"></a><a class="code" href="dlfcn_8c.html#5ce6066f9cbcf99b3cc6d47bc288daa8">00359</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>stat *<a class="code" href="dlfcn_8c.html#5ce6066f9cbcf99b3cc6d47bc288daa8">findFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keyword">const</span> <span class="keywordtype">char</span> **fullPath)
<a name="l00360"></a>00360 {
<a name="l00361"></a>00361    <span class="keywordtype">int</span> i = 0;
<a name="l00362"></a>00362    <span class="keyword">static</span> <span class="keyword">struct </span>stat sbuf;
<a name="l00363"></a>00363    <span class="keywordtype">char</span> *fileName;
<a name="l00364"></a>00364    <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"finding file %s"</span>, file);
<a name="l00365"></a>00365    *fullPath = file;
<a name="l00366"></a>00366    <span class="keywordflow">if</span> (0 == stat(file, &amp;sbuf))
<a name="l00367"></a>00367       <span class="keywordflow">return</span> &amp;sbuf;
<a name="l00368"></a>00368    <span class="keywordflow">if</span> (strchr(file, <span class="charliteral">'/'</span>))
<a name="l00369"></a>00369       <span class="keywordflow">return</span> 0;            <span class="comment">/* If the path had a / we don't look in env var places */</span>
<a name="l00370"></a>00370    fileName = NULL;
<a name="l00371"></a>00371    <span class="keywordflow">if</span> (!fileName)
<a name="l00372"></a>00372       fileName = (<span class="keywordtype">char</span> *)file;
<a name="l00373"></a>00373    <span class="keywordflow">while</span> ((*fullPath = <a class="code" href="dlfcn_8c.html#b0b1ae2c747ce1724f672c6b823a6e80">getFullPath</a>(i++, fileName)))
<a name="l00374"></a>00374    {
<a name="l00375"></a>00375       <span class="keywordflow">if</span> (0 == stat(*fullPath, &amp;sbuf))
<a name="l00376"></a>00376          <span class="keywordflow">return</span> &amp;sbuf;
<a name="l00377"></a>00377    }
<a name="l00378"></a>00378    ;
<a name="l00379"></a>00379    <span class="keywordflow">return</span> 0;
<a name="l00380"></a>00380 }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 <span class="comment">/* Determine whether a given dlstatus is valid or not */</span>
<a name="l00383"></a><a class="code" href="dlfcn_8c.html#94cc9569b7b9d1547f14f2ce0e5512cd">00383</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dlfcn_8c.html#94cc9569b7b9d1547f14f2ce0e5512cd">isValidStatus</a>(<span class="keyword">struct</span> <a class="code" href="structdlstatus.html">dlstatus</a> *status)
<a name="l00384"></a>00384 {
<a name="l00385"></a>00385    <span class="comment">/* Walk the list to verify status is contained in it */</span>
<a name="l00386"></a>00386    <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *dls = stqueue;
<a name="l00387"></a>00387    <span class="keywordflow">while</span> (dls &amp;&amp; status != dls)
<a name="l00388"></a>00388       dls = dls-&gt;<a class="code" href="structdlstatus.html#d0cab90d8d20d57e2f2b9be52f7dd25d">next</a>;
<a name="l00389"></a>00389    <span class="keywordflow">if</span> (dls == 0)
<a name="l00390"></a>00390       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"invalid handle"</span>);
<a name="l00391"></a>00391    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a> == 0) || (dls-&gt;<a class="code" href="structdlstatus.html#5740713f144552f73502d802bc23dd35">refs</a> == 0))
<a name="l00392"></a>00392       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"handle to closed library"</span>);
<a name="l00393"></a>00393    <span class="keywordflow">else</span>
<a name="l00394"></a>00394       <span class="keywordflow">return</span> <a class="code" href="plc_8c.html#c0d83f0b82a6b30de8811e69e6d95c61">TRUE</a>;
<a name="l00395"></a>00395    <span class="keywordflow">return</span> <a class="code" href="plc_8c.html#946003f97ccc52d5d3b54ac0ec31bbfc">FALSE</a>;
<a name="l00396"></a>00396 }
<a name="l00397"></a>00397 
<a name="l00398"></a><a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">00398</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">isFlagSet</a>(<span class="keywordtype">int</span> <a class="code" href="structdlstatus.html#15d61712450a686a7f365adf4fef581f">mode</a>, <span class="keywordtype">int</span> flag)
<a name="l00399"></a>00399 {
<a name="l00400"></a>00400    <span class="keywordflow">return</span> (mode &amp; flag) == flag;
<a name="l00401"></a>00401 }
<a name="l00402"></a>00402 
<a name="l00403"></a><a class="code" href="dlfcn_8c.html#302bcae6e1b779aec6b07c4891b9283f">00403</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *<a class="code" href="dlfcn_8c.html#302bcae6e1b779aec6b07c4891b9283f">lookupStatus</a>(<span class="keyword">const</span> <span class="keyword">struct</span> stat *sbuf)
<a name="l00404"></a>00404 {
<a name="l00405"></a>00405    <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *dls = stqueue;
<a name="l00406"></a>00406    <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"looking for status"</span>);
<a name="l00407"></a>00407    <span class="keywordflow">while</span> (dls &amp;&amp; ( <span class="comment">/* isFlagSet(dls-&gt;mode, RTLD_UNSHARED) */</span> 0
<a name="l00408"></a>00408                || sbuf-&gt;st_dev != dls-&gt;<a class="code" href="structdlstatus.html#913f9c49dcb544e2087cee284f4a00b7">device</a> || sbuf-&gt;st_ino != dls-&gt;<a class="code" href="structdlstatus.html#9103befcd86a4d5623156d9a3044d3eb">inode</a>))
<a name="l00409"></a>00409       dls = dls-&gt;<a class="code" href="structdlstatus.html#d0cab90d8d20d57e2f2b9be52f7dd25d">next</a>;
<a name="l00410"></a>00410    <span class="keywordflow">return</span> dls;
<a name="l00411"></a>00411 }
<a name="l00412"></a>00412 
<a name="l00413"></a><a class="code" href="dlfcn_8c.html#873dbb061fe03446f7abde7d232472c5">00413</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#873dbb061fe03446f7abde7d232472c5">insertStatus</a>(<span class="keyword">struct</span> <a class="code" href="structdlstatus.html">dlstatus</a> *dls, <span class="keyword">const</span> <span class="keyword">struct</span> stat *sbuf)
<a name="l00414"></a>00414 {
<a name="l00415"></a>00415    <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"inserting status"</span>);
<a name="l00416"></a>00416    dls-&gt;<a class="code" href="structdlstatus.html#9103befcd86a4d5623156d9a3044d3eb">inode</a> = sbuf-&gt;st_ino;
<a name="l00417"></a>00417    dls-&gt;<a class="code" href="structdlstatus.html#913f9c49dcb544e2087cee284f4a00b7">device</a> = sbuf-&gt;st_dev;
<a name="l00418"></a>00418    dls-&gt;<a class="code" href="structdlstatus.html#5740713f144552f73502d802bc23dd35">refs</a> = 0;
<a name="l00419"></a>00419    dls-&gt;<a class="code" href="structdlstatus.html#15d61712450a686a7f365adf4fef581f">mode</a> = 0;
<a name="l00420"></a>00420    <span class="keywordflow">if</span> ((dls-&gt;<a class="code" href="structdlstatus.html#4e5868d676cb634aa75b125a0f741abf">flags</a> &amp; <a class="code" href="dlfcn_8c.html#623f5284ca0d69050730d335ec3322c8">DL_IN_LIST</a>) == 0)
<a name="l00421"></a>00421    {
<a name="l00422"></a>00422       dls-&gt;<a class="code" href="structdlstatus.html#d0cab90d8d20d57e2f2b9be52f7dd25d">next</a> = stqueue;
<a name="l00423"></a>00423       stqueue = dls;
<a name="l00424"></a>00424       dls-&gt;<a class="code" href="structdlstatus.html#4e5868d676cb634aa75b125a0f741abf">flags</a> |= <a class="code" href="dlfcn_8c.html#623f5284ca0d69050730d335ec3322c8">DL_IN_LIST</a>;
<a name="l00425"></a>00425    }
<a name="l00426"></a>00426 }
<a name="l00427"></a>00427 
<a name="l00428"></a><a class="code" href="dlfcn_8c.html#f9967e34823d8729bf12f0fad36a885d">00428</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *<a class="code" href="dlfcn_8c.html#f9967e34823d8729bf12f0fad36a885d">allocStatus</a>()
<a name="l00429"></a>00429 {
<a name="l00430"></a>00430    <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *dls;
<a name="l00431"></a>00431 <span class="preprocessor">#ifdef REUSE_STATUS</span>
<a name="l00432"></a>00432 <span class="preprocessor"></span>   dls = stqueue;
<a name="l00433"></a>00433    <span class="keywordflow">while</span> (dls &amp;&amp; dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>)
<a name="l00434"></a>00434       dls = dls-&gt;<a class="code" href="structdlstatus.html#d0cab90d8d20d57e2f2b9be52f7dd25d">next</a>;
<a name="l00435"></a>00435    <span class="keywordflow">if</span> (!dls)
<a name="l00436"></a>00436 <span class="preprocessor">#endif</span>
<a name="l00437"></a>00437 <span class="preprocessor"></span>      dls = <a class="code" href="astmm_8h.html#df74d22342f0da6246131193b1993a41">malloc</a>(<span class="keyword">sizeof</span>(*dls));
<a name="l00438"></a>00438    dls-&gt;flags = 0;
<a name="l00439"></a>00439    <span class="keywordflow">return</span> dls;
<a name="l00440"></a>00440 }
<a name="l00441"></a>00441 
<a name="l00442"></a><a class="code" href="dlfcn_8c.html#55fad2fd5c7e0789f8c4b9d5e7ff4ffc">00442</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dlfcn_8c.html#55fad2fd5c7e0789f8c4b9d5e7ff4ffc">promoteLocalToGlobal</a>(<span class="keyword">struct</span> <a class="code" href="structdlstatus.html">dlstatus</a> *dls)
<a name="l00443"></a>00443 {
<a name="l00444"></a>00444    <span class="keyword">static</span> int (*p) (NSModule <a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>) = 0;
<a name="l00445"></a>00445    <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"promoting"</span>);
<a name="l00446"></a>00446    <span class="keywordflow">if</span> (!p)
<a name="l00447"></a>00447       _dyld_func_lookup(<span class="stringliteral">"__dyld_NSMakePrivateModulePublic"</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;p);
<a name="l00448"></a>00448    <span class="keywordflow">return</span> (dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a> == <a class="code" href="dlfcn_8c.html#7a6b0bdbbd9df80fd3f1044b33625543">MAGIC_DYLIB_MOD</a>) || (p &amp;&amp; p(dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>));
<a name="l00449"></a>00449 }
<a name="l00450"></a>00450 
<a name="l00451"></a><a class="code" href="dlfcn_8c.html#f9549c9322f3ac5e9f28e0bb7552f8a1">00451</a> <span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="dlfcn_8c.html#f9549c9322f3ac5e9f28e0bb7552f8a1">reference</a>(<span class="keyword">struct</span> <a class="code" href="structdlstatus.html">dlstatus</a> *dls, <span class="keywordtype">int</span> <a class="code" href="structdlstatus.html#15d61712450a686a7f365adf4fef581f">mode</a>)
<a name="l00452"></a>00452 {
<a name="l00453"></a>00453    <span class="keywordflow">if</span> (dls)
<a name="l00454"></a>00454    {
<a name="l00455"></a>00455       <span class="keywordflow">if</span> (dls-&gt;module == <a class="code" href="dlfcn_8c.html#7a6b0bdbbd9df80fd3f1044b33625543">MAGIC_DYLIB_MOD</a> &amp;&amp; !<a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">isFlagSet</a>(mode, <a class="code" href="dlfcn-compat_8h.html#d565d5d83850e65f4dc43e403df7a3db">RTLD_GLOBAL</a>))
<a name="l00456"></a>00456       {
<a name="l00457"></a>00457          <a class="code" href="dlfcn_8c.html#a0054ad56afd71085b56813f21a1544c">warning</a>(<span class="stringliteral">"trying to open a .dylib with RTLD_LOCAL"</span>);
<a name="l00458"></a>00458          <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"unable to open a .dylib with RTLD_LOCAL"</span>);
<a name="l00459"></a>00459          <span class="keywordflow">return</span> NULL;
<a name="l00460"></a>00460       }
<a name="l00461"></a>00461       <span class="keywordflow">if</span> (<a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">isFlagSet</a>(mode, <a class="code" href="dlfcn-compat_8h.html#d565d5d83850e65f4dc43e403df7a3db">RTLD_GLOBAL</a>) &amp;&amp;
<a name="l00462"></a>00462          !<a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">isFlagSet</a>(dls-&gt;mode, <a class="code" href="dlfcn-compat_8h.html#d565d5d83850e65f4dc43e403df7a3db">RTLD_GLOBAL</a>) &amp;&amp; !<a class="code" href="dlfcn_8c.html#55fad2fd5c7e0789f8c4b9d5e7ff4ffc">promoteLocalToGlobal</a>(dls))
<a name="l00463"></a>00463       {
<a name="l00464"></a>00464          <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"unable to promote local module to global"</span>);
<a name="l00465"></a>00465          <span class="keywordflow">return</span> NULL;
<a name="l00466"></a>00466       }
<a name="l00467"></a>00467       dls-&gt;mode |= mode;
<a name="l00468"></a>00468       dls-&gt;refs++;
<a name="l00469"></a>00469    }
<a name="l00470"></a>00470    <span class="keywordflow">else</span>
<a name="l00471"></a>00471       <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"reference called with NULL argument"</span>);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473    <span class="keywordflow">return</span> dls;
<a name="l00474"></a>00474 }
<a name="l00475"></a>00475 
<a name="l00476"></a><a class="code" href="dlfcn_8c.html#34ff4ec7602f0ad36f2c5c5429ded9d0">00476</a> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>mach_header *<a class="code" href="dlfcn_8c.html#34ff4ec7602f0ad36f2c5c5429ded9d0">my_find_image</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="callerid_8c.html#b068931cc450442b63f5b3d276ea4297">name</a>)
<a name="l00477"></a>00477 {
<a name="l00478"></a>00478    <span class="keyword">const</span> <span class="keyword">struct </span>mach_header *mh = 0;
<a name="l00479"></a>00479    <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span> = NULL;
<a name="l00480"></a>00480    <span class="keywordtype">int</span> i = _dyld_image_count();
<a name="l00481"></a>00481    <span class="keywordtype">int</span> j;
<a name="l00482"></a>00482    mh = (<span class="keyword">struct </span>mach_header *)
<a name="l00483"></a>00483       <a class="code" href="dlfcn_8c.html#83168d8db5a85df2b3e7898c1230942f">dyld_NSAddImage</a>(name, <a class="code" href="dlfcn_8c.html#87a157769830554a61b43585b3f66e05">NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED</a> |
<a name="l00484"></a>00484                   <a class="code" href="dlfcn_8c.html#8bef999e98f5b17a42537ade68c2db1d">NSADDIMAGE_OPTION_RETURN_ON_ERROR</a>);
<a name="l00485"></a>00485    <span class="keywordflow">if</span> (!mh)
<a name="l00486"></a>00486    {
<a name="l00487"></a>00487       <span class="keywordflow">for</span> (j = 0; j &lt; i; j++)
<a name="l00488"></a>00488       {
<a name="l00489"></a>00489          <span class="keywordtype">id</span> = _dyld_get_image_name(j);
<a name="l00490"></a>00490          <span class="keywordflow">if</span> (!strcmp(<span class="keywordtype">id</span>, name))
<a name="l00491"></a>00491          {
<a name="l00492"></a>00492             mh = _dyld_get_image_header(j);
<a name="l00493"></a>00493             <span class="keywordflow">break</span>;
<a name="l00494"></a>00494          }
<a name="l00495"></a>00495       }
<a name="l00496"></a>00496    }
<a name="l00497"></a>00497    <span class="keywordflow">return</span> mh;
<a name="l00498"></a>00498 }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="comment">/*</span>
<a name="l00501"></a>00501 <span class="comment"> * dyld adds libraries by first adding the directly dependant libraries in link order, and</span>
<a name="l00502"></a>00502 <span class="comment"> * then adding the dependencies for those libraries, so we should do the same... but we don't</span>
<a name="l00503"></a>00503 <span class="comment"> * bother adding the extra dependencies, if the symbols are neither in the loaded image nor</span>
<a name="l00504"></a>00504 <span class="comment"> * any of it's direct dependencies, then it probably isn't there.</span>
<a name="l00505"></a>00505 <span class="comment"> */</span>
<a name="l00506"></a><a class="code" href="dlfcn_8c.html#998125cc2be835ee34124f5221bdafce">00506</a> NSSymbol *<a class="code" href="dlfcn_8c.html#998125cc2be835ee34124f5221bdafce">search_linked_libs</a>(<span class="keyword">const</span> <span class="keyword">struct</span> mach_header * mh, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol)
<a name="l00507"></a>00507 {
<a name="l00508"></a>00508    <span class="keywordtype">int</span> n;
<a name="l00509"></a>00509    <span class="keyword">struct </span>load_command *lc = 0;
<a name="l00510"></a>00510    <span class="keyword">struct </span>mach_header *wh;
<a name="l00511"></a>00511    NSSymbol *nssym = 0;
<a name="l00512"></a>00512    <span class="keywordflow">if</span> (<a class="code" href="dlfcn_8c.html#83168d8db5a85df2b3e7898c1230942f">dyld_NSAddImage</a> &amp;&amp; dyld_NSIsSymbolNameDefinedInImage &amp;&amp; dyld_NSLookupSymbolInImage)
<a name="l00513"></a>00513    {
<a name="l00514"></a>00514       lc = (<span class="keyword">struct </span>load_command *)((<span class="keywordtype">char</span> *)mh + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mach_header));
<a name="l00515"></a>00515       <span class="keywordflow">for</span> (n = 0; n &lt; mh-&gt;ncmds; n++, lc = (<span class="keyword">struct</span> load_command *)((<span class="keywordtype">char</span> *)lc + lc-&gt;cmdsize))
<a name="l00516"></a>00516       {
<a name="l00517"></a>00517          <span class="keywordflow">if</span> ((LC_LOAD_DYLIB == lc-&gt;cmd) || (<a class="code" href="dlfcn_8c.html#fa155e16fdd5262004d5e3f58b998545">LC_LOAD_WEAK_DYLIB</a> == lc-&gt;cmd))
<a name="l00518"></a>00518          {
<a name="l00519"></a>00519             <span class="keywordflow">if</span> ((wh = (<span class="keyword">struct</span> mach_header *)
<a name="l00520"></a>00520                 <a class="code" href="dlfcn_8c.html#34ff4ec7602f0ad36f2c5c5429ded9d0">my_find_image</a>((<span class="keywordtype">char</span> *)(((<span class="keyword">struct</span> dylib_command *)lc)-&gt;dylib.name.offset +
<a name="l00521"></a>00521                                  (<span class="keywordtype">char</span> *)lc))))
<a name="l00522"></a>00522             {
<a name="l00523"></a>00523                <span class="keywordflow">if</span> (<a class="code" href="dlfcn_8c.html#8efc76b493fa04cbcff731ebe67cb41f">dyld_NSIsSymbolNameDefinedInImage</a>(wh, symbol))
<a name="l00524"></a>00524                {
<a name="l00525"></a>00525                   nssym = <a class="code" href="dlfcn_8c.html#9fc4abd8c5aaaa341566cf1cac760b38">dyld_NSLookupSymbolInImage</a>(wh,
<a name="l00526"></a>00526                                              symbol,
<a name="l00527"></a>00527                                              <a class="code" href="dlfcn_8c.html#cc050e8021ee1d5275232968a4c8e381">NSLOOKUPSYMBOLINIMAGE_OPTION_BIND</a> |
<a name="l00528"></a>00528                                              <a class="code" href="dlfcn_8c.html#093a56fc66d422a12e681349f7fc31ee">NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR</a>);
<a name="l00529"></a>00529                   <span class="keywordflow">break</span>;
<a name="l00530"></a>00530                }
<a name="l00531"></a>00531             }
<a name="l00532"></a>00532          }
<a name="l00533"></a>00533       }
<a name="l00534"></a>00534       <span class="keywordflow">if</span> ((!nssym) &amp;&amp; NSIsSymbolNameDefined(symbol))
<a name="l00535"></a>00535       {
<a name="l00536"></a>00536          <span class="comment">/* I've never seen this debug message...*/</span>
<a name="l00537"></a>00537          <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"Symbol \"%s\" is defined but was not found"</span>, symbol);
<a name="l00538"></a>00538       }
<a name="l00539"></a>00539    }
<a name="l00540"></a>00540    <span class="keywordflow">return</span> nssym;
<a name="l00541"></a>00541 }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 <span class="comment">/* Up to the caller to free() returned string */</span>
<a name="l00544"></a><a class="code" href="dlfcn_8c.html#c19c49edbff5e86e5280ee9f4c132344">00544</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#c19c49edbff5e86e5280ee9f4c132344">dyld_error_str</a>()
<a name="l00545"></a>00545 {
<a name="l00546"></a>00546    NSLinkEditErrors dylder;
<a name="l00547"></a>00547    <span class="keywordtype">int</span> dylderno;
<a name="l00548"></a>00548    <span class="keyword">const</span> <span class="keywordtype">char</span> *dylderrstr;
<a name="l00549"></a>00549    <span class="keyword">const</span> <span class="keywordtype">char</span> *dyldfile;
<a name="l00550"></a>00550    <span class="keyword">const</span> <span class="keywordtype">char</span>* retStr = NULL;
<a name="l00551"></a>00551    NSLinkEditError(&amp;dylder, &amp;dylderno, &amp;dyldfile, &amp;dylderrstr);
<a name="l00552"></a>00552    <span class="keywordflow">if</span> (dylderrstr &amp;&amp; strlen(dylderrstr))
<a name="l00553"></a>00553    {
<a name="l00554"></a>00554       retStr = <a class="code" href="astmm_8h.html#df74d22342f0da6246131193b1993a41">malloc</a>(strlen(dylderrstr) +1);
<a name="l00555"></a>00555       strcpy((<span class="keywordtype">char</span>*)retStr,dylderrstr);
<a name="l00556"></a>00556    }
<a name="l00557"></a>00557    <span class="keywordflow">return</span> retStr;
<a name="l00558"></a>00558 }
<a name="l00559"></a>00559 
<a name="l00560"></a><a class="code" href="dlfcn_8c.html#fbd7fb3690c8eff254f2690e831547b0">00560</a> <span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="dlfcn_8c.html#fbd7fb3690c8eff254f2690e831547b0">dlsymIntern</a>(<span class="keyword">struct</span> <a class="code" href="structdlstatus.html">dlstatus</a> *dls, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol, <span class="keywordtype">int</span> canSetError)
<a name="l00561"></a>00561 {
<a name="l00562"></a>00562    NSSymbol *nssym = 0;
<a name="l00563"></a>00563    <span class="keywordtype">void</span> *caller = __builtin_return_address(1);  <span class="comment">/* Be *very* careful about inlining */</span>
<a name="l00564"></a>00564    <span class="keyword">const</span> <span class="keyword">struct </span>mach_header *caller_mh = 0;
<a name="l00565"></a>00565    <span class="keyword">const</span> <span class="keywordtype">char</span>* savedErrorStr = NULL;
<a name="l00566"></a>00566    <a class="code" href="dlfcn_8c.html#f79dfe72a8a68fc21a7a43fdebe8771e">resetdlerror</a>();
<a name="l00567"></a>00567 <span class="preprocessor">#ifndef RTLD_SELF</span>
<a name="l00568"></a>00568 <span class="preprocessor"></span><span class="preprocessor">#define  RTLD_SELF      ((void *) -3)</span>
<a name="l00569"></a>00569 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00570"></a>00570 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (NULL == dls)
<a name="l00571"></a>00571       dls = <a class="code" href="dlfcn_8c.html#a4a62b2b396a125e09b721c4b48d19e9">RTLD_SELF</a>;
<a name="l00572"></a>00572    <span class="keywordflow">if</span> ((<a class="code" href="dlfcn-compat_8h.html#b5f76bc27279e5ac633f9109f8fa9de2">RTLD_NEXT</a> == dls) || (<a class="code" href="dlfcn_8c.html#a4a62b2b396a125e09b721c4b48d19e9">RTLD_SELF</a> == dls))
<a name="l00573"></a>00573    {
<a name="l00574"></a>00574       <span class="keywordflow">if</span> (dyld_NSIsSymbolNameDefinedInImage &amp;&amp; dyld_NSLookupSymbolInImage)
<a name="l00575"></a>00575       {
<a name="l00576"></a>00576          caller_mh = <a class="code" href="dlfcn_8c.html#edd4c3613a03834168b85d9192559af3">image_for_address</a>(caller);
<a name="l00577"></a>00577          <span class="keywordflow">if</span> (<a class="code" href="dlfcn_8c.html#a4a62b2b396a125e09b721c4b48d19e9">RTLD_SELF</a> == dls)
<a name="l00578"></a>00578          {
<a name="l00579"></a>00579             <span class="comment">/* FIXME: We should be using the NSModule api, if SELF is an MH_BUNDLE</span>
<a name="l00580"></a>00580 <span class="comment">             * But it appears to work anyway, and looking at the code in dyld_libfuncs.c</span>
<a name="l00581"></a>00581 <span class="comment">             * this is acceptable.</span>
<a name="l00582"></a>00582 <span class="comment">             */</span>
<a name="l00583"></a>00583             <span class="keywordflow">if</span> (<a class="code" href="dlfcn_8c.html#8efc76b493fa04cbcff731ebe67cb41f">dyld_NSIsSymbolNameDefinedInImage</a>(caller_mh, symbol))
<a name="l00584"></a>00584             {
<a name="l00585"></a>00585                nssym = <a class="code" href="dlfcn_8c.html#9fc4abd8c5aaaa341566cf1cac760b38">dyld_NSLookupSymbolInImage</a>(caller_mh,
<a name="l00586"></a>00586                                           symbol,
<a name="l00587"></a>00587                                           <a class="code" href="dlfcn_8c.html#cc050e8021ee1d5275232968a4c8e381">NSLOOKUPSYMBOLINIMAGE_OPTION_BIND</a> |
<a name="l00588"></a>00588                                           <a class="code" href="dlfcn_8c.html#093a56fc66d422a12e681349f7fc31ee">NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR</a>);
<a name="l00589"></a>00589             }
<a name="l00590"></a>00590          }
<a name="l00591"></a>00591          <span class="keywordflow">if</span> (!nssym)
<a name="l00592"></a>00592          {
<a name="l00593"></a>00593             <span class="keywordflow">if</span> (<a class="code" href="dlfcn_8c.html#a4a62b2b396a125e09b721c4b48d19e9">RTLD_SELF</a> == dls)
<a name="l00594"></a>00594                savedErrorStr = <a class="code" href="dlfcn_8c.html#c19c49edbff5e86e5280ee9f4c132344">dyld_error_str</a>();
<a name="l00595"></a>00595             nssym = <a class="code" href="dlfcn_8c.html#998125cc2be835ee34124f5221bdafce">search_linked_libs</a>(caller_mh, symbol);
<a name="l00596"></a>00596          }
<a name="l00597"></a>00597       }
<a name="l00598"></a>00598       <span class="keywordflow">else</span>
<a name="l00599"></a>00599       {
<a name="l00600"></a>00600          <span class="keywordflow">if</span> (canSetError)
<a name="l00601"></a>00601             <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"RTLD_SELF and RTLD_NEXT are not supported"</span>);
<a name="l00602"></a>00602          <span class="keywordflow">return</span> NULL;
<a name="l00603"></a>00603       }
<a name="l00604"></a>00604    }
<a name="l00605"></a>00605    <span class="keywordflow">if</span> (!nssym)
<a name="l00606"></a>00606    {
<a name="l00607"></a>00607 
<a name="l00608"></a>00608       <span class="keywordflow">if</span> (<a class="code" href="dlfcn-compat_8h.html#12a180c322ab561ff75b996c242fa84a">RTLD_DEFAULT</a> == dls)
<a name="l00609"></a>00609       {
<a name="l00610"></a>00610          dls = &amp;mainStatus;
<a name="l00611"></a>00611       }
<a name="l00612"></a>00612       <span class="keywordflow">if</span> (!<a class="code" href="dlfcn_8c.html#94cc9569b7b9d1547f14f2ce0e5512cd">isValidStatus</a>(dls))
<a name="l00613"></a>00613          <span class="keywordflow">return</span> NULL;
<a name="l00614"></a>00614 
<a name="l00615"></a>00615       <span class="keywordflow">if</span> (dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a> != <a class="code" href="dlfcn_8c.html#7a6b0bdbbd9df80fd3f1044b33625543">MAGIC_DYLIB_MOD</a>)
<a name="l00616"></a>00616       {
<a name="l00617"></a>00617          nssym = NSLookupSymbolInModule(dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>, symbol);
<a name="l00618"></a>00618          <span class="keywordflow">if</span> (!nssym &amp;&amp; NSIsSymbolNameDefined(symbol))
<a name="l00619"></a>00619          {
<a name="l00620"></a>00620             <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"Searching dependencies"</span>);
<a name="l00621"></a>00621             savedErrorStr = <a class="code" href="dlfcn_8c.html#c19c49edbff5e86e5280ee9f4c132344">dyld_error_str</a>();
<a name="l00622"></a>00622             nssym = <a class="code" href="dlfcn_8c.html#998125cc2be835ee34124f5221bdafce">search_linked_libs</a>(<a class="code" href="dlfcn_8c.html#980566f5f6d3ca4e4f01c5d3cced8327">get_mach_header_from_NSModule</a>(dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>), symbol);
<a name="l00623"></a>00623          }
<a name="l00624"></a>00624       }
<a name="l00625"></a>00625       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dls-&gt;<a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">lib</a> &amp;&amp; dyld_NSIsSymbolNameDefinedInImage &amp;&amp; dyld_NSLookupSymbolInImage)
<a name="l00626"></a>00626       {
<a name="l00627"></a>00627          <span class="keywordflow">if</span> (<a class="code" href="dlfcn_8c.html#8efc76b493fa04cbcff731ebe67cb41f">dyld_NSIsSymbolNameDefinedInImage</a>(dls-&gt;<a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">lib</a>, symbol))
<a name="l00628"></a>00628          {
<a name="l00629"></a>00629             nssym = <a class="code" href="dlfcn_8c.html#9fc4abd8c5aaaa341566cf1cac760b38">dyld_NSLookupSymbolInImage</a>(dls-&gt;<a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">lib</a>,
<a name="l00630"></a>00630                                        symbol,
<a name="l00631"></a>00631                                        <a class="code" href="dlfcn_8c.html#cc050e8021ee1d5275232968a4c8e381">NSLOOKUPSYMBOLINIMAGE_OPTION_BIND</a> |
<a name="l00632"></a>00632                                        <a class="code" href="dlfcn_8c.html#093a56fc66d422a12e681349f7fc31ee">NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR</a>);
<a name="l00633"></a>00633          }
<a name="l00634"></a>00634          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NSIsSymbolNameDefined(symbol))
<a name="l00635"></a>00635          {
<a name="l00636"></a>00636             <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"Searching dependencies"</span>);
<a name="l00637"></a>00637             savedErrorStr = <a class="code" href="dlfcn_8c.html#c19c49edbff5e86e5280ee9f4c132344">dyld_error_str</a>();
<a name="l00638"></a>00638             nssym = <a class="code" href="dlfcn_8c.html#998125cc2be835ee34124f5221bdafce">search_linked_libs</a>(dls-&gt;<a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">lib</a>, symbol);
<a name="l00639"></a>00639          }
<a name="l00640"></a>00640       }
<a name="l00641"></a>00641       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a> == <a class="code" href="dlfcn_8c.html#7a6b0bdbbd9df80fd3f1044b33625543">MAGIC_DYLIB_MOD</a>)
<a name="l00642"></a>00642       {
<a name="l00643"></a>00643          <span class="comment">/* Global context, use NSLookupAndBindSymbol */</span>
<a name="l00644"></a>00644          <span class="keywordflow">if</span> (NSIsSymbolNameDefined(symbol))
<a name="l00645"></a>00645          {
<a name="l00646"></a>00646             <span class="comment">/* There doesn't seem to be a return on error option for this call???</span>
<a name="l00647"></a>00647 <span class="comment">               this is potentially broken, if binding fails, it will improperly</span>
<a name="l00648"></a>00648 <span class="comment">               exit the application. */</span>
<a name="l00649"></a>00649             nssym = NSLookupAndBindSymbol(symbol);
<a name="l00650"></a>00650          }
<a name="l00651"></a>00651          <span class="keywordflow">else</span>
<a name="l00652"></a>00652          {
<a name="l00653"></a>00653             <span class="keywordflow">if</span> (savedErrorStr)
<a name="l00654"></a>00654                <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>((<span class="keywordtype">char</span>*)savedErrorStr);         
<a name="l00655"></a>00655             savedErrorStr = <a class="code" href="astmm_8h.html#df74d22342f0da6246131193b1993a41">malloc</a>(256);
<a name="l00656"></a>00656             snprintf((<span class="keywordtype">char</span>*)savedErrorStr, 256, <span class="stringliteral">"Symbol \"%s\" not in global context"</span>,symbol);  
<a name="l00657"></a>00657          }
<a name="l00658"></a>00658       }
<a name="l00659"></a>00659    }
<a name="l00660"></a>00660    <span class="comment">/* Error reporting */</span>
<a name="l00661"></a>00661    <span class="keywordflow">if</span> (!nssym)
<a name="l00662"></a>00662    {
<a name="l00663"></a>00663       <span class="keywordflow">if</span> (!savedErrorStr || !strlen(savedErrorStr))
<a name="l00664"></a>00664       {
<a name="l00665"></a>00665          <span class="keywordflow">if</span> (savedErrorStr)
<a name="l00666"></a>00666             <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>((<span class="keywordtype">char</span>*)savedErrorStr);
<a name="l00667"></a>00667          savedErrorStr = <a class="code" href="astmm_8h.html#df74d22342f0da6246131193b1993a41">malloc</a>(256);
<a name="l00668"></a>00668          snprintf((<span class="keywordtype">char</span>*)savedErrorStr, 256,<span class="stringliteral">"Symbol \"%s\" not found"</span>,symbol);
<a name="l00669"></a>00669       }
<a name="l00670"></a>00670       <span class="keywordflow">if</span> (canSetError)
<a name="l00671"></a>00671       {
<a name="l00672"></a>00672          <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(savedErrorStr);
<a name="l00673"></a>00673       }
<a name="l00674"></a>00674       <span class="keywordflow">else</span>
<a name="l00675"></a>00675       {
<a name="l00676"></a>00676          <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(savedErrorStr);
<a name="l00677"></a>00677       }
<a name="l00678"></a>00678       <span class="keywordflow">if</span> (savedErrorStr)
<a name="l00679"></a>00679          <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>((<span class="keywordtype">char</span>*)savedErrorStr);
<a name="l00680"></a>00680       <span class="keywordflow">return</span> NULL;
<a name="l00681"></a>00681    }
<a name="l00682"></a>00682    <span class="keywordflow">return</span> NSAddressOfSymbol(nssym);
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
<a name="l00685"></a><a class="code" href="dlfcn_8c.html#3ccd00c1b00c0a0c2098a526ed71fe32">00685</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *<a class="code" href="dlfcn_8c.html#3ccd00c1b00c0a0c2098a526ed71fe32">loadModule</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keyword">const</span> <span class="keyword">struct</span> stat *sbuf, <span class="keywordtype">int</span> mode)
<a name="l00686"></a>00686 {
<a name="l00687"></a>00687    NSObjectFileImage ofi = 0;
<a name="l00688"></a>00688    NSObjectFileImageReturnCode ofirc;
<a name="l00689"></a>00689    <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *dls;
<a name="l00690"></a>00690    NSLinkEditErrors ler;
<a name="l00691"></a>00691    <span class="keywordtype">int</span> lerno;
<a name="l00692"></a>00692    <span class="keyword">const</span> <span class="keywordtype">char</span> *errstr;
<a name="l00693"></a>00693    <span class="keyword">const</span> <span class="keywordtype">char</span> *file;
<a name="l00694"></a>00694    void (*init) (void);
<a name="l00695"></a>00695    ofirc = NSCreateObjectFileImageFromFile(path, &amp;ofi);
<a name="l00696"></a>00696    <span class="keywordflow">switch</span> (ofirc)
<a name="l00697"></a>00697    {
<a name="l00698"></a>00698       <span class="keywordflow">case</span> NSObjectFileImageSuccess:
<a name="l00699"></a>00699          <span class="keywordflow">break</span>;
<a name="l00700"></a>00700       <span class="keywordflow">case</span> NSObjectFileImageInappropriateFile:
<a name="l00701"></a>00701          <span class="keywordflow">if</span> (<a class="code" href="dlfcn_8c.html#83168d8db5a85df2b3e7898c1230942f">dyld_NSAddImage</a> &amp;&amp; dyld_NSIsSymbolNameDefinedInImage &amp;&amp; dyld_NSLookupSymbolInImage)
<a name="l00702"></a>00702          {
<a name="l00703"></a>00703             <span class="keywordflow">if</span> (!<a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">isFlagSet</a>(mode, <a class="code" href="dlfcn-compat_8h.html#d565d5d83850e65f4dc43e403df7a3db">RTLD_GLOBAL</a>))
<a name="l00704"></a>00704             {
<a name="l00705"></a>00705                <a class="code" href="dlfcn_8c.html#a0054ad56afd71085b56813f21a1544c">warning</a>(<span class="stringliteral">"trying to open a .dylib with RTLD_LOCAL"</span>);
<a name="l00706"></a>00706                <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"unable to open this file with RTLD_LOCAL"</span>);
<a name="l00707"></a>00707                <span class="keywordflow">return</span> NULL;
<a name="l00708"></a>00708             }
<a name="l00709"></a>00709          }
<a name="l00710"></a>00710          <span class="keywordflow">else</span>
<a name="l00711"></a>00711          {
<a name="l00712"></a>00712             <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"opening this file is unsupported on this system"</span>);
<a name="l00713"></a>00713             <span class="keywordflow">return</span> NULL;
<a name="l00714"></a>00714          }
<a name="l00715"></a>00715          <span class="keywordflow">break</span>;
<a name="l00716"></a>00716       <span class="keywordflow">case</span> NSObjectFileImageFailure:
<a name="l00717"></a>00717          <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"object file setup failure"</span>);
<a name="l00718"></a>00718          <span class="keywordflow">return</span> NULL;
<a name="l00719"></a>00719       <span class="keywordflow">case</span> NSObjectFileImageArch:
<a name="l00720"></a>00720          <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"no object for this architecture"</span>);
<a name="l00721"></a>00721          <span class="keywordflow">return</span> NULL;
<a name="l00722"></a>00722       <span class="keywordflow">case</span> NSObjectFileImageFormat:
<a name="l00723"></a>00723          <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"bad object file format"</span>);
<a name="l00724"></a>00724          <span class="keywordflow">return</span> NULL;
<a name="l00725"></a>00725       <span class="keywordflow">case</span> NSObjectFileImageAccess:
<a name="l00726"></a>00726          <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"can't read object file"</span>);
<a name="l00727"></a>00727          <span class="keywordflow">return</span> NULL;
<a name="l00728"></a>00728       <span class="keywordflow">default</span>:
<a name="l00729"></a>00729          <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"unknown error from NSCreateObjectFileImageFromFile()"</span>);
<a name="l00730"></a>00730          <span class="keywordflow">return</span> NULL;
<a name="l00731"></a>00731    }
<a name="l00732"></a>00732    dls = <a class="code" href="dlfcn_8c.html#302bcae6e1b779aec6b07c4891b9283f">lookupStatus</a>(sbuf);
<a name="l00733"></a>00733    <span class="keywordflow">if</span> (!dls)
<a name="l00734"></a>00734    {
<a name="l00735"></a>00735       dls = <a class="code" href="dlfcn_8c.html#f9967e34823d8729bf12f0fad36a885d">allocStatus</a>();
<a name="l00736"></a>00736    }
<a name="l00737"></a>00737    <span class="keywordflow">if</span> (!dls)
<a name="l00738"></a>00738    {
<a name="l00739"></a>00739       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"unable to allocate memory"</span>);
<a name="l00740"></a>00740       <span class="keywordflow">return</span> NULL;
<a name="l00741"></a>00741    }
<a name="l00742"></a>00742    dls-&gt;<a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">lib</a> = 0;
<a name="l00743"></a>00743    <span class="keywordflow">if</span> (ofirc == NSObjectFileImageInappropriateFile)
<a name="l00744"></a>00744    {
<a name="l00745"></a>00745       <span class="keywordflow">if</span> ((dls-&gt;<a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">lib</a> = <a class="code" href="dlfcn_8c.html#83168d8db5a85df2b3e7898c1230942f">dyld_NSAddImage</a>(path, <a class="code" href="dlfcn_8c.html#8bef999e98f5b17a42537ade68c2db1d">NSADDIMAGE_OPTION_RETURN_ON_ERROR</a>)))
<a name="l00746"></a>00746       {
<a name="l00747"></a>00747          <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"Dynamic lib loaded at %ld"</span>, dls-&gt;<a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">lib</a>);
<a name="l00748"></a>00748          ofi = <a class="code" href="dlfcn_8c.html#833480468fa097cbd87d801ddbb89555">MAGIC_DYLIB_OFI</a>;
<a name="l00749"></a>00749          dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a> = <a class="code" href="dlfcn_8c.html#7a6b0bdbbd9df80fd3f1044b33625543">MAGIC_DYLIB_MOD</a>;
<a name="l00750"></a>00750          ofirc = NSObjectFileImageSuccess;
<a name="l00751"></a>00751          <span class="comment">/* Although it is possible with a bit of work to modify this so it works and</span>
<a name="l00752"></a>00752 <span class="comment">            functions with RTLD_NOW, I don't deem it necessary at the moment */</span>
<a name="l00753"></a>00753       }
<a name="l00754"></a>00754       <span class="keywordflow">if</span> (!(dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>))
<a name="l00755"></a>00755       {
<a name="l00756"></a>00756          NSLinkEditError(&amp;ler, &amp;lerno, &amp;file, &amp;errstr);
<a name="l00757"></a>00757          <span class="keywordflow">if</span> (!errstr || (!strlen(errstr)))
<a name="l00758"></a>00758             <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"Can't open this file type"</span>);
<a name="l00759"></a>00759          <span class="keywordflow">else</span>
<a name="l00760"></a>00760             <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(errstr);
<a name="l00761"></a>00761          <span class="keywordflow">if</span> ((dls-&gt;<a class="code" href="structdlstatus.html#4e5868d676cb634aa75b125a0f741abf">flags</a> &amp; <a class="code" href="dlfcn_8c.html#623f5284ca0d69050730d335ec3322c8">DL_IN_LIST</a>) == 0)
<a name="l00762"></a>00762          {
<a name="l00763"></a>00763             <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>(dls);
<a name="l00764"></a>00764          }
<a name="l00765"></a>00765          <span class="keywordflow">return</span> NULL;
<a name="l00766"></a>00766       }
<a name="l00767"></a>00767    }
<a name="l00768"></a>00768    <span class="keywordflow">else</span>
<a name="l00769"></a>00769    {
<a name="l00770"></a>00770       dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a> = NSLinkModule(ofi, path,
<a name="l00771"></a>00771                            NSLINKMODULE_OPTION_RETURN_ON_ERROR |
<a name="l00772"></a>00772                            NSLINKMODULE_OPTION_PRIVATE |
<a name="l00773"></a>00773                            (<a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">isFlagSet</a>(mode, <a class="code" href="loader_8c.html#cebd9c7b300fbb075a0eb012c43879e8">RTLD_NOW</a>) ? NSLINKMODULE_OPTION_BINDNOW : 0));
<a name="l00774"></a>00774       NSDestroyObjectFileImage(ofi);
<a name="l00775"></a>00775       <span class="keywordflow">if</span> (dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>)
<a name="l00776"></a>00776       {
<a name="l00777"></a>00777          dls-&gt;<a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">lib</a> = <a class="code" href="dlfcn_8c.html#980566f5f6d3ca4e4f01c5d3cced8327">get_mach_header_from_NSModule</a>(dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>);
<a name="l00778"></a>00778       }
<a name="l00779"></a>00779    }
<a name="l00780"></a>00780    <span class="keywordflow">if</span> (!dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>)
<a name="l00781"></a>00781    {
<a name="l00782"></a>00782       NSLinkEditError(&amp;ler, &amp;lerno, &amp;file, &amp;errstr);
<a name="l00783"></a>00783       <span class="keywordflow">if</span> ((dls-&gt;<a class="code" href="structdlstatus.html#4e5868d676cb634aa75b125a0f741abf">flags</a> &amp; <a class="code" href="dlfcn_8c.html#623f5284ca0d69050730d335ec3322c8">DL_IN_LIST</a>) == 0)
<a name="l00784"></a>00784       {
<a name="l00785"></a>00785          <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>(dls);
<a name="l00786"></a>00786       }
<a name="l00787"></a>00787       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(errstr);
<a name="l00788"></a>00788       <span class="keywordflow">return</span> NULL;
<a name="l00789"></a>00789    }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791    <a class="code" href="dlfcn_8c.html#873dbb061fe03446f7abde7d232472c5">insertStatus</a>(dls, sbuf);
<a name="l00792"></a>00792    dls = <a class="code" href="dlfcn_8c.html#f9549c9322f3ac5e9f28e0bb7552f8a1">reference</a>(dls, mode);
<a name="l00793"></a>00793    <span class="keywordflow">if</span> ((init = <a class="code" href="dlfcn_8c.html#fbd7fb3690c8eff254f2690e831547b0">dlsymIntern</a>(dls, <span class="stringliteral">"__init"</span>, 0)))
<a name="l00794"></a>00794    {
<a name="l00795"></a>00795       <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"calling _init()"</span>);
<a name="l00796"></a>00796       init();
<a name="l00797"></a>00797    }
<a name="l00798"></a>00798    <span class="keywordflow">return</span> dls;
<a name="l00799"></a>00799 }
<a name="l00800"></a>00800 
<a name="l00801"></a><a class="code" href="dlfcn_8c.html#83f7d76f85298415785439b62103645f">00801</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#83f7d76f85298415785439b62103645f">dlcompat_init_func</a>(<span class="keywordtype">void</span>)
<a name="l00802"></a>00802 {
<a name="l00803"></a>00803    <span class="keyword">static</span> <span class="keywordtype">int</span> inited = 0;
<a name="l00804"></a>00804    <span class="keywordflow">if</span> (!inited)
<a name="l00805"></a>00805    {
<a name="l00806"></a>00806       inited = 1;
<a name="l00807"></a>00807       _dyld_func_lookup(<span class="stringliteral">"__dyld_NSAddImage"</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;<a class="code" href="dlfcn_8c.html#83168d8db5a85df2b3e7898c1230942f">dyld_NSAddImage</a>);
<a name="l00808"></a>00808       _dyld_func_lookup(<span class="stringliteral">"__dyld_NSIsSymbolNameDefinedInImage"</span>,
<a name="l00809"></a>00809                     (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;dyld_NSIsSymbolNameDefinedInImage);
<a name="l00810"></a>00810       _dyld_func_lookup(<span class="stringliteral">"__dyld_NSLookupSymbolInImage"</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)&amp;dyld_NSLookupSymbolInImage);
<a name="l00811"></a>00811       <span class="keywordflow">if</span> (<a class="code" href="lock_8h.html#0ed3695ec827e8564009fb1c31e24d87">pthread_mutex_init</a>(&amp;dlcompat_mutex, NULL))
<a name="l00812"></a>00812          exit(1);
<a name="l00813"></a>00813       <span class="keywordflow">if</span> (pthread_key_create(&amp;dlerror_key, &amp;<a class="code" href="dlfcn_8c.html#ce385803b09da205cc80aafca2fb1d11">dlerrorfree</a>))
<a name="l00814"></a>00814          exit(1);
<a name="l00815"></a>00815       <span class="comment">/* And be neat and tidy and clean up after ourselves */</span>  
<a name="l00816"></a>00816       atexit(<a class="code" href="dlfcn_8c.html#03f64046de974f91c1e196b315f17a6f">dlcompat_cleanup</a>);
<a name="l00817"></a>00817    }
<a name="l00818"></a>00818 }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 <span class="preprocessor">#if 0</span>
<a name="l00821"></a>00821 <span class="preprocessor"></span><span class="preprocessor">#pragma CALL_ON_LOAD dlcompat_init_func</span>
<a name="l00822"></a>00822 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00823"></a>00823 <span class="preprocessor"></span>
<a name="l00824"></a><a class="code" href="dlfcn_8c.html#03f64046de974f91c1e196b315f17a6f">00824</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#03f64046de974f91c1e196b315f17a6f">dlcompat_cleanup</a>(<span class="keywordtype">void</span>)
<a name="l00825"></a>00825 {
<a name="l00826"></a>00826    <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *dls;
<a name="l00827"></a>00827    <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *<a class="code" href="structdlstatus.html#d0cab90d8d20d57e2f2b9be52f7dd25d">next</a>;
<a name="l00828"></a>00828    <span class="keywordtype">char</span> *data;
<a name="l00829"></a>00829    data = (<span class="keywordtype">char</span> *)<a class="code" href="dlfcn_8c.html#e3b786dcfbda95c5708dc4e648cb3fd8">searchList</a>();
<a name="l00830"></a>00830    <span class="keywordflow">if</span> ( data )
<a name="l00831"></a>00831       <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>( data );
<a name="l00832"></a>00832    data =   (<span class="keywordtype">char</span> *)<a class="code" href="dlfcn_8c.html#d51feb8815c9b0ac6afdcc317a0feded">getSearchPath</a>(-1);
<a name="l00833"></a>00833    <span class="keywordflow">if</span> ( data )
<a name="l00834"></a>00834       <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>( data );
<a name="l00835"></a>00835    <a class="code" href="lock_8h.html#935427d30189c26fb39425a12c9db3a1">pthread_mutex_destroy</a>(&amp;dlcompat_mutex);
<a name="l00836"></a>00836    pthread_key_delete(dlerror_key);
<a name="l00837"></a>00837    next = stqueue;
<a name="l00838"></a>00838    <span class="keywordflow">while</span> (next &amp;&amp; (next != &amp;mainStatus))
<a name="l00839"></a>00839    {
<a name="l00840"></a>00840       dls = next;
<a name="l00841"></a>00841       next = dls-&gt;<a class="code" href="structdlstatus.html#d0cab90d8d20d57e2f2b9be52f7dd25d">next</a>;
<a name="l00842"></a>00842       <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>(dls);
<a name="l00843"></a>00843    }
<a name="l00844"></a>00844 }
<a name="l00845"></a>00845 
<a name="l00846"></a><a class="code" href="dlfcn_8c.html#f79dfe72a8a68fc21a7a43fdebe8771e">00846</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#f79dfe72a8a68fc21a7a43fdebe8771e">resetdlerror</a>()
<a name="l00847"></a>00847 {
<a name="l00848"></a>00848    <span class="keyword">struct </span><a class="code" href="structdlthread.html">dlthread</a> *tss;
<a name="l00849"></a>00849    tss = pthread_getspecific(dlerror_key);
<a name="l00850"></a>00850    tss-&gt;<a class="code" href="structdlthread.html#1d0e9ad7d1908eaf205e819f3255f92c">errset</a> = 0;
<a name="l00851"></a>00851 }
<a name="l00852"></a>00852 
<a name="l00853"></a><a class="code" href="dlfcn_8c.html#ce385803b09da205cc80aafca2fb1d11">00853</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#ce385803b09da205cc80aafca2fb1d11">dlerrorfree</a>(<span class="keywordtype">void</span> *data)
<a name="l00854"></a>00854 {
<a name="l00855"></a>00855    <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>(data);
<a name="l00856"></a>00856 }
<a name="l00857"></a>00857 
<a name="l00858"></a>00858 <span class="comment">/* We kind of want a recursive lock here, but meet a little trouble</span>
<a name="l00859"></a>00859 <span class="comment"> * because they are not available pre OS X 10.2, so we fake it</span>
<a name="l00860"></a>00860 <span class="comment"> * using thread specific storage to keep a lock count</span>
<a name="l00861"></a>00861 <span class="comment"> */</span> 
<a name="l00862"></a><a class="code" href="dlfcn_8c.html#3173031af7d4b847c50f22264d505a2a">00862</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#3173031af7d4b847c50f22264d505a2a">dolock</a>(<span class="keywordtype">void</span>)
<a name="l00863"></a>00863 {
<a name="l00864"></a>00864    <span class="keywordtype">int</span> err = 0;
<a name="l00865"></a>00865    <span class="keyword">struct </span><a class="code" href="structdlthread.html">dlthread</a> *tss;
<a name="l00866"></a>00866    tss = pthread_getspecific(dlerror_key);
<a name="l00867"></a>00867    <span class="keywordflow">if</span> (!tss)
<a name="l00868"></a>00868    {
<a name="l00869"></a>00869       tss = <a class="code" href="astmm_8h.html#df74d22342f0da6246131193b1993a41">malloc</a>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structdlthread.html">dlthread</a>));
<a name="l00870"></a>00870       tss-&gt;<a class="code" href="structdlthread.html#bd85d310fd6d0c567721fcfae6a5b559">lockcnt</a> = 0;
<a name="l00871"></a>00871       tss-&gt;<a class="code" href="structdlthread.html#1d0e9ad7d1908eaf205e819f3255f92c">errset</a> = 0;
<a name="l00872"></a>00872       <span class="keywordflow">if</span> (pthread_setspecific(dlerror_key, tss))
<a name="l00873"></a>00873       {
<a name="l00874"></a>00874          fprintf(stderr,<span class="stringliteral">"dlcompat: pthread_setspecific failed\n"</span>);
<a name="l00875"></a>00875          exit(1);
<a name="l00876"></a>00876       }
<a name="l00877"></a>00877    }
<a name="l00878"></a>00878    <span class="keywordflow">if</span> (!tss-&gt;<a class="code" href="structdlthread.html#bd85d310fd6d0c567721fcfae6a5b559">lockcnt</a>)
<a name="l00879"></a>00879       err = <a class="code" href="lock_8h.html#bfd7b8e018ae42daf1c03f52e64e036a">pthread_mutex_lock</a>(&amp;dlcompat_mutex);
<a name="l00880"></a>00880    tss-&gt;<a class="code" href="structdlthread.html#bd85d310fd6d0c567721fcfae6a5b559">lockcnt</a> = tss-&gt;<a class="code" href="structdlthread.html#bd85d310fd6d0c567721fcfae6a5b559">lockcnt</a> +1;  
<a name="l00881"></a>00881    <span class="keywordflow">if</span> (err)
<a name="l00882"></a>00882       exit(err);
<a name="l00883"></a>00883 }
<a name="l00884"></a>00884 
<a name="l00885"></a><a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">00885</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>(<span class="keywordtype">void</span>)
<a name="l00886"></a>00886 {
<a name="l00887"></a>00887    <span class="keywordtype">int</span> err = 0;
<a name="l00888"></a>00888    <span class="keyword">struct </span><a class="code" href="structdlthread.html">dlthread</a> *tss;
<a name="l00889"></a>00889    tss = pthread_getspecific(dlerror_key);
<a name="l00890"></a>00890    tss-&gt;<a class="code" href="structdlthread.html#bd85d310fd6d0c567721fcfae6a5b559">lockcnt</a> = tss-&gt;<a class="code" href="structdlthread.html#bd85d310fd6d0c567721fcfae6a5b559">lockcnt</a> -1;
<a name="l00891"></a>00891    <span class="keywordflow">if</span> (!tss-&gt;<a class="code" href="structdlthread.html#bd85d310fd6d0c567721fcfae6a5b559">lockcnt</a>)
<a name="l00892"></a>00892       err = <a class="code" href="lock_8h.html#ed02ace186d080ebc5159344e5732300">pthread_mutex_unlock</a>(&amp;dlcompat_mutex);
<a name="l00893"></a>00893    <span class="keywordflow">if</span> (err)
<a name="l00894"></a>00894       exit(err);
<a name="l00895"></a>00895 }
<a name="l00896"></a>00896 
<a name="l00897"></a><a class="code" href="dlfcn-compat_8h.html#d4ea5e7e662612dc0e5a7ad0ff1e33b0">00897</a> <span class="keywordtype">void</span> *<a class="code" href="dlfcn_8c.html#d4ea5e7e662612dc0e5a7ad0ff1e33b0">dlopen</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> mode)
<a name="l00898"></a>00898 {
<a name="l00899"></a>00899    <span class="keyword">const</span> <span class="keyword">struct </span>stat *sbuf;
<a name="l00900"></a>00900    <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *dls;
<a name="l00901"></a>00901    <span class="keyword">const</span> <span class="keywordtype">char</span> *fullPath;
<a name="l00902"></a>00902    <a class="code" href="dlfcn_8c.html#83f7d76f85298415785439b62103645f">dlcompat_init_func</a>();      <span class="comment">/* Just in case */</span>
<a name="l00903"></a>00903    <a class="code" href="dlfcn_8c.html#3173031af7d4b847c50f22264d505a2a">dolock</a>();
<a name="l00904"></a>00904    <a class="code" href="dlfcn_8c.html#f79dfe72a8a68fc21a7a43fdebe8771e">resetdlerror</a>();
<a name="l00905"></a>00905    <span class="keywordflow">if</span> (!path)
<a name="l00906"></a>00906    {
<a name="l00907"></a>00907       dls = &amp;mainStatus;
<a name="l00908"></a>00908       <span class="keywordflow">goto</span> dlopenok;
<a name="l00909"></a>00909    }
<a name="l00910"></a>00910    <span class="keywordflow">if</span> (!(sbuf = <a class="code" href="dlfcn_8c.html#5ce6066f9cbcf99b3cc6d47bc288daa8">findFile</a>(path, &amp;fullPath)))
<a name="l00911"></a>00911    {
<a name="l00912"></a>00912       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"file \"%s\" not found"</span>, path);
<a name="l00913"></a>00913       <span class="keywordflow">goto</span> dlopenerror;
<a name="l00914"></a>00914    }
<a name="l00915"></a>00915    <span class="comment">/* Now checks that it hasn't been closed already */</span>
<a name="l00916"></a>00916    <span class="keywordflow">if</span> ((dls = <a class="code" href="dlfcn_8c.html#302bcae6e1b779aec6b07c4891b9283f">lookupStatus</a>(sbuf)) &amp;&amp; (dls-&gt;<a class="code" href="structdlstatus.html#5740713f144552f73502d802bc23dd35">refs</a> &gt; 0))
<a name="l00917"></a>00917    {
<a name="l00918"></a>00918       <span class="comment">/* debug("status found"); */</span>
<a name="l00919"></a>00919       dls = <a class="code" href="dlfcn_8c.html#f9549c9322f3ac5e9f28e0bb7552f8a1">reference</a>(dls, mode);
<a name="l00920"></a>00920       <span class="keywordflow">goto</span> dlopenok;
<a name="l00921"></a>00921    }
<a name="l00922"></a>00922 <span class="preprocessor">#ifdef   RTLD_NOLOAD</span>
<a name="l00923"></a>00923 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (<a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">isFlagSet</a>(mode, <a class="code" href="dlfcn-compat_8h.html#cb78ca118dbf7ce21081e05f1a0e1406">RTLD_NOLOAD</a>))
<a name="l00924"></a>00924    {
<a name="l00925"></a>00925       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"no existing handle and RTLD_NOLOAD specified"</span>);
<a name="l00926"></a>00926       <span class="keywordflow">goto</span> dlopenerror;
<a name="l00927"></a>00927    }
<a name="l00928"></a>00928 <span class="preprocessor">#endif</span>
<a name="l00929"></a>00929 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (<a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">isFlagSet</a>(mode, <a class="code" href="dlfcn-compat_8h.html#8884c6632ee6d253203a2d6deb4b7354">RTLD_LAZY</a>) &amp;&amp; <a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">isFlagSet</a>(mode, <a class="code" href="loader_8c.html#cebd9c7b300fbb075a0eb012c43879e8">RTLD_NOW</a>))
<a name="l00930"></a>00930    {
<a name="l00931"></a>00931       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"how can I load something both RTLD_LAZY and RTLD_NOW?"</span>);
<a name="l00932"></a>00932       <span class="keywordflow">goto</span> dlopenerror;
<a name="l00933"></a>00933    }
<a name="l00934"></a>00934    dls = <a class="code" href="dlfcn_8c.html#3ccd00c1b00c0a0c2098a526ed71fe32">loadModule</a>(fullPath, sbuf, mode);
<a name="l00935"></a>00935    
<a name="l00936"></a>00936   dlopenok:
<a name="l00937"></a>00937    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l00938"></a>00938    <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)dls;
<a name="l00939"></a>00939   dlopenerror:
<a name="l00940"></a>00940    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l00941"></a>00941    <span class="keywordflow">return</span> NULL;
<a name="l00942"></a>00942 }
<a name="l00943"></a>00943 
<a name="l00944"></a>00944 <span class="preprocessor">#if !FINK_BUILD</span>
<a name="l00945"></a><a class="code" href="dlfcn-compat_8h.html#def04fd1fe7f4abea4e0f3df9745048d">00945</a> <span class="preprocessor"></span><span class="keywordtype">void</span> *<a class="code" href="dlfcn_8c.html#def04fd1fe7f4abea4e0f3df9745048d">dlsym</a>(<span class="keywordtype">void</span> * <a class="code" href="dlfcn_8c.html#e3405fce965daa65a1561ec53eafb46b">dl_restrict</a> handle, <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="dlfcn_8c.html#e3405fce965daa65a1561ec53eafb46b">dl_restrict</a> symbol)
<a name="l00946"></a>00946 {
<a name="l00947"></a>00947    <span class="keywordtype">int</span> sym_len = strlen(symbol);
<a name="l00948"></a>00948    <span class="keywordtype">void</span> *value = NULL;
<a name="l00949"></a>00949    <span class="keywordtype">char</span> *malloc_sym = NULL;
<a name="l00950"></a>00950    <a class="code" href="dlfcn_8c.html#3173031af7d4b847c50f22264d505a2a">dolock</a>();
<a name="l00951"></a>00951    malloc_sym = <a class="code" href="astmm_8h.html#df74d22342f0da6246131193b1993a41">malloc</a>(sym_len + 2);
<a name="l00952"></a>00952    <span class="keywordflow">if</span> (malloc_sym)
<a name="l00953"></a>00953    {
<a name="l00954"></a>00954       sprintf(malloc_sym, <span class="stringliteral">"_%s"</span>, symbol);
<a name="l00955"></a>00955       value = <a class="code" href="dlfcn_8c.html#fbd7fb3690c8eff254f2690e831547b0">dlsymIntern</a>(handle, malloc_sym, 1);
<a name="l00956"></a>00956       <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>(malloc_sym);
<a name="l00957"></a>00957    }
<a name="l00958"></a>00958    <span class="keywordflow">else</span>
<a name="l00959"></a>00959    {
<a name="l00960"></a>00960       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"Unable to allocate memory"</span>);
<a name="l00961"></a>00961       <span class="keywordflow">goto</span> dlsymerror;
<a name="l00962"></a>00962    }
<a name="l00963"></a>00963    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l00964"></a>00964    <span class="keywordflow">return</span> value;
<a name="l00965"></a>00965   dlsymerror:
<a name="l00966"></a>00966    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l00967"></a>00967    <span class="keywordflow">return</span> NULL;
<a name="l00968"></a>00968 }
<a name="l00969"></a>00969 <span class="preprocessor">#endif</span>
<a name="l00970"></a>00970 <span class="preprocessor"></span>
<a name="l00971"></a>00971 <span class="preprocessor">#if FINK_BUILD</span>
<a name="l00972"></a>00972 <span class="preprocessor"></span>
<a name="l00973"></a>00973 <span class="keywordtype">void</span> *dlsym_prepend_underscore(<span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol)
<a name="l00974"></a>00974 {
<a name="l00975"></a>00975    <span class="keywordtype">void</span> *<a class="code" href="answer_8h.html#e308b49e5dc27c5848510086e585d7e1">answer</a>;
<a name="l00976"></a>00976    <a class="code" href="dlfcn_8c.html#3173031af7d4b847c50f22264d505a2a">dolock</a>();
<a name="l00977"></a>00977    answer = dlsym_prepend_underscore_intern(handle, symbol);
<a name="l00978"></a>00978    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l00979"></a>00979    <span class="keywordflow">return</span> answer;
<a name="l00980"></a>00980 }
<a name="l00981"></a>00981 
<a name="l00982"></a>00982 <span class="keyword">static</span> <span class="keywordtype">void</span> *dlsym_prepend_underscore_intern(<span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol)
<a name="l00983"></a>00983 {
<a name="l00984"></a>00984 <span class="comment">/*</span>
<a name="l00985"></a>00985 <span class="comment"> * A quick and easy way for porting packages which call dlsym(handle,"sym")</span>
<a name="l00986"></a>00986 <span class="comment"> * If the porter adds -Ddlsym=dlsym_prepend_underscore to the CFLAGS then</span>
<a name="l00987"></a>00987 <span class="comment"> * this function will be called, and will add the required underscore.</span>
<a name="l00988"></a>00988 <span class="comment"> * </span>
<a name="l00989"></a>00989 <span class="comment"> * Note that I haven't figured out yet which should be "standard", prepend</span>
<a name="l00990"></a>00990 <span class="comment"> * the underscore always, or not at all. These global functions need to go away</span>
<a name="l00991"></a>00991 <span class="comment"> * for opendarwin.</span>
<a name="l00992"></a>00992 <span class="comment"> */</span>
<a name="l00993"></a>00993    <span class="keywordtype">int</span> sym_len = strlen(symbol);
<a name="l00994"></a>00994    <span class="keywordtype">void</span> *value = NULL;
<a name="l00995"></a>00995    <span class="keywordtype">char</span> *malloc_sym = NULL;
<a name="l00996"></a>00996    malloc_sym = <a class="code" href="astmm_8h.html#df74d22342f0da6246131193b1993a41">malloc</a>(sym_len + 2);
<a name="l00997"></a>00997    <span class="keywordflow">if</span> (malloc_sym)
<a name="l00998"></a>00998    {
<a name="l00999"></a>00999       sprintf(malloc_sym, <span class="stringliteral">"_%s"</span>, symbol);
<a name="l01000"></a>01000       value = <a class="code" href="dlfcn_8c.html#fbd7fb3690c8eff254f2690e831547b0">dlsymIntern</a>(handle, malloc_sym, 1);
<a name="l01001"></a>01001       <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>(malloc_sym);
<a name="l01002"></a>01002    }
<a name="l01003"></a>01003    <span class="keywordflow">else</span>
<a name="l01004"></a>01004    {
<a name="l01005"></a>01005       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"Unable to allocate memory"</span>);
<a name="l01006"></a>01006    }
<a name="l01007"></a>01007    <span class="keywordflow">return</span> value;
<a name="l01008"></a>01008 }
<a name="l01009"></a>01009 
<a name="l01010"></a>01010 <span class="keywordtype">void</span> *dlsym_auto_underscore(<span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol)
<a name="l01011"></a>01011 {
<a name="l01012"></a>01012    <span class="keywordtype">void</span> *<a class="code" href="answer_8h.html#e308b49e5dc27c5848510086e585d7e1">answer</a>;
<a name="l01013"></a>01013    <a class="code" href="dlfcn_8c.html#3173031af7d4b847c50f22264d505a2a">dolock</a>();
<a name="l01014"></a>01014    answer = dlsym_auto_underscore_intern(handle, symbol);
<a name="l01015"></a>01015    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l01016"></a>01016    <span class="keywordflow">return</span> answer;
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 }
<a name="l01019"></a>01019 <span class="keyword">static</span> <span class="keywordtype">void</span> *dlsym_auto_underscore_intern(<span class="keywordtype">void</span> *handle, <span class="keyword">const</span> <span class="keywordtype">char</span> *symbol)
<a name="l01020"></a>01020 {
<a name="l01021"></a>01021    <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *dls = handle;
<a name="l01022"></a>01022    <span class="keywordtype">void</span> *addr = 0;
<a name="l01023"></a>01023    addr = <a class="code" href="dlfcn_8c.html#fbd7fb3690c8eff254f2690e831547b0">dlsymIntern</a>(dls, symbol, 0);
<a name="l01024"></a>01024    <span class="keywordflow">if</span> (!addr)
<a name="l01025"></a>01025       addr = dlsym_prepend_underscore_intern(handle, symbol);
<a name="l01026"></a>01026    <span class="keywordflow">return</span> addr;
<a name="l01027"></a>01027 }
<a name="l01028"></a>01028 
<a name="l01029"></a>01029 
<a name="l01030"></a>01030 <span class="keywordtype">void</span> *<a class="code" href="dlfcn_8c.html#def04fd1fe7f4abea4e0f3df9745048d">dlsym</a>(<span class="keywordtype">void</span> * <a class="code" href="dlfcn_8c.html#e3405fce965daa65a1561ec53eafb46b">dl_restrict</a> handle, <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="dlfcn_8c.html#e3405fce965daa65a1561ec53eafb46b">dl_restrict</a> symbol)
<a name="l01031"></a>01031 {
<a name="l01032"></a>01032    <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *dls = handle;
<a name="l01033"></a>01033    <span class="keywordtype">void</span> *addr = 0;
<a name="l01034"></a>01034    <a class="code" href="dlfcn_8c.html#3173031af7d4b847c50f22264d505a2a">dolock</a>();
<a name="l01035"></a>01035    addr = <a class="code" href="dlfcn_8c.html#fbd7fb3690c8eff254f2690e831547b0">dlsymIntern</a>(dls, symbol, 1);
<a name="l01036"></a>01036    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l01037"></a>01037    <span class="keywordflow">return</span> addr;
<a name="l01038"></a>01038 }
<a name="l01039"></a>01039 <span class="preprocessor">#endif</span>
<a name="l01040"></a>01040 <span class="preprocessor"></span>
<a name="l01041"></a><a class="code" href="dlfcn-compat_8h.html#45a2f0c60f9c16390e6878ecc49d436d">01041</a> <span class="keywordtype">int</span> <a class="code" href="dlfcn_8c.html#45a2f0c60f9c16390e6878ecc49d436d">dlclose</a>(<span class="keywordtype">void</span> *handle)
<a name="l01042"></a>01042 {
<a name="l01043"></a>01043    <span class="keyword">struct </span><a class="code" href="structdlstatus.html">dlstatus</a> *dls = handle;
<a name="l01044"></a>01044    <a class="code" href="dlfcn_8c.html#3173031af7d4b847c50f22264d505a2a">dolock</a>();
<a name="l01045"></a>01045    <a class="code" href="dlfcn_8c.html#f79dfe72a8a68fc21a7a43fdebe8771e">resetdlerror</a>();
<a name="l01046"></a>01046    <span class="keywordflow">if</span> (!<a class="code" href="dlfcn_8c.html#94cc9569b7b9d1547f14f2ce0e5512cd">isValidStatus</a>(dls))
<a name="l01047"></a>01047    {
<a name="l01048"></a>01048       <span class="keywordflow">goto</span> dlcloseerror;
<a name="l01049"></a>01049    }
<a name="l01050"></a>01050    <span class="keywordflow">if</span> (dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a> == <a class="code" href="dlfcn_8c.html#7a6b0bdbbd9df80fd3f1044b33625543">MAGIC_DYLIB_MOD</a>)
<a name="l01051"></a>01051    {
<a name="l01052"></a>01052       <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="callerid_8c.html#b068931cc450442b63f5b3d276ea4297">name</a>;
<a name="l01053"></a>01053       <span class="keywordflow">if</span> (!dls-&gt;<a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">lib</a>)
<a name="l01054"></a>01054       {
<a name="l01055"></a>01055          name = <span class="stringliteral">"global context"</span>;
<a name="l01056"></a>01056       }
<a name="l01057"></a>01057       <span class="keywordflow">else</span>
<a name="l01058"></a>01058       {
<a name="l01059"></a>01059          name = <a class="code" href="dlfcn_8c.html#0b7d7a9f21dd25d6dc50d712552f343a">get_lib_name</a>(dls-&gt;<a class="code" href="structdlstatus.html#e8acc63b1e238f3255c900eed37254b8">lib</a>);
<a name="l01060"></a>01060       }
<a name="l01061"></a>01061       <a class="code" href="dlfcn_8c.html#a0054ad56afd71085b56813f21a1544c">warning</a>(<span class="stringliteral">"trying to close a .dylib!"</span>);
<a name="l01062"></a>01062       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"Not closing \"%s\" - dynamic libraries cannot be closed"</span>, name);
<a name="l01063"></a>01063       <span class="keywordflow">goto</span> dlcloseerror;
<a name="l01064"></a>01064    }
<a name="l01065"></a>01065    <span class="keywordflow">if</span> (!dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>)
<a name="l01066"></a>01066    {
<a name="l01067"></a>01067       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"module already closed"</span>);
<a name="l01068"></a>01068       <span class="keywordflow">goto</span> dlcloseerror;
<a name="l01069"></a>01069    }
<a name="l01070"></a>01070    
<a name="l01071"></a>01071    <span class="keywordflow">if</span> (dls-&gt;<a class="code" href="structdlstatus.html#5740713f144552f73502d802bc23dd35">refs</a> == 1)
<a name="l01072"></a>01072    {
<a name="l01073"></a>01073       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> options = 0;
<a name="l01074"></a>01074       void (*fini) (void);
<a name="l01075"></a>01075       <span class="keywordflow">if</span> ((fini = <a class="code" href="dlfcn_8c.html#fbd7fb3690c8eff254f2690e831547b0">dlsymIntern</a>(dls, <span class="stringliteral">"__fini"</span>, 0)))
<a name="l01076"></a>01076       {
<a name="l01077"></a>01077          <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"calling _fini()"</span>);
<a name="l01078"></a>01078          fini();
<a name="l01079"></a>01079       }
<a name="l01080"></a>01080 <span class="preprocessor">#ifdef __ppc__</span>
<a name="l01081"></a>01081 <span class="preprocessor"></span>      options |= NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES;
<a name="l01082"></a>01082 <span class="preprocessor">#endif</span>
<a name="l01083"></a>01083 <span class="preprocessor"></span><span class="preprocessor">#if 1</span>
<a name="l01084"></a>01084 <span class="preprocessor"></span><span class="comment">/*  Currently, if a module contains c++ static destructors and it is unloaded, we</span>
<a name="l01085"></a>01085 <span class="comment"> *  get a segfault in atexit(), due to compiler and dynamic loader differences of</span>
<a name="l01086"></a>01086 <span class="comment"> *  opinion, this works around that.</span>
<a name="l01087"></a>01087 <span class="comment"> *  I really need a way to figure out from code if this is still necessary.</span>
<a name="l01088"></a>01088 <span class="comment"> */</span>
<a name="l01089"></a>01089       <span class="keywordflow">if</span> ((<span class="keyword">const</span> <span class="keyword">struct</span> section *)NULL !=
<a name="l01090"></a>01090          getsectbynamefromheader(<a class="code" href="dlfcn_8c.html#980566f5f6d3ca4e4f01c5d3cced8327">get_mach_header_from_NSModule</a>(dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>),
<a name="l01091"></a>01091                            <span class="stringliteral">"__DATA"</span>, <span class="stringliteral">"__mod_term_func"</span>))
<a name="l01092"></a>01092       {
<a name="l01093"></a>01093          options |= NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED;
<a name="l01094"></a>01094       }
<a name="l01095"></a>01095 <span class="preprocessor">#endif</span>
<a name="l01096"></a>01096 <span class="preprocessor"></span><span class="preprocessor">#ifdef RTLD_NODELETE</span>
<a name="l01097"></a>01097 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (<a class="code" href="dlfcn_8c.html#de1ac04ff9536258d5099cd4ed3f0b84">isFlagSet</a>(dls-&gt;<a class="code" href="structdlstatus.html#15d61712450a686a7f365adf4fef581f">mode</a>, <a class="code" href="dlfcn-compat_8h.html#0cc0978e1ca3437f8a24fab84ea5f45a">RTLD_NODELETE</a>))
<a name="l01098"></a>01098          options |= NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED;
<a name="l01099"></a>01099 <span class="preprocessor">#endif</span>
<a name="l01100"></a>01100 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (!NSUnLinkModule(dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a>, options))
<a name="l01101"></a>01101       {
<a name="l01102"></a>01102          <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"unable to unlink module"</span>);
<a name="l01103"></a>01103          <span class="keywordflow">goto</span> dlcloseerror;
<a name="l01104"></a>01104       }
<a name="l01105"></a>01105       dls-&gt;<a class="code" href="structdlstatus.html#5740713f144552f73502d802bc23dd35">refs</a>--;
<a name="l01106"></a>01106       dls-&gt;<a class="code" href="structdlstatus.html#22884db148f0ffb0d830ba431102b0b5">module</a> = 0;
<a name="l01107"></a>01107       <span class="comment">/* Note: the dlstatus struct dls is neither removed from the list</span>
<a name="l01108"></a>01108 <span class="comment">       * nor is the memory it occupies freed. This shouldn't pose a </span>
<a name="l01109"></a>01109 <span class="comment">       * problem in mostly all cases, though.</span>
<a name="l01110"></a>01110 <span class="comment">       */</span>
<a name="l01111"></a>01111    }
<a name="l01112"></a>01112    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l01113"></a>01113    <span class="keywordflow">return</span> 0;
<a name="l01114"></a>01114   dlcloseerror:
<a name="l01115"></a>01115    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l01116"></a>01116    <span class="keywordflow">return</span> 1;
<a name="l01117"></a>01117 }
<a name="l01118"></a>01118 
<a name="l01119"></a><a class="code" href="dlfcn-compat_8h.html#f4f18e7a664d25663c1a235c1fc7fade">01119</a> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="dlfcn_8c.html#f4f18e7a664d25663c1a235c1fc7fade">dlerror</a>(<span class="keywordtype">void</span>)
<a name="l01120"></a>01120 {
<a name="l01121"></a>01121    <span class="keyword">struct </span><a class="code" href="structdlthread.html">dlthread</a>  *tss;
<a name="l01122"></a>01122    <span class="keywordtype">char</span> * err_str;
<a name="l01123"></a>01123    tss = pthread_getspecific(dlerror_key);
<a name="l01124"></a>01124    err_str = tss-&gt;<a class="code" href="structdlthread.html#ac8ef2b34ca04ea40d46ffb53ef323f8">errstr</a>;
<a name="l01125"></a>01125    tss = pthread_getspecific(dlerror_key);
<a name="l01126"></a>01126    <span class="keywordflow">if</span> (tss-&gt;<a class="code" href="structdlthread.html#1d0e9ad7d1908eaf205e819f3255f92c">errset</a> == 0)
<a name="l01127"></a>01127       <span class="keywordflow">return</span> 0;
<a name="l01128"></a>01128    tss-&gt;<a class="code" href="structdlthread.html#1d0e9ad7d1908eaf205e819f3255f92c">errset</a> = 0;  
<a name="l01129"></a>01129    <span class="keywordflow">return</span> (err_str );
<a name="l01130"></a>01130 }
<a name="l01131"></a>01131 
<a name="l01132"></a>01132 <span class="comment">/* Given an address, return the mach_header for the image containing it</span>
<a name="l01133"></a>01133 <span class="comment"> * or zero if the given address is not contained in any loaded images.</span>
<a name="l01134"></a>01134 <span class="comment"> */</span>
<a name="l01135"></a><a class="code" href="dlfcn_8c.html#edd4c3613a03834168b85d9192559af3">01135</a> <span class="keyword">const</span> <span class="keyword">struct </span>mach_header *<a class="code" href="dlfcn_8c.html#edd4c3613a03834168b85d9192559af3">image_for_address</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *address)
<a name="l01136"></a>01136 {
<a name="l01137"></a>01137    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;
<a name="l01138"></a>01138    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j;
<a name="l01139"></a>01139    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> count = _dyld_image_count();
<a name="l01140"></a>01140    <span class="keyword">struct </span>mach_header *mh = 0;
<a name="l01141"></a>01141    <span class="keyword">struct </span>load_command *lc = 0;
<a name="l01142"></a>01142    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr = NULL;
<a name="l01143"></a>01143    <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
<a name="l01144"></a>01144    {
<a name="l01145"></a>01145       addr = (<span class="keywordtype">unsigned</span> long)address - _dyld_get_image_vmaddr_slide(i);
<a name="l01146"></a>01146       mh = _dyld_get_image_header(i);
<a name="l01147"></a>01147       <span class="keywordflow">if</span> (mh)
<a name="l01148"></a>01148       {
<a name="l01149"></a>01149          lc = (<span class="keyword">struct </span>load_command *)((<span class="keywordtype">char</span> *)mh + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mach_header));
<a name="l01150"></a>01150          <span class="keywordflow">for</span> (j = 0; j &lt; mh-&gt;ncmds; j++, lc = (<span class="keyword">struct</span> load_command *)((<span class="keywordtype">char</span> *)lc + lc-&gt;cmdsize))
<a name="l01151"></a>01151          {
<a name="l01152"></a>01152             <span class="keywordflow">if</span> (LC_SEGMENT == lc-&gt;cmd &amp;&amp;
<a name="l01153"></a>01153                addr &gt;= ((<span class="keyword">struct</span> segment_command *)lc)-&gt;vmaddr &amp;&amp;
<a name="l01154"></a>01154                addr &lt;
<a name="l01155"></a>01155                ((<span class="keyword">struct</span> segment_command *)lc)-&gt;vmaddr + ((<span class="keyword">struct</span> segment_command *)lc)-&gt;vmsize)
<a name="l01156"></a>01156             {
<a name="l01157"></a>01157                <span class="keywordflow">goto</span> image_found;
<a name="l01158"></a>01158             }
<a name="l01159"></a>01159          }
<a name="l01160"></a>01160       }
<a name="l01161"></a>01161       mh = 0;
<a name="l01162"></a>01162    }
<a name="l01163"></a>01163   image_found:
<a name="l01164"></a>01164    <span class="keywordflow">return</span> mh;
<a name="l01165"></a>01165 }
<a name="l01166"></a>01166 
<a name="l01167"></a><a class="code" href="dlfcn_8c.html#d8cea3d64aea155f9baf923941850689">01167</a> <span class="keywordtype">int</span> <a class="code" href="dlfcn_8c.html#d8cea3d64aea155f9baf923941850689">dladdr</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> * <a class="code" href="dlfcn_8c.html#e3405fce965daa65a1561ec53eafb46b">dl_restrict</a> p, <a class="code" href="structdl__info.html">Dl_info</a> * <a class="code" href="dlfcn_8c.html#e3405fce965daa65a1561ec53eafb46b">dl_restrict</a> info)
<a name="l01168"></a>01168 {
<a name="l01169"></a>01169 <span class="comment">/*</span>
<a name="l01170"></a>01170 <span class="comment">   FIXME: USe the routine image_for_address.</span>
<a name="l01171"></a>01171 <span class="comment">*/</span>
<a name="l01172"></a>01172    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;
<a name="l01173"></a>01173    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> j;
<a name="l01174"></a>01174    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> count = _dyld_image_count();
<a name="l01175"></a>01175    <span class="keyword">struct </span>mach_header *mh = 0;
<a name="l01176"></a>01176    <span class="keyword">struct </span>load_command *lc = 0;
<a name="l01177"></a>01177    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> addr = NULL;
<a name="l01178"></a>01178    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> table_off = (<span class="keywordtype">unsigned</span> long)0;
<a name="l01179"></a>01179    <span class="keywordtype">int</span> found = 0;
<a name="l01180"></a>01180    <span class="keywordflow">if</span> (!info)
<a name="l01181"></a>01181       <span class="keywordflow">return</span> 0;
<a name="l01182"></a>01182    <a class="code" href="dlfcn_8c.html#3173031af7d4b847c50f22264d505a2a">dolock</a>();
<a name="l01183"></a>01183    <a class="code" href="dlfcn_8c.html#f79dfe72a8a68fc21a7a43fdebe8771e">resetdlerror</a>();
<a name="l01184"></a>01184    info-&gt;dli_fname = 0;
<a name="l01185"></a>01185    info-&gt;dli_fbase = 0;
<a name="l01186"></a>01186    info-&gt;dli_sname = 0;
<a name="l01187"></a>01187    info-&gt;dli_saddr = 0;
<a name="l01188"></a>01188 <span class="comment">/* Some of this was swiped from code posted by Douglas Davidson &lt;ddavidso AT apple DOT com&gt;</span>
<a name="l01189"></a>01189 <span class="comment"> * to darwin-development AT lists DOT apple DOT com and slightly modified</span>
<a name="l01190"></a>01190 <span class="comment"> */</span>
<a name="l01191"></a>01191    <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
<a name="l01192"></a>01192    {
<a name="l01193"></a>01193       addr = (<span class="keywordtype">unsigned</span> long)p - _dyld_get_image_vmaddr_slide(i);
<a name="l01194"></a>01194       mh = _dyld_get_image_header(i);
<a name="l01195"></a>01195       <span class="keywordflow">if</span> (mh)
<a name="l01196"></a>01196       {
<a name="l01197"></a>01197          lc = (<span class="keyword">struct </span>load_command *)((<span class="keywordtype">char</span> *)mh + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mach_header));
<a name="l01198"></a>01198          <span class="keywordflow">for</span> (j = 0; j &lt; mh-&gt;ncmds; j++, lc = (<span class="keyword">struct</span> load_command *)((<span class="keywordtype">char</span> *)lc + lc-&gt;cmdsize))
<a name="l01199"></a>01199          {
<a name="l01200"></a>01200             <span class="keywordflow">if</span> (LC_SEGMENT == lc-&gt;cmd &amp;&amp;
<a name="l01201"></a>01201                addr &gt;= ((<span class="keyword">struct</span> segment_command *)lc)-&gt;vmaddr &amp;&amp;
<a name="l01202"></a>01202                addr &lt;
<a name="l01203"></a>01203                ((<span class="keyword">struct</span> segment_command *)lc)-&gt;vmaddr + ((<span class="keyword">struct</span> segment_command *)lc)-&gt;vmsize)
<a name="l01204"></a>01204             {
<a name="l01205"></a>01205                info-&gt;dli_fname = _dyld_get_image_name(i);
<a name="l01206"></a>01206                info-&gt;dli_fbase = (<span class="keywordtype">void</span> *)mh;
<a name="l01207"></a>01207                found = 1;
<a name="l01208"></a>01208                <span class="keywordflow">break</span>;
<a name="l01209"></a>01209             }
<a name="l01210"></a>01210          }
<a name="l01211"></a>01211          <span class="keywordflow">if</span> (found)
<a name="l01212"></a>01212             <span class="keywordflow">break</span>;
<a name="l01213"></a>01213       }
<a name="l01214"></a>01214    }
<a name="l01215"></a>01215    <span class="keywordflow">if</span> (!found)
<a name="l01216"></a>01216    {
<a name="l01217"></a>01217       <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l01218"></a>01218       <span class="keywordflow">return</span> 0;
<a name="l01219"></a>01219    }
<a name="l01220"></a>01220    lc = (<span class="keyword">struct </span>load_command *)((<span class="keywordtype">char</span> *)mh + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mach_header));
<a name="l01221"></a>01221    <span class="keywordflow">for</span> (j = 0; j &lt; mh-&gt;ncmds; j++, lc = (<span class="keyword">struct</span> load_command *)((<span class="keywordtype">char</span> *)lc + lc-&gt;cmdsize))
<a name="l01222"></a>01222    {
<a name="l01223"></a>01223       <span class="keywordflow">if</span> (LC_SEGMENT == lc-&gt;cmd)
<a name="l01224"></a>01224       {
<a name="l01225"></a>01225          <span class="keywordflow">if</span> (!strcmp(((<span class="keyword">struct</span> segment_command *)lc)-&gt;segname, <span class="stringliteral">"__LINKEDIT"</span>))
<a name="l01226"></a>01226             <span class="keywordflow">break</span>;
<a name="l01227"></a>01227       }
<a name="l01228"></a>01228    }
<a name="l01229"></a>01229    table_off =
<a name="l01230"></a>01230       ((<span class="keywordtype">unsigned</span> long)((<span class="keyword">struct</span> segment_command *)lc)-&gt;vmaddr) -
<a name="l01231"></a>01231       ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)((<span class="keyword">struct</span> segment_command *)lc)-&gt;fileoff) + _dyld_get_image_vmaddr_slide(i);
<a name="l01232"></a>01232    <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"table off %x"</span>, table_off);
<a name="l01233"></a>01233 
<a name="l01234"></a>01234    lc = (<span class="keyword">struct </span>load_command *)((<span class="keywordtype">char</span> *)mh + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mach_header));
<a name="l01235"></a>01235    <span class="keywordflow">for</span> (j = 0; j &lt; mh-&gt;ncmds; j++, lc = (<span class="keyword">struct</span> load_command *)((<span class="keywordtype">char</span> *)lc + lc-&gt;cmdsize))
<a name="l01236"></a>01236    {
<a name="l01237"></a>01237       <span class="keywordflow">if</span> (LC_SYMTAB == lc-&gt;cmd)
<a name="l01238"></a>01238       {
<a name="l01239"></a>01239 
<a name="l01240"></a>01240          <span class="keyword">struct </span>nlist *symtable = (<span class="keyword">struct </span>nlist *)(((<span class="keyword">struct</span> symtab_command *)lc)-&gt;symoff + table_off);
<a name="l01241"></a>01241          <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> numsyms = ((<span class="keyword">struct </span>symtab_command *)lc)-&gt;nsyms;
<a name="l01242"></a>01242          <span class="keyword">struct </span>nlist *nearest = NULL;
<a name="l01243"></a>01243          <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> diff = 0xffffffff;
<a name="l01244"></a>01244          <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> strtable = (<span class="keywordtype">unsigned</span> long)(((<span class="keyword">struct</span> symtab_command *)lc)-&gt;stroff + table_off);
<a name="l01245"></a>01245          <a class="code" href="app__rpt_8c.html#ad42f6697b035b7580e4fef93be20b4d">debug</a>(<span class="stringliteral">"symtable %x"</span>, symtable);
<a name="l01246"></a>01246          <span class="keywordflow">for</span> (i = 0; i &lt; numsyms; i++)
<a name="l01247"></a>01247          {
<a name="l01248"></a>01248             <span class="comment">/* Ignore the following kinds of Symbols */</span>
<a name="l01249"></a>01249             <span class="keywordflow">if</span> ((!symtable-&gt;n_value)   <span class="comment">/* Undefined */</span>
<a name="l01250"></a>01250                || (symtable-&gt;n_type &gt;= N_PEXT)  <span class="comment">/* Debug symbol */</span>
<a name="l01251"></a>01251                || (!(symtable-&gt;n_type &amp; N_EXT)) <span class="comment">/* Local Symbol */</span>
<a name="l01252"></a>01252                )
<a name="l01253"></a>01253             {
<a name="l01254"></a>01254                symtable++;
<a name="l01255"></a>01255                <span class="keywordflow">continue</span>;
<a name="l01256"></a>01256             }
<a name="l01257"></a>01257             <span class="keywordflow">if</span> ((addr &gt;= symtable-&gt;n_value) &amp;&amp; (diff &gt;= (symtable-&gt;n_value - addr)))
<a name="l01258"></a>01258             {
<a name="l01259"></a>01259                diff = (<span class="keywordtype">unsigned</span> long)symtable-&gt;n_value - addr;
<a name="l01260"></a>01260                nearest = symtable;
<a name="l01261"></a>01261             }
<a name="l01262"></a>01262             symtable++;
<a name="l01263"></a>01263          }
<a name="l01264"></a>01264          <span class="keywordflow">if</span> (nearest)
<a name="l01265"></a>01265          {
<a name="l01266"></a>01266             info-&gt;dli_saddr = nearest-&gt;n_value + ((<span class="keywordtype">void</span> *)p - addr);
<a name="l01267"></a>01267             info-&gt;dli_sname = (<span class="keywordtype">char</span> *)(strtable + nearest-&gt;n_un.n_strx);
<a name="l01268"></a>01268          }
<a name="l01269"></a>01269       }
<a name="l01270"></a>01270    }
<a name="l01271"></a>01271    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l01272"></a>01272    <span class="keywordflow">return</span> 1;
<a name="l01273"></a>01273 }
<a name="l01274"></a>01274 
<a name="l01275"></a>01275 
<a name="l01276"></a>01276 <span class="comment">/*</span>
<a name="l01277"></a>01277 <span class="comment"> * Implement the dlfunc() interface, which behaves exactly the same as</span>
<a name="l01278"></a>01278 <span class="comment"> * dlsym() except that it returns a function pointer instead of a data</span>
<a name="l01279"></a>01279 <span class="comment"> * pointer.  This can be used by applications to avoid compiler warnings</span>
<a name="l01280"></a>01280 <span class="comment"> * about undefined behavior, and is intended as prior art for future</span>
<a name="l01281"></a>01281 <span class="comment"> * POSIX standardization.  This function requires that all pointer types</span>
<a name="l01282"></a>01282 <span class="comment"> * have the same representation, which is true on all platforms FreeBSD</span>
<a name="l01283"></a>01283 <span class="comment"> * runs on, but is not guaranteed by the C standard.</span>
<a name="l01284"></a>01284 <span class="comment"> */</span>
<a name="l01285"></a>01285 <span class="preprocessor">#if 0 </span>
<a name="l01286"></a>01286 <span class="preprocessor"></span>dlfunc_t dlfunc(<span class="keywordtype">void</span> * <a class="code" href="dlfcn_8c.html#e3405fce965daa65a1561ec53eafb46b">dl_restrict</a> handle, <span class="keyword">const</span> <span class="keywordtype">char</span> * <a class="code" href="dlfcn_8c.html#e3405fce965daa65a1561ec53eafb46b">dl_restrict</a> symbol)
<a name="l01287"></a>01287 {
<a name="l01288"></a>01288    <span class="keyword">union</span>
<a name="l01289"></a>01289 <span class="keyword">   </span>{
<a name="l01290"></a>01290       <span class="keywordtype">void</span> *d;
<a name="l01291"></a>01291       dlfunc_t <a class="code" href="format__g726_8c.html#85b9b17a7dd34a3638c560bc9152473b">f</a>;
<a name="l01292"></a>01292    } rv;
<a name="l01293"></a>01293    <span class="keywordtype">int</span> sym_len = strlen(symbol);
<a name="l01294"></a>01294    <span class="keywordtype">char</span> *malloc_sym = NULL;
<a name="l01295"></a>01295    <a class="code" href="dlfcn_8c.html#3173031af7d4b847c50f22264d505a2a">dolock</a>();
<a name="l01296"></a>01296    malloc_sym = <a class="code" href="astmm_8h.html#df74d22342f0da6246131193b1993a41">malloc</a>(sym_len + 2);
<a name="l01297"></a>01297    <span class="keywordflow">if</span> (malloc_sym)
<a name="l01298"></a>01298    {
<a name="l01299"></a>01299       sprintf(malloc_sym, <span class="stringliteral">"_%s"</span>, symbol);
<a name="l01300"></a>01300       rv.d = <a class="code" href="dlfcn_8c.html#fbd7fb3690c8eff254f2690e831547b0">dlsymIntern</a>(handle, malloc_sym, 1);
<a name="l01301"></a>01301       <a class="code" href="astmm_8h.html#eb051e552619427a26721b1a925a56e8">free</a>(malloc_sym);
<a name="l01302"></a>01302    }
<a name="l01303"></a>01303    <span class="keywordflow">else</span>
<a name="l01304"></a>01304    {
<a name="l01305"></a>01305       <a class="code" href="dlfcn_8c.html#9989047f9754c69a45ea752cb417ca79">error</a>(<span class="stringliteral">"Unable to allocate memory"</span>);
<a name="l01306"></a>01306       <span class="keywordflow">goto</span> dlfuncerror;
<a name="l01307"></a>01307    }
<a name="l01308"></a>01308    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l01309"></a>01309    <span class="keywordflow">return</span> rv.f;
<a name="l01310"></a>01310   dlfuncerror:
<a name="l01311"></a>01311    <a class="code" href="dlfcn_8c.html#1db4dbf9ea9f28b2fb35656635a0bebe">dounlock</a>();
<a name="l01312"></a>01312    <span class="keywordflow">return</span> NULL;
<a name="l01313"></a>01313 }
<a name="l01314"></a>01314 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu May 24 22:26:41 2007 for Asterisk - the Open Source PBX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.5 </small></address>
</body>
</html>
