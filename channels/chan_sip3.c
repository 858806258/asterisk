/* CODENAME PINEAPPLE - THIS IS VERY EXPERIMENTAL. 
   IF YOU USE THIS IN PRODUCTION, I WILL NOT SUPPORT YOU...
*
*  -- Mail bugs to oej@edvina.net, do not file them in the bug tracker
*/

/* To skip to source code, search for "-END-" */

/*
 * Asterisk -- An open source telephony toolkit.
 *
 * Copyright (C) 1999 - 2006, Digium, Inc.
 *
 * Mark Spencer <markster@digium.com>
 * Chan_sip3 changes by Olle E. Johansson <oej@edvina.net>
 *
 *
 *
 * See http://www.asterisk.org for more information about
 * the Asterisk project. Please do not directly contact
 * any of the maintainers of this project for assistance;
 * the project provides a web site, mailing lists and IRC
 * channels for your use.
 *
 * This program is free software, distributed under the terms of
 * the GNU General Public License Version 2. See the LICENSE file
 * at the top of the source tree.
 */

/*!
 * \file
 * \brief Implementation of Session Initiation Protocol
 * Version 3 of chan_sip
 *
 * \author Mark Spencer <markster@digium.com>
 * \author Olle E. Johansson <oej@edvina.net> (all the chan_sip3 changes)
 *
 * See Also:
 * \arg \ref AstCREDITS
 *
 * Implementation of RFC 3261 - without S/MIME, TCP and TLS support
 * Configuration file \link Config_sip sip.conf \endlink
 *
 *
 * \todo SIP over TCP
 * \todo SIP over TLS
 * \todo Better support of forking
 * \todo VIA branch tag transaction checking
 * \todo Transaction support
 *
 * \ingroup channel_drivers
 */
/*! \page Chan_sip3_overview Chan_SIP3:: Overview
 *
 * \par Overview of the handling of SIP sessions
 * The SIP channel handles several types of SIP sessions, or dialogs,
 * not all of them being "telephone calls".
 * - Incoming calls that will be sent to the PBX core
 * - Outgoing calls, generated by the PBX
 * - SIP subscriptions and notifications of states and voicemail messages
 * - SIP registrations, both inbound and outbound
 * - SIP peer management (peerpoke, OPTIONS)
 * - SIP text messages
 *
 * In the SIP channel, there's a list of active SIP dialogs, which includes
 * all of these when they are active. "sip show channels" in the CLI will
 * show most of these, excluding subscriptions which are shown by
 * "sip show subscriptions"
 *
 * \par incoming packets
 * Incoming packets are received in the monitoring thread, then handled by
 * sipsock_read(). This function parses the packet and matches an existing
 * dialog or starts a new SIP dialog.
 * 
 * sipsock_read sends the packet to handle_request(), that parses a bit more.
 * if it's a response to an outbound request, it's sent to handle_response().
 * If it is a request, handle_request sends it to one of a list of functions
 * depending on the request type - INVITE, OPTIONS, REFER, BYE, CANCEL etc
 * sipsock_read locks the ast_channel if it exists (an active call) and
 * unlocks it after we have processed the SIP message.
 *
 * A new INVITE is sent to handle_request_invite(), that will end up
 * starting a new channel in the PBX, the new channel after that executing
 * in a separate channel thread. This is an incoming "call".
 * When the call is answered, either by a bridged channel or the PBX itself
 * the sip_answer() function is called.
 *
 * The actual media - Video or Audio - is mostly handled by the RTP subsystem
 * in rtp.c 
 * 
 * \par Outbound calls
 * Outbound calls are set up by the PBX through the sip_request_call()
 * function. After that, they are activated by sip_call().
 * 
 * \par Hanging up
 * The PBX issues a hangup on both incoming and outgoing calls through
 * the sip_hangup() function
 *
 * \title Dialogs, packets, transactions
 *
 * This version of chan_sip has a concept of a SIP dialog (\ref sip_dialog) that
 * lives throughut a session - a call (INVITE), a registration (REGISTER)
 * or a subscription for status (SUBSCRIBE)... We do save new requests we
 * send in a queue (sip_dialog->packets) until they're acknowledged by the
 * remote party, when we remove them (sip_ack() )
 * 
 * For requests and responses, we store them in a structure called \ref sip_request
 * and process them. The matching between a response or a new request and an
 * existing dialog is done in match_or_create_dialog().
 *
 */

/*!	\page chan_sip3_00index Chan_sip3: Index over docs
	\title Chan_sip3 :: Index

	- \subpage chan_sip3_start
	- \subpage chan_sip3_objects
	- \subpage chan_sip3_files
	- \subpage chan_sip3_auth
	- \subpage chan_sip3_dialogs
	- \subpage chan_sip3_overview
	- \subpage sip3_dialog_match
	\par todo Things to do, ideas
	- \subpage chan_sip3_todo
	- \subpage chan_sip3_subs

*/

/*! 
	\page chan_sip3_start Chan_sip3: Welcome to Codename Pineapple !

	\title Chan_sip3: What's this?
	This is a re-work of the SIP channel in Asterisk. 
	This channel will not be backwards compatible with the old 
	sip channel. In order to be more SIP compatible, I will have
	to break the backwards compatibility. That's why the old channel
	will still be around for a while.

	** This work is sponsored by voop.com - the Internet Dialtone.
	   I am open for more sponsors - contact me on oej@edvina.net

	\page chan_sip3_todo Chan_sip3: Things to do
	Done
	- removed userconf support (in favour of astum)
	- removed pedantic mode
	- added config option for qualify frequency timers
	- merged peermatch and sipregister branches
	- removed "type=user"
	- change "sip nodebug" to "sip debug off" and "sip debug" to "sip debug on" - done
	- change "sip history" and "nohistory" to "on/off" - done
	- "sip show/list peers" is now "sip show/list phones"
	- manager command renamed - SIPdevices and SIPshowdevice
	- Added "authuser" configuration option for trunks and services
	- Added "domain" configuration option for all devices
	- Fixed handling of too short registration times (sending 423)
	- T38 does no longer depend on canreinvite settings

	Halfdone
	- Added separate TOS setting for presence. Need to run setsockopt
	  in a locked socket for that to work on the SIP interface.

	Todo
	- check resp 491 to INVITE processing
	- Make show devices and the completion support domains too
	- Fix realtime caching and optional loading
	- Clean up the authuser/username/peername mess!
		- authuser as a separate config option, please, please
	- Split up source code file
	- Add astum
	- Add T1 timer configuration settings
	- Add auto-nat for RFC 1918 networks
	- Add type=device for peers
	- Add type=service for register= replacement
	- Add type=trunk definition, based on domain routing
	- Implement state engine for dialogs
	- Implement transactions
	- Implement state engine for transactions
	- Implement real realtime caching
	- Implement realtime static loading for MWI and qualify support
	- Implement remote MWI notification
	- Implement remote subscriptions
	- Implement improved SIP domain support
		- Document these ideas!
	- Prove transaction engine by implementing PRACK
	- Implement netsock API in this channel
	- Add File's multithreading code
	- Make debugaddr a ha list instead of one address and move it out of sipnet

	Maybe
	- add support for Path header
		the Path is arriving with Register requests, saved in location
		and used as a Route: header in the outbound request

	- ... And much more
*/
/*!
	\page chan_sip3_objects	Chan_sip3: Devices, trunks and services
	- \b phones are devices that connect to Asterisk. They register with  
	Asterisk acting as a SIP location server/registrar and use Asterisk 
	as the outbound SIP  proxy. They get calls from Asterisk and place 
	calls to Asterisk. The phone use one of  the SIP domains that are hosted 
	within your Asterisk server. (this is like the  
	current "friend")

	- \b service is when Asterisk is the UA, acting as a phone towards  
	another SIP server - we register with a SIP location server/registrar 
	to get incoming  calls. We place
	calls, masquerading as a phone (using the registrars domain).
	Currently, this is a mixture between a peer (matched on IP for  
	incoming calls) and a register= statement. In some cases, two 
	peers and a register= statement.  Very confusing.

	- \b trunk is when we exchange traffic with another server. We send  
	calls to their SIP domain and receive calls to our SIP domain. We may 
	use realm based authentication for the incoming part of the trunk 
	(not based on caller ID/From: header) and a combination of SIP domain and ACLs.
	This is currently handled by defining sip peers for outbound calls and
	separate SIP peers for inbound calls - where we match on IP. The
	problem with the IP matching is when a trunking partner use several
	SIP servers to connect to us, we need to define one peer per server
	instead of just matching on domain and then authenticate.

*/

/*!
	\page chan_sip3_subs Chan_sip3: Subscriptions

	\title Ideas for a new subscription system
	
	We need to move out the active subsriptions to a list
	of their own, like the registry. Do not keep them in
	the active dialog list, they're active subscriptions.

	Add a list of internal and external subscriptions.
	We need one object that "watches" URIs or extensions
	that is connected to subscribers. For several subscribers,
	we have only one internal or external subscription.

	Should the external subscription system be directly
	connected or go through the hint subsystem? Will this
	cause un-needed overhead?

	exten => johnny,hint,sipsubscribe::sip:johnny@johnnysdomain.com

*/

/*!
	\page chan_sip3_files Chan_sip3: Source code files
	\title Chan_sip3: Source Code Files

	\b \\channels

	- \b chan_sip3.c	The main source code file for the channel
				PBX interface

	\b \\channels\\sip3
	
	- \b sip3.h		The include file for structures and enums
	- \b sip3funcs.h	The include file for functions
	- \b sip3_cliami.c	Manager and CLI functions
	- \b sip3_sdprtp.c	SDP handling and RTP interface
	- \b sip3_callerid.c	CallerID, pres and RPID handling
	- \b sip3_dialog.c	SIP dialog support
	- \b sip3_auth.c	SIP authentication
	- \b sip3_config.c	Configuration
	- \b sip3_domain.c	SIP domain support
	- \b sip3_subscribe.c	SIP subscription support
	- \b sip3_parse.c	Parsing stuff
	- \b sip3_compose.c	Composing new requests and responses
	- \b sip3_refer.c	SIP transfer and parking support
	- \b sip3_network.c	Networks interface (UDP today)
	- \b sip3_services.c	Outbound registrations (services)
		
*/
/*!
 *	\page chan_sip3_transactions Implementing transactions
 *
 *	A SIP transaction is a request and one or several responses. 
 *	The INVITE transaction is special, it's a three-way handshake
 *		request - response - ack
 *	
 *	Responses are divided into temporary responses and final responses.
 *	A final response closes the transaction, temporary responses
 *	just updates the transaction.
 *
 *	Some transactions will open a new SIP dialog, some will not.
 *	Some transactions are allowed within an active dialog, some
 *	are not.
 *
 *	\title	Transactions and chan_sip
 *	The current version of chan_sip.c does not have much notion
 * 	of a SIP transaction or a dialog. Each transaction will update
 *	the dialog, so only the last request is remembered and the
 *	direction of the last request.
 *	
 *	While this can be seen as effective, it does not allow 
 * 	for situations with multiple concurrent transactions.
 *	Most importantly, the INVITE transaction can be open for
 *	a long time (Ringing) and other things may happen at
 *	the same time.
 *
 *	We do need to change chan_sip3 so that the transaction
 *	state engine works properly.

 * 	\title Random thoughts
 *	- Integrate sip_pkt and sip_request - done
 *	- Mark the UNACKed packets in dialog->packets with a flag
 *		Maybe two lists of packets, to keep it simple for do_monitor?
 *		Or a flag when we have no open transactions?
 *	- Use sip-request as "transaction holders" within sip_dialog
 *	- Keep them in Cseq order
 *	- Add transaction state
 *	- When do you delete them - 32 secs after first transmit 
 *	- Then we finally can fix the "ignore" ignorant stuff and resend last response
 *	- The first transaction that opened in a dialog needs to be saved for the
 *	  CANCEL/BYE (in an INVITE transaction)
 *	- For SUBSCRIBE dialogs, we need to keep the initial SUBSCRIBE
 *	  Then unacknowledged NOTIFY transactions. Keep the transaction
 *	  until timer expires
 *
 *	SIP_dialog
 *	   - sip_trans
 *		Request	(our or remote)
 *		response (our or remote)
 *	   - sip_trans
 *
 */
			/* -END- documentation pages */

#define CHAN_SIP3_MAIN

/* GNURK is a temporary marker of functions that are exposed outside of this code file 
   and possibly needs to move out */
#define GNURK

#include "asterisk.h"

ASTERISK_FILE_VERSION(__FILE__, "$Revision$")

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <errno.h>
#include <stdlib.h>
#include <fcntl.h>
#include <netdb.h>
#include <signal.h>
#include <sys/signal.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <arpa/inet.h>
#include <netinet/ip.h>
#include <regex.h>

#include "asterisk/lock.h"
#include "asterisk/channel.h"
#include "asterisk/config.h"
#include "asterisk/logger.h"
#include "asterisk/module.h"
#include "asterisk/pbx.h"
#include "asterisk/options.h"
#include "asterisk/lock.h"
#include "asterisk/sched.h"
#include "asterisk/io.h"
#include "asterisk/rtp.h"
#include "asterisk/udptl.h"
#include "asterisk/acl.h"
#include "asterisk/manager.h"
#include "asterisk/translate.h"
#include "asterisk/callerid.h"
#include "asterisk/cli.h"
#include "asterisk/app.h"
#include "asterisk/musiconhold.h"
#include "asterisk/dsp.h"
#include "asterisk/features.h"
#include "asterisk/acl.h"
#include "asterisk/srv.h"
#include "asterisk/astdb.h"
#include "asterisk/causes.h"
#include "asterisk/utils.h"
#include "asterisk/file.h"
#include "asterisk/astobj.h"
#include "asterisk/dnsmgr.h"
#include "asterisk/devicestate.h"
#include "asterisk/linkedlists.h"
#include "asterisk/stringfields.h"
#include "asterisk/monitor.h"
#include "asterisk/localtime.h"
#include "asterisk/abstract_jb.h"
#include "asterisk/compiler.h"

#include "sip3/sip3.h"
#include "sip3/sip3funcs.h"

#define SIPLABEL	sip3

/*------- GLOBAL VARIABLES ------------------------------------ */

/*! \brief various expiry times for registrations */
struct expiry_times expiry = {
	.min_expiry = DEFAULT_MIN_EXPIRY,        /*!< Minimum accepted registration time */
	.max_expiry = DEFAULT_MAX_EXPIRY,        /*!< Maximum accepted registration time */
	.default_expiry = DEFAULT_DEFAULT_EXPIRY,
	.expiry = DEFAULT_EXPIRY,		/*!< Is this ever used ??? */
};

/* Default setttings are used as a channel setting and as a default when
   configuring devices */
/* Global settings only apply to the channel */
struct sip_globals global;

/* Object counters */
struct channel_counters sipcounters = { 0, 0, 0, 0, 0, 0, 0};

/*! \brief Protect the monitoring thread, so only one process can kill or start it, and not
   when it's doing something critical. */
AST_MUTEX_DEFINE_STATIC(monlock);

/*! \brief Make sure we don't reload twice at the same time */
AST_MUTEX_DEFINE_STATIC(sip_reload_lock);

/*! \brief This is the thread for the monitor which checks for input on the channels
   which are not currently in use.  */
static pthread_t monitor_thread = AST_PTHREADT_NULL;

static int sip_reloading = FALSE;                      /*!< Flag for avoiding multiple reloads at the same time */
static enum channelreloadreason sip_reloadreason;      /*!< Reason for last reload/load of configuration */

struct sched_context *sched;     /*!< The scheduling context */
struct io_context *io;           /*!< The IO context */

/* --- Linked lists of various objects --------*/

struct sip_dialog *dialoglist = NULL;        /*!< List of concurrent SIP dialogs */
struct sip_device_list devicelist;           /*!< The device list */
struct ast_config *notify_types;	     /*!< The list of manual NOTIFY types we know how to send */

/*---------------------------- Forward declarations of functions in chan_sip3.c */

/*--- PBX interface functions  - stays in this source code file */
static struct ast_channel *sip_request_call(const char *type, int format, void *data, int *cause);
static int sip_devicestate(void *data);
static int sip_sendtext(struct ast_channel *ast, const char *text);
static int sip_call(struct ast_channel *ast, char *dest, int timeout);
static int sip_hangup(struct ast_channel *ast);
static int sip_answer(struct ast_channel *ast);
static int sip_write(struct ast_channel *ast, struct ast_frame *frame);
static int sip_indicate(struct ast_channel *ast, int condition, const void *data, size_t datalen);
static int sip_transfer(struct ast_channel *ast, const char *dest);
static int sip_fixup(struct ast_channel *oldchan, struct ast_channel *newchan);
static int sip_senddigit_begin(struct ast_channel *ast, char digit);
static int sip_senddigit_end(struct ast_channel *ast, char digit);

/*--- Transmitting responses and requests */
static int transmit_sip_request(struct sip_dialog *p, struct sip_request *req);
static int transmit_request(struct sip_dialog *p, int sipmethod, int inc, enum xmittype reliable, int newbranch);
static int transmit_response_reliable(struct sip_dialog *p, const char *msg, const struct sip_request *req);
static int transmit_response_with_attachment(enum responseattach attach, struct sip_dialog *p, const char *msg, 
		const struct sip_request *req, enum xmittype reliable);
static int transmit_response_with_unsupported(struct sip_dialog *p, const char *msg, const struct sip_request *req, const char *unsupported);
static void transmit_fake_auth_response(struct sip_dialog *p, struct sip_request *req, int reliable);
static int transmit_info_with_digit(struct sip_dialog *p, const char digit);
static int transmit_info_with_vidupdate(struct sip_dialog *p);
static int transmit_message_with_text(struct sip_dialog *p, const char *text);
static int transmit_refer(struct sip_dialog *p, const char *dest);
static int transmit_notify_with_mwi(struct sip_dialog *p, int newmsgs, int oldmsgs, char *vmexten);
static void receive_message(struct sip_dialog *p, struct sip_request *req);
static int sip_send_mwi_to_peer(struct sip_peer *peer);
static int does_peer_need_mwi(struct sip_peer *peer);

/*--- Dialog management */
static int auto_congest(void *nothing);
static void list_route(struct sip_route *route);
static void build_route(struct sip_dialog *p, struct sip_request *req, int backwards);
static enum check_auth_result register_verify(struct sip_dialog *p, struct sockaddr_in *sin,
					      struct sip_request *req, char *uri);
static void check_pendings(struct sip_dialog *p);
static int sip_sipredirect(struct sip_dialog *p, const char *dest);

/*--- Codec handling / SDP */
static void try_suggested_sip_codec(struct sip_dialog *p);

/*--- Authentication stuff */
static enum check_auth_result check_user_full(struct sip_dialog *p, struct sip_request *req,
		      int sipmethod, char *uri, enum xmittype reliable,
		      struct sockaddr_in *sin, struct sip_peer **authpeer);
static int check_user(struct sip_dialog *p, struct sip_request *req, int sipmethod, char *uri, enum xmittype reliable, struct sockaddr_in *sin);

/*--- Misc functions */
static int sip_do_reload(enum channelreloadreason reason);
static int sip_sipredirect(struct sip_dialog *p, const char *dest);
static void *do_monitor(void *data);
static int restart_monitor(void);
static int sip_send_mwi_to_peer(struct sip_peer *peer);
static int sip_addrcmp(char *name, struct sockaddr_in *sin);	/* Support for peer matching */

/*--- Device monitoring and Device/extension state handling */
static int cb_extensionstate(char *context, char* exten, int state, void *data);
static int sip_devicestate(void *data);

/*--- Applications, functions, CLI and manager command helpers */
GNURK int sip_notify(int fd, int argc, char *argv[]);
static int func_header_read(struct ast_channel *chan, char *function, char *data, char *buf, size_t len);
static int function_sippeer(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len);
static int function_sipchaninfo_read(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len);
static int sip_dtmfmode(struct ast_channel *chan, void *data);
static int sip_addheader(struct ast_channel *chan, void *data);
static int sip_do_reload(enum channelreloadreason reason);

/*--- Debugging 
	Functions for enabling debug per IP or fully, or enabling history logging for
	a SIP dialog
*/
GNURK void sip_dump_history(struct sip_dialog *dialog);	/* Dump history to LOG_DEBUG at end of dialog, before destroying data */
GNURK inline int sip_debug_test_pvt(struct sip_dialog *p);

/*--- Device object handling */
static struct sip_peer *temp_peer(const char *name);
static struct sip_peer *temp_peer(const char *name);
static void register_peer_exten(struct sip_peer *peer, int onoff);
static enum parse_register_result parse_register_contact(struct sip_dialog *pvt, struct sip_peer *p, struct sip_request *req);

/* Realtime device support */
static void realtime_update_peer(const char *peername, struct sockaddr_in *sin, const char *username, const char *fullcontact, int expirey);
static void update_peer(struct sip_peer *p, int expiry);

/*--- Parsing SIP requests and responses */
static int get_also_info(struct sip_dialog *p, struct sip_request *oreq);
static int parse_ok_contact(struct sip_dialog *pvt, struct sip_request *req);
static int set_address_from_contact(struct sip_dialog *pvt);
static void check_via(struct sip_dialog *p, struct sip_request *req);
static int get_msg_text(char *buf, int len, struct sip_request *req);

/*--- Constructing requests and responses */
static int create_addr_from_peer(struct sip_dialog *r, struct sip_peer *peer);
static int add_vidupdate(struct sip_request *req);

/*------Request handling functions */
static int handle_request_invite(struct sip_dialog *p, struct sip_request *req, int debug, struct sockaddr_in *sin, int *recount, char *e);
static int handle_request_bye(struct sip_dialog *p, struct sip_request *req);
static int handle_request_register(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e);
static int handle_request_cancel(struct sip_dialog *p, struct sip_request *req);
static int handle_request_message(struct sip_dialog *p, struct sip_request *req);
static int handle_request_subscribe(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e);
static void handle_request_info(struct sip_dialog *p, struct sip_request *req);
static int handle_request_options(struct sip_dialog *p, struct sip_request *req);
static int handle_invite_replaces(struct sip_dialog *p, struct sip_request *req, int debug, struct sockaddr_in *sin);
static int handle_request_notify(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e);

/*------Response handling functions */
static void handle_response_invite(struct sip_dialog *p, int resp, char *rest, struct sip_request *req);
static void handle_response_refer(struct sip_dialog *p, int resp, char *rest, struct sip_request *req);
static void handle_response(struct sip_dialog *p, int resp, char *rest, struct sip_request *req);

/*------ T38 Support --------- */
static int sip_handle_t38_reinvite(struct ast_channel *chan, struct sip_dialog *pvt, int reinvite); /*!< T38 negotiation helper function */

/*! \brief Definition of this channel for PBX channel registration */
static const struct ast_channel_tech sip_tech = {
	.type = "SIP",
	.description = "Session Initiation Protocol (SIP)",
	.capabilities = ((AST_FORMAT_MAX_AUDIO << 1) - 1),
	.properties = AST_CHAN_TP_WANTSJITTER | AST_CHAN_TP_CREATESJITTER,
	.requester = sip_request_call,		/*!< Where we set up a call, but don't actually activate it */
	.devicestate = sip_devicestate,		/*!< Checking the status of a known SIP device */
	.call = sip_call,			/*!< Try calling Bob, says Alice */
	.hangup = sip_hangup,			/*!< Alice does not want to talk to Bob any more */
	.answer = sip_answer,			/*!< Bob answers the call */
	.read = sip_read,			/*!< Deliver media to the PBX */
	.write = sip_write,			/*!< Get media from the PBX side */
	.write_video = sip_write,		/*!< Get video media from the PBX side */
	.indicate = sip_indicate,		/*!< Get indications from the PBX side */
	.transfer = sip_transfer,		/*!< Transfer a call, severely broken */
	.fixup = sip_fixup,
	.send_digit_begin = sip_senddigit_begin,	/*!< DTMF support */
	.send_digit_end = sip_senddigit_end,		/*!< DTMF support */
	.bridge = ast_rtp_bridge,
	.early_bridge = ast_rtp_early_bridge,
	.send_text = sip_sendtext,		/*!< Get text from the PBX to send out */
};

/*! \brief Initialize the initital request packet in the pvt structure.
 	This packet is used for creating replies and future requests in
	a dialog */
GNURK void initialize_initreq(struct sip_dialog *dialog, struct sip_request *req)
{
	if (dialog->initreq.headers && option_debug) {
		ast_log(LOG_DEBUG, "Initializing already initialized SIP dialog %s (presumably reinvite)\n", dialog->callid);
	}
	/* Use this as the basis */
	copy_request(&dialog->initreq, req);
	/* XX Instead -allocate this request in the dialog->packets linked list */
	ast_set_flag(&dialog->initreq, SIP_PKT_INITREQ);
	parse_request(&dialog->initreq);
	if (ast_test_flag(req, SIP_PKT_DEBUG))
		ast_verbose("Initreq: %d headers, %d lines\n", dialog->initreq.headers, dialog->initreq.lines);
}

/*! \brief Find via branch parameter */
GNURK void find_via_branch(struct sip_request *req, char *viabuf, size_t vialen)
{
	char *dupvia;
	char *viabranch;
	char *sep;

	if (ast_strlen_zero(req->via))
		return;
	dupvia = ast_strdupa(req->via);
	if (!(viabranch = strcasestr(dupvia, ";branch=")))
		return;
	viabranch += 8;
	if ((sep = strchr(viabranch, ';')))
		*sep = '\0';
	if (ast_test_flag(req, SIP_PKT_DEBUG) && option_debug > 3)
		ast_log(LOG_DEBUG, "* Found via branch %s\n", viabranch);
	strncpy(viabuf, viabranch, vialen);
}


/*! \brief Make branch tag for via header if it does not exist yet */
static char *ourdialogbranch(struct sip_dialog *dialog, int forcenewbranch)
{
	char branch[20];
	int seed = 0;

	if (forcenewbranch || ast_strlen_zero(dialog->ourbranch)) {
		if (forcenewbranch)
			seed ^= ast_random();
		else
			seed = ast_random();
		snprintf(branch, sizeof(branch), "z9hG4bk%08x", seed);
		ast_string_field_set(dialog, ourbranch, branch);
	}

	return((char *) dialog->ourbranch);
	
}

/*! \brief Build a Via header for a request */
GNURK void build_via(struct sip_dialog *dialog, int forcenewbranch)
{
	/* Work around buggy UNIDEN UIP200 firmware */
	const char *rport = ast_test_flag(&dialog->flags[0], SIP_NAT) & SIP_NAT_RFC3581 ? ";rport" : "";

	/* z9hG4bK is a magic cookie.  See RFC 3261 section 8.1.1.7 */
	ast_string_field_build(dialog, via, "SIP/2.0/UDP %s:%d;branch=%s%s",
			ast_inet_ntoa(dialog->ourip), sipnet_ourport(), 
			ourdialogbranch(dialog, forcenewbranch), rport);
}

GNURK void append_history_full(struct sip_dialog *p, const char *fmt, ...)
	__attribute__ ((format (printf, 2, 3)));

/*! \brief Append to SIP dialog history with arg list  */
GNURK void append_history_va(struct sip_dialog *p, const char *fmt, va_list ap)
{
	char buf[80], *c = buf; /* max history length */
	struct sip_history *hist;
	int l;

	vsnprintf(buf, sizeof(buf), fmt, ap);
	strsep(&c, "\r\n"); /* Trim up everything after \r or \n */
	l = strlen(buf) + 1;
	if (!(hist = ast_calloc(1, sizeof(*hist) + l)))
		return;
	if (!p->history && !(p->history = ast_calloc(1, sizeof(*p->history)))) {
		free(hist);
		return;
	}
	memcpy(hist->event, buf, l);
	AST_LIST_INSERT_TAIL(p->history, hist, list);
}

/*! \brief Append to SIP dialog history with arg list  */
GNURK void append_history_full(struct sip_dialog *dialog, const char *fmt, ...)
{
	va_list ap;

	if (!dialog)
		return;
	va_start(ap, fmt);
	append_history_va(dialog, fmt, ap);
	va_end(ap);

	return;
}

/*! \brief Copy SIP request, pre-parse it */
GNURK void parse_copy(struct sip_request *dst, const struct sip_request *src)
{
	memset(dst, 0, sizeof(*dst));
	memcpy(dst->data, src->data, sizeof(dst->data));
	dst->len = src->len;
	parse_request(dst);
}

/*! \brief add a blank line if no body */
GNURK void add_blank(struct sip_request *req)
{
	if (!req->lines) {
		/* Add extra empty return. add_header() reserves 4 bytes so cannot be truncated */
		snprintf(req->data + req->len, sizeof(req->data) - req->len, "\r\n");
		req->len += strlen(req->data + req->len);
	}
}

/*! \brief Send SIP MESSAGE text within a call
	Called from PBX core sendtext() application */
static int sip_sendtext(struct ast_channel *ast, const char *text)
{
	struct sip_dialog *dialog = ast->tech_pvt;
	int debug = sip_debug_test_pvt(dialog);

	if (debug)
		ast_verbose("Sending text %s on %s\n", text, ast->name);
	if (!dialog)
		return -1;
	if (ast_strlen_zero(text))
		return 0;
	if (debug)
		ast_verbose("Really sending text %s on %s\n", text, ast->name);
	transmit_message_with_text(dialog, text);
	return 0;	
}

/*! \brief Update peer object in realtime storage 
	If the Asterisk system name is set in asterisk.conf, we will use
	that name and store that in the "regserver" field in the sippeers
	table to facilitate multi-server setups.
*/
static void realtime_update_peer(const char *peername, struct sockaddr_in *sin, const char *username, const char *fullcontact, int expirey)
{
	char port[10];
	char ipaddr[INET_ADDRSTRLEN];
	char regseconds[20];

	char *sysname = ast_config_AST_SYSTEM_NAME;
	char *syslabel = NULL;

	time_t nowtime = time(NULL) + expirey;
	const char *fc = fullcontact ? "fullcontact" : NULL;
	
	snprintf(regseconds, sizeof(regseconds), "%d", (int)nowtime);	/* Expiration time */
	ast_copy_string(ipaddr, ast_inet_ntoa(sin->sin_addr), sizeof(ipaddr));
	snprintf(port, sizeof(port), "%d", ntohs(sin->sin_port));
	
	if (ast_strlen_zero(sysname))	/* No system name, disable this */
		sysname = NULL;
	else if (ast_test_flag(&global.flags[1], SIP_PAGE2_RTSAVE_SYSNAME))
		syslabel = "regserver";

	if (fc)
		ast_update_realtime("sippeers", "name", peername, "ipaddr", ipaddr,
			"port", port, "regseconds", regseconds,
			"defaultuser", username, fc, fullcontact, syslabel, sysname, NULL); /* note fc and syslabel _can_ be NULL */
	else
		ast_update_realtime("sippeers", "name", peername, "ipaddr", ipaddr,
			"port", port, "regseconds", regseconds,
			"defaultuser", username, syslabel, sysname, NULL); /* note syslabel _can_ be NULL */
}

/*! \brief Automatically add peer extension to dial plan */
static void register_peer_exten(struct sip_peer *device, int onoff)
{
	char multi[256];
	char *stringp, *ext, *context;

	/* XXX note that global.regcontext is both a global 'enable' flag and
	 * the name of the global regexten context, if not specified
	 * individually.
	 */
	if (ast_strlen_zero(global.regcontext))
		return;

	ast_copy_string(multi, S_OR(device->regexten, device->name), sizeof(multi));
	stringp = multi;
	while ((ext = strsep(&stringp, "&"))) {
		if ((context = strchr(ext, '@'))) {
			*context++ = '\0';	/* split ext@context */
			if (!ast_context_find(context)) {
				ast_log(LOG_WARNING, "Context %s must exist in regcontext= in sip.conf!\n", context);
				continue;
			}
		} else {
			context = global.regcontext;
		}
		if (onoff)
			ast_add_extension(context, 1, ext, 1, NULL, NULL, "Noop",
				 ast_strdup(device->name), ast_free, "SIP");
		else
			ast_context_remove_extension(context, ext, 1, NULL);
	}
}

/*! \brief Destroy device object from memory */
GNURK void sip_destroy_device(struct sip_peer *device)
{
	logdebug(3, "Destroying SIP device %s\n", device->name);
	//if (option_debug > 2)
		//ast_log(LOG_DEBUG, "Destroying SIP %s %s\n", device->type & SIP_USER ? "user" : "peer", device->name);

	/* Delete it, it needs to disappear */
	if (device->call)
		sip_destroy(device->call);
	if (device->chanvars) {
		ast_variables_destroy(device->chanvars);
		device->chanvars = NULL;
	}

	if (device->mwipvt) 		/* We have an active subscription, delete it */
		sip_destroy(device->mwipvt);

	if (device->expire > -1)
		ast_sched_del(sched, device->expire);
	if (device->pokeexpire > -1)
		ast_sched_del(sched, device->pokeexpire);
	ast_free_ha(device->ha);

	if (device->type & SIP_PEER) {
		register_peer_exten(device, FALSE);
		clear_realm_authentication(device->auth);
		device->auth = (struct sip_auth *) NULL;
		if (ast_test_flag((&device->flags[1]), SIP_PAGE2_SELFDESTRUCT))
			sipcounters.autocreated_peers--;
		else if (ast_test_flag(&device->flags[0], SIP_REALTIME))
			sipcounters.realtime_peers--;
		else
			sipcounters.static_peers--;
	} 
	if (device->type & SIP_USER) {	/* SIP_USER */
		if (ast_test_flag(&device->flags[0], SIP_REALTIME))
			sipcounters.realtime_users--;
		else
			sipcounters.static_users--;
	}
	if (device->dnsmgr)
		ast_dnsmgr_release(device->dnsmgr);
	if (device->registry) {
		device->registry->peer = NULL;
		ASTOBJ_UNREF(device->registry,sip_registry_destroy);
	}
	free(device);
}

/*! \brief Update peer data in database (if used) */
static void update_peer(struct sip_peer *device, int expiry)
{
	int rtcachefriends = ast_test_flag(&device->flags[1], SIP_PAGE2_RTCACHEFRIENDS);
	if (ast_test_flag(&global.flags[1], SIP_PAGE2_RTUPDATE) &&
	    (ast_test_flag(&device->flags[0], SIP_REALTIME) || rtcachefriends)) {
		realtime_update_peer(device->name, &device->addr, device->defaultuser, rtcachefriends ? device->fullcontact : NULL, expiry);
	}
}

/*! \brief Support routine for find_device */
static int sip_addrcmp(char *name, struct sockaddr_in *sin)
{
	/* We know name is the first field, so we can cast */
	struct sip_peer *peer = (struct sip_peer *) name;
	return 	!(!inaddrcmp(&peer->addr, sin) || 
					(ast_test_flag(&peer->flags[0], SIP_INSECURE_PORT) &&
					(peer->addr.sin_addr.s_addr == sin->sin_addr.s_addr)));
}

/*! \brief Locate peer by name or ip address 
 *	This is used on incoming SIP message to find matching peer on ip
	or outgoing message to find matching peer on name */
GNURK struct sip_peer *find_device(const char *device, struct sockaddr_in *sin, int realtime)
{
	struct sip_peer *peer = NULL;

	if (device)
		peer = ASTOBJ_CONTAINER_FIND(&devicelist, device);
	else
		peer = ASTOBJ_CONTAINER_FIND_FULL(&devicelist, sin, name, sip_addr_hashfunc, 1, sip_addrcmp);

	if (!peer && realtime)
		peer = realtime_peer(device, sin);

	return peer;
}

/*! \brief Set nat mode on the various media streams */
GNURK void do_setnat(struct sip_dialog *dialog, int natflags)
{
	const char *mode = natflags ? "On" : "Off";

	if (dialog->rtp) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Setting NAT on RTP to %s\n", mode);
		ast_rtp_setnat(dialog->rtp, natflags);
	}
	if (dialog->vrtp) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Setting NAT on VRTP to %s\n", mode);
		ast_rtp_setnat(dialog->vrtp, natflags);
	}
	if (dialog->udptl) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Setting NAT on UDPTL to %s\n", mode);
		ast_udptl_setnat(dialog->udptl, natflags);
	}
}

/*! \brief Create address structure from device reference.
 *  return -1 on error, 0 on success.
 */
static int create_addr_from_peer(struct sip_dialog *dialog, struct sip_peer *device)
{
	if ((device->addr.sin_addr.s_addr || device->defaddr.sin_addr.s_addr) &&
	    (!device->maxms || ((device->lastms >= 0)  && (device->lastms <= device->maxms)))) {
		dialog->sa = (device->addr.sin_addr.s_addr) ? device->addr : device->defaddr;
		dialog->recv = dialog->sa;
	} else 
		return -1;

	ast_copy_flags(&dialog->flags[0], &device->flags[0], SIP_FLAGS_TO_COPY);
	ast_copy_flags(&dialog->flags[1], &device->flags[1], SIP_PAGE2_FLAGS_TO_COPY);
	dialog->capability = device->capability;
	if (!ast_test_flag(&dialog->flags[1], SIP_PAGE2_VIDEOSUPPORT) && dialog->vrtp) {
		ast_rtp_destroy(dialog->vrtp);
		dialog->vrtp = NULL;
	}
	dialog->prefs = device->prefs;
	if (ast_test_flag(&dialog->flags[1], SIP_PAGE2_T38SUPPORT)) {
		dialog->t38.capability = global.t38_capability;
		if (dialog->udptl) {
			if (ast_udptl_get_error_correction_scheme(dialog->udptl) == UDPTL_ERROR_CORRECTION_FEC )
				dialog->t38.capability |= T38FAX_UDP_EC_FEC;
			else if (ast_udptl_get_error_correction_scheme(dialog->udptl) == UDPTL_ERROR_CORRECTION_REDUNDANCY )
				dialog->t38.capability |= T38FAX_UDP_EC_REDUNDANCY;
			else if (ast_udptl_get_error_correction_scheme(dialog->udptl) == UDPTL_ERROR_CORRECTION_NONE )
				dialog->t38.capability |= T38FAX_UDP_EC_NONE;
			dialog->t38.capability |= T38FAX_RATE_MANAGEMENT_TRANSFERED_TCF;
			if (option_debug > 1)
				ast_log(LOG_DEBUG,"Our T38 capability (%d)\n", dialog->t38.capability);
		}
		dialog->t38.jointcapability = dialog->t38.capability;
	} else if (dialog->udptl) {
		ast_udptl_destroy(dialog->udptl);
		dialog->udptl = NULL;
	}
	do_setnat(dialog, ast_test_flag(&dialog->flags[0], SIP_NAT) & SIP_NAT_ROUTE );

	if (dialog->rtp) {
		ast_rtp_setdtmf(dialog->rtp, ast_test_flag(&dialog->flags[0], SIP_DTMF) != SIP_DTMF_INFO);
		ast_rtp_setdtmfcompensate(dialog->rtp, ast_test_flag(&dialog->flags[1], SIP_PAGE2_RFC2833_COMPENSATE));
	}
	if (dialog->vrtp) {
		ast_rtp_setdtmf(dialog->vrtp, 0);
		ast_rtp_setdtmfcompensate(dialog->vrtp, 0);
	}

	/* Set Frame packetization */
	if (dialog->rtp) {
		ast_rtp_codec_setpref(dialog->rtp, &dialog->prefs);
		dialog->autoframing = device->autoframing;
	}

	/* XXX Why use username for all of this? */
	//ast_string_field_set(dialog, peername, device->defaultuser);

	ast_string_field_set(dialog, peername, device->name);
	/* Authuser is fromuser, and if that not is set, it's the defaultuser, if that's set */
	
	if (ast_strlen_zero(device->fromuser))
		ast_string_field_set(dialog, authname, device->defaultuser);
	else
		ast_string_field_set(dialog, authname, device->fromuser);
	ast_string_field_set(dialog, defaultuser, device->defaultuser);
	ast_string_field_set(dialog, peersecret, device->secret);
	ast_string_field_set(dialog, peermd5secret, device->md5secret);
	ast_string_field_set(dialog, tohost, device->tohost);
	ast_string_field_set(dialog, fullcontact, device->fullcontact);
	if (!dialog->initreq.headers && !ast_strlen_zero(device->fromdomain)) {
		char *tmpcall;
		char *c;
		tmpcall = ast_strdupa(dialog->callid);
		c = strchr(tmpcall, '@');
		if (c) {
			*c = '\0';
			ast_string_field_build(dialog, callid, "%s@%s", tmpcall, device->fromdomain);
		}
	}
	if (ast_strlen_zero(dialog->tohost))
		ast_string_field_set(dialog, tohost, ast_inet_ntoa(dialog->sa.sin_addr));
	if (!ast_strlen_zero(device->fromdomain))
		ast_string_field_set(dialog, fromdomain, device->fromdomain);
	if (!ast_strlen_zero(device->fromuser))
		ast_string_field_set(dialog, fromuser, device->fromuser);
	dialog->callgroup = device->callgroup;
	dialog->pickupgroup = device->pickupgroup;
	dialog->allowtransfer = device->allowtransfer;
	/* Set timer T1 to RTT for this peer (if known by qualify=) */
	/* Minimum is settable or default to 100 ms */
	if (device->maxms && device->lastms)
		dialog->timer_t1 = device->lastms < global.t1min ? global.t1min : device->lastms;
	if ((ast_test_flag(&dialog->flags[0], SIP_DTMF) == SIP_DTMF_RFC2833) ||
	    (ast_test_flag(&dialog->flags[0], SIP_DTMF) == SIP_DTMF_AUTO))
		dialog->noncodeccapability |= AST_RTP_DTMF;
	else
		dialog->noncodeccapability &= ~AST_RTP_DTMF;
	ast_string_field_set(dialog, context, device->context);
	dialog->rtptimeout = device->rtptimeout;
	dialog->rtpholdtimeout = device->rtpholdtimeout;
	dialog->rtpkeepalive = device->rtpkeepalive;
	if (device->call_limit)
		ast_set_flag(&dialog->flags[0], SIP_CALL_LIMIT);
	dialog->maxcallbitrate = device->maxcallbitrate;
	
	return 0;
}

/*! \brief create address structure from peer name
 *      Or, if peer not found, find it in the global DNS 
 *      returns TRUE (-1) on failure, FALSE on success */
GNURK int create_addr(struct sip_dialog *dialog, const char *opeer)
{
	struct hostent *hp;
	struct ast_hostent ahp;
	struct sip_peer *p;
	char *port;
	int portno;
	char host[MAXHOSTNAMELEN], *hostn;
	char peername[256];

	ast_copy_string(peername, opeer, sizeof(peername));
	port = strchr(peername, ':');
	if (port)
		*port++ = '\0';
	dialog->sa.sin_family = AF_INET;
	dialog->timer_t1 = SIP_TIMER_T1_DEFAULT; /* Default SIP retransmission timer T1 (RFC 3261) */
	p = find_device(peername, NULL, 1);

	if (p) {
		int res = create_addr_from_peer(dialog, p);
		ASTOBJ_UNREF(p, sip_destroy_device);
		return res;
	}
	hostn = peername;
	portno = port ? atoi(port) : STANDARD_SIP_PORT;
	if (global.srvlookup) {
		char service[MAXHOSTNAMELEN];
		int tportno;
		int ret;

		snprintf(service, sizeof(service), "_sip._udp.%s", peername);
		ret = ast_get_srv(NULL, host, sizeof(host), &tportno, service);
		if (ret > 0) {
			hostn = host;
			portno = tportno;
		}
		hp = ast_gethostbyname(hostn, &ahp);
		if (hp) {
			ast_string_field_set(dialog, tohost, peername);
			memcpy(&dialog->sa.sin_addr, hp->h_addr, sizeof(dialog->sa.sin_addr));
			dialog->sa.sin_port = htons(portno);
			dialog->recv = dialog->sa;
			return 0;
		} else {
			ast_log(LOG_WARNING, "No such host: %s\n", peername);
			return -1;
		}
	} else {
		ASTOBJ_UNREF(p, sip_destroy_device);
		return 0;
	}
	hp = ast_gethostbyname(hostn, &ahp);
	if (!hp) {
		ast_log(LOG_WARNING, "No such host: %s\n", peername);
		return -1;
	}
	ast_string_field_set(dialog, tohost, peername);
	memcpy(&dialog->sa.sin_addr, hp->h_addr, sizeof(dialog->sa.sin_addr));
	dialog->sa.sin_port = htons(portno);
	dialog->recv = dialog->sa;
	return 0;
}

/*! \brief Scheduled congestion on a call */
static int auto_congest(void *nothing)
{
	struct sip_dialog *dialog = nothing;

	dialog_lock(dialog, TRUE);
	dialog->initid = -1;
	if (dialog->owner) {
		/* XXX fails on possible deadlock */
		if (!ast_channel_trylock(dialog->owner)) {
			ast_log(LOG_NOTICE, "Auto-congesting %s\n", dialog->owner->name);
			append_history(dialog, "Cong", "Auto-congesting (timer)");
			ast_queue_control(dialog->owner, AST_CONTROL_CONGESTION);
			ast_channel_unlock(dialog->owner);
		}
	}
	dialog_lock(dialog, FALSE);
	return 0;
}


/*! \brief Initiate SIP call from PBX 
 *      used from the dial() application      */
static int sip_call(struct ast_channel *ast, char *dest, int timeout)
{
	int res;
	struct sip_dialog *p;
	struct varshead *headp;
	struct ast_var_t *current;
	const char *referer = NULL;   /* SIP refererer */	

	p = ast->tech_pvt;
	if ((ast->_state != AST_STATE_DOWN) && (ast->_state != AST_STATE_RESERVED)) {
		ast_log(LOG_WARNING, "sip_call called on %s, neither down nor reserved\n", ast->name);
		return -1;
	}

	/* Check whether there is vxml_url, distinctive ring variables */
	headp=&ast->varshead;
	AST_LIST_TRAVERSE(headp,current,entries) {
		/* Check whether there is a VXML_URL variable */
		if (!p->options->vxml_url && !strcasecmp(ast_var_name(current), "VXML_URL")) {
			p->options->vxml_url = ast_var_value(current);
		} else if (!p->options->uri_options && !strcasecmp(ast_var_name(current), "SIP_URI_OPTIONS")) {
			p->options->uri_options = ast_var_value(current);
		} else if (!p->options->addsipheaders && !strncasecmp(ast_var_name(current), "SIPADDHEADER", strlen("SIPADDHEADER"))) {
			/* Check whether there is a variable with a name starting with SIPADDHEADER */
			p->options->addsipheaders = 1;
		} else if (!strcasecmp(ast_var_name(current), "SIPTRANSFER")) {
			/* This is a transfered call */
			p->options->transfer = 1;
		} else if (!strcasecmp(ast_var_name(current), "SIPTRANSFER_REFERER")) {
			/* This is the referer */
			referer = ast_var_value(current);
		} else if (!strcasecmp(ast_var_name(current), "SIPTRANSFER_REPLACES")) {
			/* We're replacing a call. */
			p->options->replaces = ast_var_value(current);
		} else if (!strcasecmp(ast_var_name(current), "T38CALL")) {
			p->t38.state = T38_LOCAL_DIRECT;
			if (option_debug)
				ast_log(LOG_DEBUG,"T38State change to %d on channel %s\n", p->t38.state, ast->name);
		}

	}
	
	res = 0;
	ast_set_flag(&p->flags[0], SIP_OUTGOING);

	if (p->options->transfer) {
		char buf[BUFSIZ/2];

		if (referer) {
			if (sipdebug && option_debug > 2)
				ast_log(LOG_DEBUG, "Call for %s transfered by %s\n", p->peername, referer);
			snprintf(buf, sizeof(buf)-1, "-> %s (via %s)", p->cid_name, referer);
		} else 
			snprintf(buf, sizeof(buf)-1, "-> %s", p->cid_name);
		ast_string_field_set(p, cid_name, buf);
	} 
	if (option_debug)
		ast_log(LOG_DEBUG, "Outgoing Call for %s\n", p->peername);

	res = update_call_counter(p, INC_CALL_RINGING);
	if ( res != -1 ) {
		p->callingpres = ast->cid.cid_pres;
		p->jointcapability = ast_translate_available_formats(p->capability, p->prefcodec);
		if (!(p->jointcapability & AST_FORMAT_AUDIO_MASK)) {	
			ast_log(LOG_WARNING, "No audio formats found to offer. Cancelling call to %s\n", p->username);
			res = -1;
		} else {
			p->t38.jointcapability = p->t38.capability;
			if (option_debug)
				ast_log(LOG_DEBUG,"Our T38 capability (%d), joint T38 capability (%d)\n", p->t38.capability, p->t38.jointcapability);
			transmit_invite(p, SIP_INVITE, TRUE, 2);
			p->initid = ast_sched_add(sched, SIP_TRANS_TIMEOUT, auto_congest, p);
		}
	}
	return res;
}

/*! \brief  update_call_counter: Handle call_limit for SIP users 
 * Setting a call-limit will cause calls above the limit not to be accepted.
 *
 * Remember that for a type=friend, there's one limit for the user and
 * another for the peer, not a combined call limit.
 * This will cause unexpected behaviour in subscriptions, since a "friend"
 * is *two* devices in Asterisk, not one.
 *
 * Thought: For realtime, we should propably update storage with inuse counter... 
 *
 * \return 0 if call is ok (no call limit, below treshold)
 *	-1 on rejection of call
 *		
 */
GNURK int update_call_counter(struct sip_dialog *fup, int event)
{
	char name[256];
	int outgoing = ast_test_flag(&fup->flags[0], SIP_OUTGOING);
	struct sip_peer *device = NULL;

	if (option_debug > 2)
		ast_log(LOG_DEBUG, "Updating call counter for %s call\n", outgoing ? "outgoing" : "incoming");
	/* Test if we need to check call limits, in order to avoid 
	   realtime lookups if we do not need it */
	if (!ast_test_flag(&fup->flags[0], SIP_CALL_LIMIT))
		return 0;

	ast_copy_string(name, fup->peername, sizeof(name));

	/* Check the list of devices */
	device = find_device(fup->peername, NULL, 1);
	if (!device) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "%s is not a local device, no call limit\n", name);
		return 0;
	}

	switch(event) {
		/* incoming and outgoing affects the inUse counter */
		case DEC_CALL_LIMIT:
			if ( device->inUse > 0 ) {
				if (ast_test_flag(&fup->flags[0], SIP_INC_COUNT))
					device->inUse--;
			} else {
				device->inUse= 0;
			}
			if (ast_test_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING)) {
				if (device->inRinging > 0)
					(device->inRinging)--;
				else
					ast_log(LOG_WARNING, "Inringing for peer '%s' < 0?\n", fup->peername);
				ast_clear_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING);
			}
			if (option_debug > 1 || sipdebug) {
				ast_log(LOG_DEBUG, "Call %s %s '%s' removed from call limit %d\n", outgoing ? "to" : "from", device->type & SIP_USER ? "user":"peer", name, device->call_limit);
			}
			break;
		case INC_CALL_RINGING:
		case INC_CALL_LIMIT:
			if (device->call_limit > 0 ) {
				if (device->inUse >= device->call_limit) {
					ast_log(LOG_ERROR, "Call %s %s '%s' rejected due to usage limit of %d\n", outgoing ? "to" : "from", device->type & SIP_USER ? "user":"peer", name, device->call_limit);
					ASTOBJ_UNREF(device, sip_destroy_device);
					return -1; 
				}
			}
			if (event == INC_CALL_RINGING) {
				if (!ast_test_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING)) {
					device->inRinging++;
					ast_set_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING);
				}
			}
			/* Continue */
			device->inUse++;
			ast_set_flag(&fup->flags[0], SIP_INC_COUNT);
			if (option_debug > 1 || sipdebug) {
				ast_log(LOG_DEBUG, "Call %s %s '%s' is %d out of %d\n", outgoing ? "to" : "from", device->type & SIP_USER ? "user" : "peer", name, device->inUse, device->call_limit);
			}
			break;
		case DEC_CALL_RINGING:
			if (ast_test_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING)) {
				if (device->inRinging > 0)
						device->inRinging--;
				else
					ast_log(LOG_WARNING, "Inringing for peer '%s' < 0?\n", device->name);
				ast_clear_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING);
			}
			break;
		default:
			ast_log(LOG_ERROR, "update_call_counter(%s, %d) called with no event!\n", name, event);
	}
	ast_device_state_changed("SIP/%s", device->name);
	ASTOBJ_UNREF(device, sip_destroy_device);
	return 0;
}

/*! \brief  sip_hangup: Hangup SIP call
 * Part of PBX interface, called from ast_hangup */
static int sip_hangup(struct ast_channel *ast)
{
	struct sip_dialog *p = ast->tech_pvt;
	int needcancel = FALSE;
	int needdestroy = 0;
	struct ast_channel *oldowner = ast;

	if (!p) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Asked to hangup channel that was not connected\n");
		return 0;
	}

	if (ast_test_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER)) {
		if (option_debug >3)
			ast_log(LOG_DEBUG, "SIP Transfer: Not hanging up right now... Rescheduling hangup for %s.\n", p->callid);
		if (p->autokillid > -1)
			sip_cancel_destroy(p);
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);	/* This does not issue BYE  - fix needed */
		ast_clear_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER);	/* Really hang up next time */
		ast_clear_flag(&p->flags[0], SIP_NEEDDESTROY);
		p->owner->tech_pvt = NULL;
		p->owner = NULL;  /* Owner will be gone after we return, so take it away */
		return 0;
	}
	if (option_debug > 1) {
		if (ast_test_flag(ast, AST_FLAG_ZOMBIE) && p->refer && option_debug)
         		ast_log(LOG_DEBUG, "SIP Transfer: Hanging up Zombie channel %s after transfer ... Call-ID: %s\n", ast->name, p->callid);
		else  
			ast_log(LOG_DEBUG, "Hangup call %s, SIP callid %s)\n", ast->name, p->callid);
	}
	if (option_debug > 1 && ast_test_flag(ast, AST_FLAG_ZOMBIE)) 
		ast_log(LOG_DEBUG, "Hanging up zombie call. Be scared.\n");

	dialog_lock(p, TRUE);
	if (option_debug && sipdebug)
		ast_log(LOG_DEBUG, "update_call_counter(%s) - decrement call limit counter on hangup\n", p->peername);
	update_call_counter(p, DEC_CALL_LIMIT);		/* Fix call limit counter */

	/* Determine how to disconnect */
	if (p->owner != ast) {
		ast_log(LOG_WARNING, "Huh?  We aren't the owner? Can't hangup call.\n");
		dialog_lock(p, FALSE);
		return 0;
	}
	/* If the call is not UP, we need to send CANCEL instead of BYE */
	if (ast->_state == AST_STATE_RING || ast->_state == AST_STATE_RINGING) {
		needcancel = TRUE;
		if (option_debug > 3)
			ast_log(LOG_DEBUG, "Hanging up channel in state %s (not UP)\n", ast_state2str(ast->_state));
	}

	/* Disconnect */
	if (p->vad)
		ast_dsp_free(p->vad);

	/* Disconnect us from the owner */
	p->owner = NULL;
	ast->tech_pvt = NULL;

	/* Do not destroy this pvt until we have timeout or
	   get an answer to the BYE or INVITE/CANCEL 
	   If we get no answer during retransmit period, drop the call anyway.
	   (Sorry, mother-in-law, you can't deny a hangup by sending
	   603 declined to BYE...)
	*/
	if (ast_test_flag(&p->flags[0], SIP_ALREADYGONE))
		needdestroy = 1;	/* Set destroy flag at end of this function */
	else
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);

	/* Start the process if it's not already started */
	if (!ast_test_flag(&p->flags[0], SIP_ALREADYGONE) && !ast_strlen_zero(p->initreq.data)) {
		if (needcancel) {	/* Outgoing call, not up */
			if (ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
				/* stop retransmitting an INVITE that has not received a response */
				__sip_pretend_ack(p);

				/* if we can't send right now, mark it pending */
				if (p->state == DIALOG_STATE_TRYING) {
					ast_set_flag(&p->flags[0], SIP_PENDINGBYE);
					/* Do we need a timer here if we don't hear from them at all? */
				} else {
					/* Send a new request: CANCEL */
					transmit_request_with_auth(p, SIP_CANCEL, p->ocseq, XMIT_RELIABLE, FALSE);
					/* Actually don't destroy us yet, wait for the 487 on our original 
					   INVITE, but do set an autodestruct just in case we never get it. */
					needdestroy = 0;
					sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
					dialogstatechange(p, DIALOG_STATE_TERMINATED);
				}
				if ( p->initid != -1 ) {
					/* channel still up - reverse dec of inUse counter
					   only if the channel is not auto-congested */
					update_call_counter(p, INC_CALL_LIMIT);
				}
			} else {	/* Incoming call, not up */
				const char *res;
				if (ast->hangupcause && (res = hangup_cause2sip(ast->hangupcause)))
					transmit_response_reliable(p, res, &p->initreq);
				else 
					transmit_response_reliable(p, "603 Declined", &p->initreq);
				dialogstatechange(p, DIALOG_STATE_TERMINATED);
			}
		} else {	/* Call is in UP state, send BYE */
			if (!p->pendinginvite) {
				char *audioqos = "";
				char *videoqos = "";
				if (p->rtp)
					audioqos = ast_rtp_get_quality(p->rtp);
				if (p->vrtp)
					videoqos = ast_rtp_get_quality(p->vrtp);

				/* Get RTCP quality before end of call */
				if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY)) {
					if (p->rtp)
						append_history(p, "RTCPaudio", "Quality:%s", audioqos);
					if (p->vrtp)
						append_history(p, "RTCPvideo", "Quality:%s", videoqos);
				}
				if (p->rtp && oldowner)
					pbx_builtin_setvar_helper(oldowner, "RTPAUDIOQOS", audioqos);
				if (p->vrtp && oldowner)
					pbx_builtin_setvar_helper(oldowner, "RTPVIDEOQOS", videoqos);
				dialogstatechange(p, DIALOG_STATE_TERMINATED);

				/* Send a hangup */
				transmit_request_with_auth(p, SIP_BYE, 0, XMIT_RELIABLE, 1);
			} else {
				/* Note we will need a BYE when this all settles out
				   but we can't send one while we have "INVITE" outstanding. */
				ast_set_flag(&p->flags[0], SIP_PENDINGBYE);	
				ast_clear_flag(&p->flags[0], SIP_NEEDREINVITE);	
			}
		}
	}
	if (needdestroy)
		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);

	if(!ast_test_flag(&p->flags[0], SIP_PENDINGBYE))
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);	/* If we don't get answer in 32 secs, destroy */
	dialog_lock(p, FALSE);
	return 0;
}

/*! \brief Try setting codec suggested by the SIP_CODEC channel variable */
static void try_suggested_sip_codec(struct sip_dialog *p)
{
	int fmt;
	const char *codec;

	codec = pbx_builtin_getvar_helper(p->owner, "SIP_CODEC");
	if (!codec) 
		return;

	fmt = ast_getformatbyname(codec);
	if (fmt) {
		ast_log(LOG_NOTICE, "Changing codec to '%s' for this call because of ${SIP_CODEC} variable\n", codec);
		if (p->jointcapability & fmt) {
			p->jointcapability &= fmt;
			p->capability &= fmt;
		} else
			ast_log(LOG_NOTICE, "Ignoring ${SIP_CODEC} variable because it is not shared by both ends.\n");
	} else
		ast_log(LOG_NOTICE, "Ignoring ${SIP_CODEC} variable because of unrecognized/not configured codec (check allow/disallow in sip.conf): %s\n", codec);
	return;	
}

/*! \brief  sip_answer: Answer SIP call , send 200 OK on Invite 
 * Part of PBX interface */
static int sip_answer(struct ast_channel *ast)
{
	int res = 0;
	struct sip_dialog *dialog = ast->tech_pvt;

	dialog_lock(dialog, TRUE);
	if (ast->_state != AST_STATE_UP) {
		try_suggested_sip_codec(dialog);	

		ast_setstate(ast, AST_STATE_UP);
		if (option_debug)
			ast_log(LOG_DEBUG, "SIP answering channel: %s\n", ast->name);
		if (dialog->t38.state == T38_PEER_DIRECT) {
			dialog->t38.state = T38_ENABLED;
			if (option_debug > 1)
				ast_log(LOG_DEBUG,"T38State change to %d on channel %s\n", dialog->t38.state, ast->name);
			res = transmit_response_with_attachment(WITH_T38_SDP, dialog, "200 OK", &dialog->initreq, XMIT_CRITICAL);
		} else 
			res = transmit_response_with_attachment(WITH_SDP, dialog, "200 OK", &dialog->initreq, XMIT_CRITICAL);
		dialogstatechange(dialog, DIALOG_STATE_CONFIRMED);
	}
	dialog_lock(dialog, FALSE);
	return res;
}

/*! \brief Send frame to media channel (rtp) */
static int sip_write(struct ast_channel *ast, struct ast_frame *frame)
{
	struct sip_dialog *p = ast->tech_pvt;
	int res = 0;

	switch (frame->frametype) {
	case AST_FRAME_VOICE:
		if (!(frame->subclass & ast->nativeformats)) {
			char s1[512], s2[512], s3[512];
			ast_log(LOG_WARNING, "Asked to transmit frame type %d, while native formats is %s(%d) read/write = %s(%d)/%s(%d)\n",
				frame->subclass, 
				ast_getformatname_multiple(s1, sizeof(s1) - 1, ast->nativeformats & AST_FORMAT_AUDIO_MASK),
				ast->nativeformats & AST_FORMAT_AUDIO_MASK,
				ast_getformatname_multiple(s2, sizeof(s2) - 1, ast->readformat),
				ast->readformat,
				ast_getformatname_multiple(s3, sizeof(s3) - 1, ast->writeformat),
				ast->writeformat);
			return 0;
		}
		if (p) {
			dialog_lock(p, TRUE);
			if (p->rtp) {
				/* If channel is not up, activate early media session */
				if ((ast->_state != AST_STATE_UP) &&
				    !ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) &&
				    !ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
					transmit_response_with_attachment(WITH_SDP, p, "183 Session Progress", &p->initreq, XMIT_UNRELIABLE);
					ast_set_flag(&p->flags[0], SIP_PROGRESS_SENT);	
				}
				p->lastrtptx = time(NULL);
				res = ast_rtp_write(p->rtp, frame);
			}
			dialog_lock(p, FALSE);
		}
		break;
	case AST_FRAME_VIDEO:
		if (p) {
			dialog_lock(p, TRUE);
			if (p->vrtp) {
				/* Activate video early media */
				if ((ast->_state != AST_STATE_UP) &&
				    !ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) &&
				    !ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
					transmit_response_with_attachment(WITH_SDP, p, "183 Session Progress", &p->initreq, XMIT_UNRELIABLE);
					ast_set_flag(&p->flags[0], SIP_PROGRESS_SENT);	
				}
				p->lastrtptx = time(NULL);
				res = ast_rtp_write(p->vrtp, frame);
			}
			dialog_lock(p, FALSE);
		}
		break;
	case AST_FRAME_IMAGE:
		return 0;
		break;
	case AST_FRAME_MODEM:
		if (p) {
			dialog_lock(p, TRUE);
			if (p->udptl) {
				if ((ast->_state != AST_STATE_UP) &&
					!ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) && 
				    !ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
					transmit_response_with_attachment(WITH_T38_SDP, p, "183 Session Progress", &p->initreq, XMIT_UNRELIABLE);
					ast_set_flag(&p->flags[0], SIP_PROGRESS_SENT);
				}
				res = ast_udptl_write(p->udptl, frame);
			}
			dialog_lock(p, FALSE);
		}
		break;
	default: 
		ast_log(LOG_WARNING, "Can't send %d type frames with SIP write\n", frame->frametype);
		return 0;
	}

	return res;
}

/*! \brief  sip_fixup: Fix up a channel:  If a channel is consumed, this is called.
        Basically update any ->owner links */
static int sip_fixup(struct ast_channel *oldchan, struct ast_channel *newchan)
{
	int ret = -1;
	struct sip_dialog *p;

	if (newchan && ast_test_flag(newchan, AST_FLAG_ZOMBIE) && option_debug)
		ast_log(LOG_DEBUG, "New channel is zombie\n");
	if (oldchan && ast_test_flag(oldchan, AST_FLAG_ZOMBIE) && option_debug)
		ast_log(LOG_DEBUG, "Old channel is zombie\n");

	if (!newchan || !newchan->tech_pvt) {
		if (!newchan)
			ast_log(LOG_WARNING, "No new channel! Fixup of %s failed.\n", oldchan->name);
		else
			ast_log(LOG_WARNING, "No SIP tech_pvt! Fixup of %s failed.\n", oldchan->name);
		return -1;
	}
	p = newchan->tech_pvt;

	dialog_lock(p, TRUE);
	append_history(p, "Masq", "Old channel: %s\n", oldchan->name);
	append_history(p, "Masq (cont)", "...new owner: %s\n", newchan->name);
	if (p->owner != oldchan)
		ast_log(LOG_WARNING, "old channel wasn't %p but was %p\n", oldchan, p->owner);
	else {
		p->owner = newchan;
		ret = 0;
	}
	if (option_debug > 2)
		ast_log(LOG_DEBUG, "SIP Fixup: New owner for dialogue %s: %s (Old parent: %s)\n", p->callid, p->owner->name, oldchan->name);

	dialog_lock(p, FALSE);
	return ret;
}

/*! \brief Start sending DTMF character on SIP channel
	within one call, we're able to transmit in many methods simultaneously */
static int sip_senddigit_begin(struct ast_channel *ast, char digit)
{
	struct sip_dialog *p = ast->tech_pvt;
	int res = 0;

	dialog_lock(p, TRUE);
	switch (ast_test_flag(&p->flags[0], SIP_DTMF)) {
	case SIP_DTMF_INBAND:
		res = -1; /* Tell Asterisk to generate inband indications */
		break;
	case SIP_DTMF_RFC2833:
		if (p->rtp)
			ast_rtp_senddigit_begin(p->rtp, digit);
		break;
	default:
		break;
	}
	dialog_lock(p, FALSE);

	return res;
}

/*! \brief Send DTMF character on SIP channel
	within one call, we're able to transmit in many methods simultaneously */
static int sip_senddigit_end(struct ast_channel *ast, char digit)
{
	struct sip_dialog *p = ast->tech_pvt;
	int res = 0;

	dialog_lock(p, TRUE);
	switch (ast_test_flag(&p->flags[0], SIP_DTMF)) {
	case SIP_DTMF_INFO:
		transmit_info_with_digit(p, digit);
		break;
	case SIP_DTMF_RFC2833:
		if (p->rtp)
			ast_rtp_senddigit_end(p->rtp, digit);
		break;
	case SIP_DTMF_INBAND:
		res = -1; /* Tell Asterisk to stop inband indications */
		break;
	}
	dialog_lock(p, FALSE);

	return res;
}

/*! \brief Transfer SIP call */
static int sip_transfer(struct ast_channel *ast, const char *dest)
{
	struct sip_dialog *p = ast->tech_pvt;
	int res;

	if (dest == NULL)
		dest = "";
	dialog_lock(p, TRUE);
	if (ast->_state == AST_STATE_RING)
		res = sip_sipredirect(p, dest);
	else
		res = transmit_refer(p, dest);
	dialog_lock(p, FALSE);
	return res;
}

/*! \brief Play indication to user 
 * With SIP a lot of indications is sent as messages, letting the device play
   the indication - busy signal, congestion etc 
   \return -1 to force ast_indicate to send indication in audio, 0 if SIP can handle the indication by sending a message
*/
static int sip_indicate(struct ast_channel *ast, int condition, const void *data, size_t datalen)
{
	struct sip_dialog *p = ast->tech_pvt;
	int res = 0;

	dialog_lock(p, TRUE);
	switch(condition) {
	case AST_CONTROL_RINGING:
		if (ast->_state == AST_STATE_RING) {
			if (!ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) ||
			    (ast_test_flag(&p->flags[0], SIP_PROG_INBAND) == SIP_PROG_INBAND_NEVER)) {				
				/* Send 180 ringing if out-of-band seems reasonable */
				transmit_response(p, "180 Ringing", &p->initreq);
				ast_set_flag(&p->flags[0], SIP_RINGING);
				if (ast_test_flag(&p->flags[0], SIP_PROG_INBAND) != SIP_PROG_INBAND_YES)
					break;
			} else {
				/* Well, if it's not reasonable, just send in-band */
			}
		}
		res = -1;
		break;
	case AST_CONTROL_BUSY:
		if (ast->_state != AST_STATE_UP) {
			transmit_final_response(p, "486 Busy Here", &p->initreq, XMIT_RELIABLE);
			ast_softhangup_nolock(ast, AST_SOFTHANGUP_DEV);
			break;
		}
		res = -1;
		break;
	case AST_CONTROL_CONGESTION:
		if (ast->_state != AST_STATE_UP) {
			transmit_final_response(p, "503 Service Unavailable", &p->initreq, XMIT_RELIABLE);
			ast_softhangup_nolock(ast, AST_SOFTHANGUP_DEV);
			break;
		}
		res = -1;
		break;
	case AST_CONTROL_PROCEEDING:
		if ((ast->_state != AST_STATE_UP) &&
		    !ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) &&
		    !ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
			transmit_response(p, "100 Trying", &p->initreq);
			break;
		}
		res = -1;
		break;
	case AST_CONTROL_PROGRESS:
		if ((ast->_state != AST_STATE_UP) &&
		    !ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) &&
		    !ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
			transmit_response_with_attachment(WITH_SDP, p, "183 Session Progress", &p->initreq, XMIT_UNRELIABLE);
			ast_set_flag(&p->flags[0], SIP_PROGRESS_SENT);	
			break;
		}
		res = -1;
		break;
	case AST_CONTROL_HOLD:
		ast_moh_start(ast, data, p->mohinterpret);
		break;
	case AST_CONTROL_UNHOLD:
		ast_moh_stop(ast);
		break;
	case AST_CONTROL_VIDUPDATE:	/* Request a video frame update */
		if (p->vrtp && !ast_test_flag(&p->flags[0], SIP_NOVIDEO)) {
			transmit_info_with_vidupdate(p);
			/* ast_rtcp_send_h261fur(p->vrtp); */
		} else
			res = -1;
		break;
	case -1:
		res = -1;
		break;
	default:
		ast_log(LOG_WARNING, "Don't know how to indicate condition %d\n", condition);
		res = -1;
		break;
	}
	dialog_lock(p, FALSE);
	return res;
}



/*! \brief Initiate a call in the SIP channel
	called from sip_request_call (calls from the pbx ) for outbound channels
	and from handle_request_invite for inbound channels
	
*/
static struct ast_channel *sip_new(struct sip_dialog *dialog, int state, const char *title)
{
	struct ast_channel *tmp;
	struct ast_variable *v = NULL;
	int fmt;
	int what;
	int needvideo = 0;
	
	{
		const char *my_name;	/* pick a good name */
	
		if (title)
			my_name = title;
		else if ( (my_name = strchr(dialog->fromdomain,':')) )
			my_name++;	/* skip ':' */
		else
			my_name = dialog->fromdomain;

		dialog_lock(dialog, FALSE);
		/* Don't hold a sip pvt lock while we allocate a channel */

		tmp = ast_channel_alloc(1, state, dialog->cid_num, dialog->cid_name, "SIP/%s-%08x", my_name, (int)(long) dialog);

	}
	dialog_lock(dialog, TRUE);
	if (!tmp) {
		ast_log(LOG_WARNING, "Unable to allocate AST channel structure for SIP channel\n");
		return NULL;
	}
	tmp->tech = &sip_tech;

	/* Select our native format based on codec preference until we receive
	   something from another device to the contrary. */
	if (dialog->jointcapability)	 	/* The joint capabilities of us and peer */
		what = dialog->jointcapability;
	else if (dialog->capability)		/* Our configured capability for this peer */
		what = dialog->capability;
	else
		what = global.capability;	/* Global codec support */

	/* Set the native formats for audio  and merge in video */
	tmp->nativeformats = ast_codec_choose(&dialog->prefs, what, 1) | (dialog->jointcapability & AST_FORMAT_VIDEO_MASK);
	if (option_debug > 2) {
		char buf[BUFSIZ];
		ast_log(LOG_DEBUG, "*** Our native formats are %s \n", ast_getformatname_multiple(buf, BUFSIZ, tmp->nativeformats));
		ast_log(LOG_DEBUG, "*** Joint capabilities are %s \n", ast_getformatname_multiple(buf, BUFSIZ, dialog->jointcapability));
		ast_log(LOG_DEBUG, "*** Our capabilities are %s \n", ast_getformatname_multiple(buf, BUFSIZ, dialog->capability));
		ast_log(LOG_DEBUG, "*** AST_CODEC_CHOOSE formats are %s \n", ast_getformatname_multiple(buf, BUFSIZ, ast_codec_choose(&dialog->prefs, what, 1)));
		if (dialog->prefcodec)
			ast_log(LOG_DEBUG, "*** Our preferred formats from the incoming channel are %s \n", ast_getformatname_multiple(buf, BUFSIZ, dialog->prefcodec));
	}

	/* XXX Why are we choosing a codec from the native formats?? */
	fmt = ast_best_codec(tmp->nativeformats);

	/* If we have a prefcodec setting, we have an inbound channel that set a 
	   preferred format for this call. Otherwise, we check the jointcapability
	   We also check for vrtp. If it's not there, we are not allowed do any video anyway.
	 */
	if (dialog->vrtp) {
		if (dialog->prefcodec)
			needvideo = dialog->prefcodec & AST_FORMAT_VIDEO_MASK;	/* Outbound call */
 		else
			needvideo = dialog->jointcapability & AST_FORMAT_VIDEO_MASK;	/* Inbound call */
	}

	if (option_debug > 2) {
		if (needvideo) 
			ast_log(LOG_DEBUG, "This channel can handle video! HOLLYWOOD next!\n");
		else
			ast_log(LOG_DEBUG, "This channel will not be able to handle video.\n");
	}

	if (ast_test_flag(&dialog->flags[0], SIP_DTMF) ==  SIP_DTMF_INBAND) {
		dialog->vad = ast_dsp_new();
		ast_dsp_set_features(dialog->vad, DSP_FEATURE_DTMF_DETECT);
		if (global.relaxdtmf)
			ast_dsp_digitmode(dialog->vad, DSP_DIGITMODE_DTMF | DSP_DIGITMODE_RELAXDTMF);
	}
	if (dialog->rtp) {
		tmp->fds[0] = ast_rtp_fd(dialog->rtp);
		tmp->fds[1] = ast_rtcp_fd(dialog->rtp);
	}
	if (needvideo && dialog->vrtp) {
		tmp->fds[2] = ast_rtp_fd(dialog->vrtp);
		tmp->fds[3] = ast_rtcp_fd(dialog->vrtp);
	}
	if (dialog->udptl) {
		tmp->fds[5] = ast_udptl_fd(dialog->udptl);
	}
	if (state == AST_STATE_RING)
		tmp->rings = 1;
	tmp->adsicpe = AST_ADSI_UNAVAILABLE;
	tmp->writeformat = fmt;
	tmp->rawwriteformat = fmt;
	tmp->readformat = fmt;
	tmp->rawreadformat = fmt;
	tmp->tech_pvt = dialog;

	tmp->callgroup = dialog->callgroup;
	tmp->pickupgroup = dialog->pickupgroup;
	tmp->cid.cid_pres = dialog->callingpres;
	if (!ast_strlen_zero(dialog->accountcode))
		ast_string_field_set(tmp, accountcode, dialog->accountcode);
	if (dialog->amaflags)
		tmp->amaflags = dialog->amaflags;
	if (!ast_strlen_zero(dialog->language))
		ast_string_field_set(tmp, language, dialog->language);
	dialog->owner = tmp;
	ast_copy_string(tmp->context, dialog->context, sizeof(tmp->context));
	ast_copy_string(tmp->exten, dialog->exten, sizeof(tmp->exten));

	/* Don't use ast_set_callerid() here because it will
	 * generate a NewCallerID event before the NewChannel event */
	tmp->cid.cid_num = ast_strdup(dialog->cid_num);
	tmp->cid.cid_ani = ast_strdup(dialog->cid_num);
	tmp->cid.cid_name = ast_strdup(dialog->cid_name);
	if (!ast_strlen_zero(dialog->rdnis))
		tmp->cid.cid_rdnis = ast_strdup(dialog->rdnis);
	
	if (!ast_strlen_zero(dialog->exten) && strcmp(dialog->exten, "s"))
		tmp->cid.cid_dnid = ast_strdup(dialog->exten);

	tmp->priority = 1;
	if (!ast_strlen_zero(dialog->uri))
		pbx_builtin_setvar_helper(tmp, "SIPURI", dialog->uri);
	if (!ast_strlen_zero(dialog->domain))
		pbx_builtin_setvar_helper(tmp, "SIPDOMAIN", dialog->domain);
	if (!ast_strlen_zero(dialog->callid))
		pbx_builtin_setvar_helper(tmp, "SIPCALLID", dialog->callid);
	if (dialog->rtp)
		ast_jb_configure(tmp, &global.jbconf);
	if (state != AST_STATE_DOWN && ast_pbx_start(tmp)) {
		ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
		tmp->hangupcause = AST_CAUSE_SWITCH_CONGESTION;
		ast_hangup(tmp);
		tmp = NULL;
	}
	/* Set channel variables for this call from configuration */
	for (v = dialog->chanvars ; v ; v = v->next)
		pbx_builtin_setvar_helper(tmp,v->name,v->value);

	if (!ast_test_flag(&dialog->flags[0], SIP_NO_HISTORY))
		append_history(dialog, "NewChan", "Channel %s - from %s", tmp->name, dialog->callid);

	return tmp;
}

/*! \brief Parse a SIP message 
	\note this function is used both on incoming and outgoing packets
*/
GNURK void parse_request(struct sip_request *req)
{
	char *c = req->data, **dst = req->header;
	int i = 0, lim = SIP_MAX_HEADERS - 1;
	int seqno = 0;

	req->header[0] = c;
	req->headers = -1;	/* mark that we are working on the header */
	for (; *c; c++) {
		if (*c == '\r')		/* remove \r */
			*c = '\0';
		else if (*c == '\n') { /* end of this line */
			*c = '\0';
			if (sipdebug && option_debug > 3)
				ast_log(LOG_DEBUG, "%7s %2d [%3d]: %s\n",
					req->headers < 0 ? "Header" : "Body",
					i, (int)strlen(dst[i]), dst[i]);
			if (ast_strlen_zero(dst[i]) && req->headers < 0) {
				req->headers = i;	/* record number of header lines */
				dst = req->line;	/* start working on the body */
				i = 0;
				lim = SIP_MAX_LINES - 1;
			} else {	/* move to next line, check for overflows */
				if (i++ >= lim)
					break;
			}
			dst[i] = c + 1; /* record start of next line */
		}
        }
	/* update count of header or body lines */
	if (req->headers >= 0)	/* we are in the body */
		req->lines = i;
	else {			/* no body */
		req->headers = i;
		req->lines = 0;
		req->line[0] = "";
	}

	if (*c)
		ast_log(LOG_WARNING, "Too many lines, skipping <%s>\n", c);
	/* Split up the first line parts */
	determine_firstline_parts(req);
	/* Determine the seqno of this request once and for all */

	req->callid = get_header(req, "Call-ID");
	req->from = get_header(req, "From");
	req->to = get_header(req, "To");
	req->via = get_header(req, "Via");	/* Get the first via header only */
	req->cseqheader = get_header(req, "CSeq");  
	/* Seqno can be zero, but anyway... */
	if (!req->seqno && sscanf(req->cseqheader, "%d ", &seqno) != 1)
		req->seqno = seqno;
}

/*! \brief Add header to SIP message */
GNURK int add_header(struct sip_request *req, const char *var, const char *value)
{
	int maxlen = sizeof(req->data) - 4 - req->len; /* 4 bytes are for two \r\n ? */

	if (req->headers == SIP_MAX_HEADERS) {
		ast_log(LOG_WARNING, "Out of SIP header space\n");
		return -1;
	}

	if (req->lines) {
		ast_log(LOG_WARNING, "Can't add more headers when lines have been added\n");
		return -1;
	}

	if (maxlen <= 0) {
		ast_log(LOG_WARNING, "Out of space, can't add anymore (%s:%s)\n", var, value);
		return -1;
	}

	req->header[req->headers] = req->data + req->len;

	if (global.compactheaders)
		var = find_alias(var, var);

	snprintf(req->header[req->headers], maxlen, "%s: %s\r\n", var, value);
	req->len += strlen(req->header[req->headers]);
	req->headers++;
	if (req->headers < SIP_MAX_HEADERS)
		req->headers++;
	else
		ast_log(LOG_WARNING, "Out of SIP header space... Will generate broken SIP message\n");

	return 0;	
}

/*! \brief Initialize SIP response, based on SIP request */
GNURK int init_resp(struct sip_request *resp, const char *msg)
{
	/* Initialize a response */
	memset(resp, 0, sizeof(*resp));
	resp->method = SIP_RESPONSE;
	resp->header[0] = resp->data;
	snprintf(resp->header[0], sizeof(resp->data), "SIP/2.0 %s\r\n", msg);
	resp->len = strlen(resp->header[0]);
	resp->headers++;
	return 0;
}

/*! \brief Initialize SIP request */
GNURK int init_req(struct sip_request *req, int sipmethod, const char *recip)
{
	/* Initialize a request */
	memset(req, 0, sizeof(*req));
        req->method = sipmethod;
	req->header[0] = req->data;
	snprintf(req->header[0], sizeof(req->data), "%s %s SIP/2.0\r\n", sip_method2txt(sipmethod), recip);
	req->len = strlen(req->header[0]);
	req->headers++;
	return 0;
}

/*! \brief Base transmit response function */
GNURK int __transmit_response(struct sip_dialog *p, const char *msg, const struct sip_request *req, enum xmittype reliable)
{
	struct sip_request resp;
	int seqno = 0;

	if (reliable && (sscanf(get_header(req, "CSeq"), "%d ", &seqno) != 1)) {
		ast_log(LOG_WARNING, "Unable to determine sequence number from '%s'\n", get_header(req, "CSeq"));
		return -1;
	}
	resp.seqno = seqno;
	respprep(&resp, p, msg, req);
	add_header_contentLength(&resp, 0);
	/* If we are cancelling an incoming invite for some reason, add information
		about the reason why we are doing this in clear text */
	if (p->method == SIP_INVITE && msg[0] != '1' && p->owner && p->owner->hangupcause) {
		char buf[10];

		add_header(&resp, "X-Asterisk-HangupCause", ast_cause2str(p->owner->hangupcause));
		snprintf(buf, sizeof(buf), "%d", p->owner->hangupcause);
		add_header(&resp, "X-Asterisk-HangupCauseCode", buf);
	}
	return send_response(p, &resp, reliable, seqno);
}

/*! \brief Transmit response, no retransmits */
GNURK int transmit_response(struct sip_dialog *p, const char *msg, const struct sip_request *req) 
{
	return __transmit_response(p, msg, req, XMIT_UNRELIABLE);
}


/*! \brief Transmit response, Make sure you get an ACK
	This is only used for responses to INVITEs, where we need to make sure we get an ACK
*/
static int transmit_response_reliable(struct sip_dialog *p, const char *msg, const struct sip_request *req)
{
	return __transmit_response(p, msg, req, XMIT_CRITICAL);
}

/* Forward declaration */
static int add_t38_sdp(struct sip_request *resp, struct sip_dialog *p);

/*! \brief Transmit responses with various attachments */
static int transmit_response_with_attachment(enum responseattach attach, struct sip_dialog *p, const char *msg, 
		const struct sip_request *req, enum xmittype reliable)
{
	struct sip_request resp;
	char buf[12];

	respprep(&resp, p, msg, req);
	append_date(&resp);
	switch (attach) {
	case WITH_DATE:
		add_header_contentLength(&resp, 0);
		break;
	case WITH_MINEXPIRY:
		snprintf(buf, sizeof(buf), "%d", expiry.min_expiry);
		add_header(&resp, "Min-Expires", buf);
		break;
	case WITH_ALLOW:
		add_header(&resp, "Accept", "application/sdp");
		add_header_contentLength(&resp, 0);
		break;
	case WITH_SDP:
		if (p->rtp) {
			if (!p->autoframing && !ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
				if (option_debug)
					ast_log(LOG_DEBUG, "Setting framing from config on incoming call\n");
				ast_rtp_codec_setpref(p->rtp, &p->prefs);
			}
			try_suggested_sip_codec(p);	
			add_sdp(&resp, p);
		} else 
			ast_log(LOG_ERROR, "Can't add SDP to response, since we have no RTP session allocated. Call-ID %s\n", p->callid);
		break;
	case WITH_T38_SDP:
		if (p->udptl) {
			ast_udptl_offered_from_local(p->udptl, 0);
			add_t38_sdp(&resp, p);
		} else 
			ast_log(LOG_ERROR, "Can't add T38 SDP to response, since we have no UDPTL session allocated. Call-ID %s\n", p->callid);
		break;
	}
	return send_response(p, &resp, reliable, 0);
}

/*! \brief Transmit response, no retransmits */
static int transmit_response_with_unsupported(struct sip_dialog *p, const char *msg, const struct sip_request *req, const char *unsupported) 
{
	struct sip_request resp;

	respprep(&resp, p, msg, req);
	append_date(&resp);
	add_header(&resp, "Unsupported", unsupported);
	return send_response(p, &resp, XMIT_UNRELIABLE, 0);
}

/*! \brief Respond with authorization request */
GNURK int transmit_response_with_auth(struct sip_dialog *p, const char *msg, const struct sip_request *req, const char *randdata, enum xmittype reliable, const char *header, int stale)
{
	struct sip_request resp;
	char tmp[512];
	int seqno = 0;

	if (reliable && (sscanf(get_header(req, "CSeq"), "%d ", &seqno) != 1)) {
		ast_log(LOG_WARNING, "Unable to determine sequence number from '%s'\n", get_header(req, "CSeq"));
		return -1;
	}
	/* Stale means that they sent us correct authentication, but 
	   based it on an old challenge (nonce) */
	snprintf(tmp, sizeof(tmp), "Digest algorithm=MD5, realm=\"%s\", nonce=\"%s\"%s", global.realm, randdata, stale ? ", stale=true" : "");
	respprep(&resp, p, msg, req);
	add_header(&resp, header, tmp);
	add_header_contentLength(&resp, 0);
	return send_response(p, &resp, reliable, seqno);
}

/*! \brief add XML encoded media control with update 
	\note XML: The only way to turn 0 bits of information into a few hundred. (markster) */
static int add_vidupdate(struct sip_request *req)
{
	const char *xml_is_a_huge_waste_of_space =
		"<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n"
		" <media_control>\r\n"
		"  <vc_primitive>\r\n"
		"   <to_encoder>\r\n"
		"    <picture_fast_update>\r\n"
		"    </picture_fast_update>\r\n"
		"   </to_encoder>\r\n"
		"  </vc_primitive>\r\n"
		" </media_control>\r\n";
	add_header(req, "Content-Type", "application/media_control+xml");
	add_header_contentLength(req, strlen(xml_is_a_huge_waste_of_space));
	add_line(req, xml_is_a_huge_waste_of_space);
	return 0;
}

/*! \brief Get Max T.38 Transmission rate from T38 capabilities */
static int t38_get_rate(int t38cap)
{
	int maxrate = (t38cap & (T38FAX_RATE_14400 | T38FAX_RATE_12000 | T38FAX_RATE_9600 | T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400));
	
	if (maxrate & T38FAX_RATE_14400) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 14400 found\n");
		return 14400;
	} else if (maxrate & T38FAX_RATE_12000) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 12000 found\n");
		return 12000;
	} else if (maxrate & T38FAX_RATE_9600) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 9600 found\n");
		return 9600;
	} else if (maxrate & T38FAX_RATE_7200) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 7200 found\n");
		return 7200;
	} else if (maxrate & T38FAX_RATE_4800) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 4800 found\n");
		return 4800;
	} else if (maxrate & T38FAX_RATE_2400) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 2400 found\n");
		return 2400;
	} else {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "Strange, T38MaxFaxRate NOT found in peers T38 SDP.\n");
		return 0;
	}
}

/*! \brief Add T.38 Session Description Protocol message */
static int add_t38_sdp(struct sip_request *resp, struct sip_dialog *p)
{
	int len = 0;
	int x = 0;
	struct sockaddr_in udptlsin;
	char v[256] = "";
	char s[256] = "";
	char o[256] = "";
	char c[256] = "";
	char t[256] = "";
	char m_modem[256];
	char a_modem[1024];
	char *m_modem_next = m_modem;
	size_t m_modem_left = sizeof(m_modem);
	char *a_modem_next = a_modem;
	size_t a_modem_left = sizeof(a_modem);
	struct sockaddr_in udptldest = { 0, };
	int debug;
	
	debug = sip_debug_test_pvt(p);
	len = 0;
	if (!p->udptl) {
		ast_log(LOG_WARNING, "No way to add SDP without an UDPTL structure\n");
		return -1;
	}
	
	if (!p->sessionid) {
		p->sessionid = getpid();
		p->sessionversion = p->sessionid;
	} else
		p->sessionversion++;
	
	/* Our T.38 end is */
	ast_udptl_get_us(p->udptl, &udptlsin);
	
	/* Determine T.38 UDPTL destination */
	if (p->udptlredirip.sin_addr.s_addr) {
		udptldest.sin_port = p->udptlredirip.sin_port;
		udptldest.sin_addr = p->udptlredirip.sin_addr;
	} else {
		udptldest.sin_addr = p->ourip;
		udptldest.sin_port = udptlsin.sin_port;
	}
	
	if (debug) 
		ast_log(LOG_DEBUG, "T.38 UDPTL is at %s port %d\n", ast_inet_ntoa(p->ourip), ntohs(udptlsin.sin_port));
	
	/* We break with the "recommendation" and send our IP, in order that our
	   peer doesn't have to ast_gethostbyname() us */
	
	if (debug) {
		ast_log(LOG_DEBUG, "Our T38 capability (%d), peer T38 capability (%d), joint capability (%d)\n",
			p->t38.capability,
			p->t38.peercapability,
			p->t38.jointcapability);
	}
	snprintf(v, sizeof(v), "v=0\r\n");
	snprintf(o, sizeof(o), "o=root %d %d IN IP4 %s\r\n", p->sessionid, p->sessionversion, ast_inet_ntoa(udptldest.sin_addr));
	snprintf(s, sizeof(s), "s=session\r\n");
	snprintf(c, sizeof(c), "c=IN IP4 %s\r\n", ast_inet_ntoa(udptldest.sin_addr));
	snprintf(t, sizeof(t), "t=0 0\r\n");
	ast_build_string(&m_modem_next, &m_modem_left, "m=image %d udptl t38\r\n", ntohs(udptldest.sin_port));
	
	if ((p->t38.jointcapability & T38FAX_VERSION) == T38FAX_VERSION_0)
		ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxVersion:0\r\n");
	if ((p->t38.jointcapability & T38FAX_VERSION) == T38FAX_VERSION_1)
		ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxVersion:1\r\n");
	if ((x = t38_get_rate(p->t38.jointcapability)))
		ast_build_string(&a_modem_next, &a_modem_left, "a=T38MaxBitRate:%d\r\n",x);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxFillBitRemoval:%d\r\n", (p->t38.jointcapability & T38FAX_FILL_BIT_REMOVAL) ? 1 : 0);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxTranscodingMMR:%d\r\n", (p->t38.jointcapability & T38FAX_TRANSCODING_MMR) ? 1 : 0);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxTranscodingJBIG:%d\r\n", (p->t38.jointcapability & T38FAX_TRANSCODING_JBIG) ? 1 : 0);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxRateManagement:%s\r\n", (p->t38.jointcapability & T38FAX_RATE_MANAGEMENT_LOCAL_TCF) ? "localTCF" : "transferredTCF");
	x = ast_udptl_get_local_max_datagram(p->udptl);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxMaxBuffer:%d\r\n",x);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxMaxDatagram:%d\r\n",x);
	if (p->t38.jointcapability != T38FAX_UDP_EC_NONE)
		ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxUdpEC:%s\r\n", (p->t38.jointcapability & T38FAX_UDP_EC_REDUNDANCY) ? "t38UDPRedundancy" : "t38UDPFEC");
	if (p->udptl)
		len = strlen(m_modem) + strlen(a_modem);
	add_header(resp, "Content-Type", "application/sdp");
	add_header_contentLength(resp, len);
	add_line(resp, v);
	add_line(resp, o);
	add_line(resp, s);
	add_line(resp, c);
	add_line(resp, t);
	add_line(resp, m_modem);
	add_line(resp, a_modem);
	
	/* Update lastrtprx when we send our SDP */
	p->lastrtprx = p->lastrtptx = time(NULL);
	
	return 0;
}

/*! \brief Transmit reinvite with SDP
\note 	A re-invite is basically a new INVITE with the same CALL-ID and TAG as the
	INVITE that opened the SIP dialogue 
	We reinvite so that the audio stream (RTP) go directly between
	the SIP UAs. SIP Signalling stays with * in the path.
	IF type == 1, we send T.38 SDP 
*/
GNURK int transmit_reinvite_with_sdp(struct sip_dialog *p, int t38type)
{
	struct sip_request req;

	reqprep(&req, p, ast_test_flag(&p->flags[0], SIP_REINVITE_UPDATE) ?  SIP_UPDATE : SIP_INVITE, 0, 1);
	
	add_header(&req, "Allow", ALLOWED_METHODS);
	add_header(&req, "Supported", SUPPORTED_EXTENSIONS);
	if (sipdebug)
		add_header(&req, "X-asterisk-Info",(t38type ? "SIP re-invite for T38 fax" : "SIP re-invite (External RTP bridge)"));
	if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY))
		append_history(p, "ReInv", "%s", (t38type ? "Re-invite sent for T38" : "Re-invite sent for external RTP media"));
	if (t38type)
		add_t38_sdp(&req, p);
	else
		add_sdp(&req, p);

	/* Use this as the basis */
	initialize_initreq(p, &req);
	p->lastinvite = p->ocseq;
	return send_request(p, &req, XMIT_CRITICAL, p->ocseq);
}

/*! \brief Build REFER/INVITE/OPTIONS message and transmit it */
GNURK int transmit_invite(struct sip_dialog *p, int sipmethod, int sdp, int init)
{
	struct sip_request req;
	
	req.method = sipmethod;
	if (init)
		/* Bump branch even on initial requests */
		build_via(p, TRUE);

	if (init == 2) /* open a new dialog */
		initreqprep(&req, p, sipmethod);
	else
		reqprep(&req, p, sipmethod, 0, TRUE);
		
	if (p->options && p->options->auth)
		add_header(&req, p->options->authheader, p->options->auth);
	append_date(&req);
	if (sipmethod == SIP_REFER && p->refer) { /* Call transfer */
		char buf[BUFSIZ];
		if (!ast_strlen_zero(p->refer->refer_to))
			add_header(&req, "Refer-To", p->refer->refer_to);
		if (!ast_strlen_zero(p->refer->referred_by)) {
			sprintf(buf, "%s <%s>", p->refer->referred_by_name, p->refer->referred_by);
			add_header(&req, "Referred-By", buf);
		}
	}

	if (p->options && p->options->replaces && !ast_strlen_zero(p->options->replaces)) {
		/* This new INVITE is part of an attended transfer. Make sure that the
	 	   other end knows and replace the current call with this new call */
		add_header(&req, "Replaces", p->options->replaces);
		add_header(&req, "Require", "replaces");
	}

	add_header(&req, "Allow", ALLOWED_METHODS);
	add_header(&req, "Supported", SUPPORTED_EXTENSIONS);
	if (p->options && p->options->addsipheaders) {
		struct ast_channel *ast;
		struct varshead *headp = NULL;
		const struct ast_var_t *current;

		ast = p->owner;	/* The owner channel */
		if (ast) {
			char *headdup;
	 		headp = &ast->varshead;
			if (!headp)
				ast_log(LOG_WARNING,"No varshead for the channel...ooops!\n");
			else {
				AST_LIST_TRAVERSE(headp, current, entries) {  
					/* SIPADDHEADER: Add SIP header to outgoing call */
					if (!strncasecmp(ast_var_name(current), "SIPADDHEADER", strlen("SIPADDHEADER"))) {
						char *content, *end;
						const char *header = ast_var_value(current);

						headdup = ast_strdupa(header);
						/* Strip of the starting " (if it's there) */
						if (*headdup == '"')
					 		headdup++;
						if ((content = strchr(headdup, ':'))) {
							*content++ = '\0';
							content = ast_skip_blanks(content); /* Skip white space */
							/* Strip the ending " (if it's there) */
					 		end = content + strlen(content) -1;	
							if (*end == '"')
								*end = '\0';
						
							add_header(&req, headdup, content);
							if (sipdebug)
								ast_log(LOG_DEBUG, "Adding SIP Header \"%s\" with content :%s: \n", headdup, content);
						}
					}
				}
			}
		}
	}
	if (sdp) {
		if (p->udptl && p->t38.state == T38_LOCAL_DIRECT) {
			ast_udptl_offered_from_local(p->udptl, 1);
			if (option_debug)
				ast_log(LOG_DEBUG, "T38 is in state %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
			add_t38_sdp(&req, p);
		} else if (p->rtp) 
			add_sdp(&req, p);
	} else {
		add_header_contentLength(&req, 0);
	}

	if (!p->initreq.headers)
		initialize_initreq(p, &req);
	p->lastinvite = p->ocseq;
	return send_request(p, &req, init ? XMIT_CRITICAL : XMIT_RELIABLE, p->ocseq);
}

/*! \brief Notify user of messages waiting in voicemail
\note	- Notification only works for registered peers with mailbox= definitions
	in sip.conf
	- We use the SIP Event package message-summary
	 MIME type defaults to  "application/simple-message-summary";
 */
static int transmit_notify_with_mwi(struct sip_dialog *p, int newmsgs, int oldmsgs, char *vmexten)
{
	struct sip_request req;
	char tmp[500];
	char *t = tmp;
	size_t maxbytes = sizeof(tmp);

	initreqprep(&req, p, SIP_NOTIFY);
	add_header(&req, "Event", "message-summary");
	add_header(&req, "Content-Type", global.default_notifymime);

	ast_build_string(&t, &maxbytes, "Messages-Waiting: %s\r\n", newmsgs ? "yes" : "no");
	ast_build_string(&t, &maxbytes, "Message-Account: sip:%s@%s\r\n",
		S_OR(vmexten, global.default_vmexten), S_OR(p->fromdomain, ast_inet_ntoa(p->ourip)));
	ast_build_string(&t, &maxbytes, "Voice-Message: %d/%d (0/0)\r\n", newmsgs, oldmsgs);
	if (p->subscribed) {
		if (p->expiry)
			add_header(&req, "Subscription-State", "active");
		else	/* Expired */
			add_header(&req, "Subscription-State", "terminated;reason=timeout");
	}

	if (t > tmp + sizeof(tmp))
		ast_log(LOG_WARNING, "Buffer overflow detected!!  (Please file a bug report)\n");

	add_header_contentLength(&req, strlen(tmp));
	add_line(&req, tmp);

	if (!p->initreq.headers) 
		initialize_initreq(p, &req);
	return send_request(p, &req, XMIT_RELIABLE, p->ocseq);
}

/*! \brief Transmit SIP request unreliably (only used in sip_notify subsystem) */
static int transmit_sip_request(struct sip_dialog *p, struct sip_request *req)
{
	if (!p->initreq.headers) 	/* Initialize first request before sending */
		initialize_initreq(p, req);
	return send_request(p, req, XMIT_UNRELIABLE, p->ocseq);
}

/*! \brief Transmit text with SIP MESSAGE method */
static int transmit_message_with_text(struct sip_dialog *p, const char *text)
{
	struct sip_request req;

	reqprep(&req, p, SIP_MESSAGE, 0, TRUE);
	add_text(&req, text);
	return send_request(p, &req, XMIT_RELIABLE, p->ocseq);
}

/*! \brief Transmit SIP REFER message (initiated by the transfer() dialplan application
	\note this is currently broken as we have no way of telling the dialplan
	engine whether a transfer succeeds or fails.
	\todo Fix the transfer() dialplan function so that a transfer may fail
*/
static int transmit_refer(struct sip_dialog *p, const char *dest)
{
	struct sip_request req = { 
		.headers = 0,	
	};
	char from[256];
	const char *of;
	char *c;
	char referto[256];
	char *ttag, *ftag;
	char *theirtag = ast_strdupa(p->theirtag);

	if (option_debug || sipdebug)
		ast_log(LOG_DEBUG, "SIP transfer of %s to %s\n", p->callid, dest);

	/* Are we transfering an inbound or outbound call ? */
	if (ast_test_flag(&p->flags[0], SIP_OUTGOING))  {
		of = get_header(&p->initreq, "To");
		ttag = theirtag;
		ftag = p->tag;
	} else {
		of = get_header(&p->initreq, "From");
		ftag = theirtag;
		ttag = p->tag;
	}

	ast_copy_string(from, of, sizeof(from));
	of = get_in_brackets(from);
	ast_string_field_set(p, from, of);
	if (strncmp(of, "sip:", 4))
		ast_log(LOG_NOTICE, "From address missing 'sip:', using it anyway\n");
	else
		of += 4;
	/* Get just the username part */
	if ((c = strchr(dest, '@')))
		c = NULL;
	else if ((c = strchr(of, '@')))
		*c++ = '\0';
	if (c) 
		snprintf(referto, sizeof(referto), "<sip:%s@%s>", dest, c);
	else
		snprintf(referto, sizeof(referto), "<sip:%s>", dest);

	/* save in case we get 407 challenge */
	sip_refer_allocate(p);
	ast_copy_string(p->refer->refer_to, referto, sizeof(p->refer->refer_to));
	ast_copy_string(p->refer->referred_by, p->our_contact, sizeof(p->refer->referred_by));
	p->refer->status = REFER_SENT;   /* Set refer status */

	reqprep(&req, p, SIP_REFER, 0, TRUE);
	add_header(&req, "Max-Forwards", DEFAULT_MAX_FORWARDS);

	add_header(&req, "Refer-To", referto);
	add_header(&req, "Allow", ALLOWED_METHODS);
	add_header(&req, "Supported", SUPPORTED_EXTENSIONS);
	if (!ast_strlen_zero(p->our_contact))
		add_header(&req, "Referred-By", p->our_contact);

	return send_request(p, &req, XMIT_RELIABLE, p->ocseq);
	/* We should propably wait for a NOTIFY here until we ack the transfer */
	/* Maybe fork a new thread and wait for a STATUS of REFER_200OK on the refer status before returning to app_transfer */

	/*! \todo In theory, we should hang around and wait for a reply, before
	returning to the dial plan here. Don't know really how that would
	affect the transfer() app or the pbx, but, well, to make this
	useful we should have a STATUS code on transfer().
	*/
}


/*! \brief Send SIP INFO dtmf message, see Cisco documentation on cisco.com */
static int transmit_info_with_digit(struct sip_dialog *p, const char digit)
{
	struct sip_request req;

	reqprep(&req, p, SIP_INFO, 0, TRUE);
	add_digit(&req, digit);
	return send_request(p, &req, XMIT_RELIABLE, p->ocseq);
}

/*! \brief Send SIP INFO with video update request */
static int transmit_info_with_vidupdate(struct sip_dialog *p)
{
	struct sip_request req;

	reqprep(&req, p, SIP_INFO, 0, TRUE);
	add_vidupdate(&req);
	return send_request(p, &req, XMIT_RELIABLE, p->ocseq);
}

/*! \brief Transmit generic SIP request */
static int transmit_request(struct sip_dialog *p, int sipmethod, int seqno, enum xmittype reliable, int newbranch)
{
	struct sip_request resp;

	reqprep(&resp, p, sipmethod, seqno, newbranch);
	add_header_contentLength(&resp, 0);
	return send_request(p, &resp, reliable, seqno ? seqno : p->ocseq);
}

/*! \brief Transmit SIP request, auth added */
GNURK int transmit_request_with_auth(struct sip_dialog *p, int sipmethod, int seqno, enum xmittype reliable, int newbranch)
{
	struct sip_request resp;

	reqprep(&resp, p, sipmethod, seqno, newbranch);
	if (!ast_strlen_zero(p->realm)) {
		char digest[1024];

		memset(digest, 0, sizeof(digest));
		if(!build_reply_digest(p, sipmethod, digest, sizeof(digest))) {
			char *dummy, *response;
			enum sip_auth_type code = p->options ? p->options->auth_type : PROXY_AUTH; /* XXX force 407 if unknown */
			auth_headers(code, &dummy, &response);
			add_header(&resp, response, digest);
		} else
			ast_log(LOG_WARNING, "No authentication available for call %s\n", p->callid);
	}
	/* If we are hanging up and know a cause for that, send it in clear text to make
		debugging easier. */
	if (sipmethod == SIP_BYE && p->owner && p->owner->hangupcause)	{
		char buf[10];

		add_header(&resp, "X-Asterisk-HangupCause", ast_cause2str(p->owner->hangupcause));
		snprintf(buf, sizeof(buf), "%d", p->owner->hangupcause);
		add_header(&resp, "X-Asterisk-HangupCauseCode", buf);
	}

	add_header_contentLength(&resp, 0);
	return send_request(p, &resp, reliable, seqno ? seqno : p->ocseq);	
}

/*! \brief Remove registration data from realtime database or AST/DB when registration expires */
GNURK void destroy_association(struct sip_peer *peer)
{
	if (!ast_test_flag(&global.flags[1], SIP_PAGE2_IGNOREREGEXPIRE)) {
		if (ast_test_flag(&peer->flags[1], SIP_PAGE2_RT_FROMCONTACT))
			ast_update_realtime("sippeers", "name", peer->name, "fullcontact", "", "ipaddr", "", "port", "", "regseconds", "0", "defaultuser", "", "regserver", "", NULL);
		else 
			ast_db_del("SIP/Registry", peer->name);
	}
}

/*! \brief Expire registration of SIP peer */
GNURK int expire_register(void *data)
{
	struct sip_peer *peer = data;
	
	if (!peer)		/* Hmmm. We have no peer. Weird. */
		return 0;

	memset(&peer->addr, 0, sizeof(peer->addr));

	destroy_association(peer);	/* remove registration data from storage */
	
	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Unregistered\r\nCause: Expired\r\n", peer->name);
	register_peer_exten(peer, FALSE);	/* Remove regexten */
	peer->expire = -1;
	ast_device_state_changed("SIP/%s", peer->name);

	/* Do we need to release this peer from memory? 
		Only for realtime peers and autocreated peers
	*/
	if (ast_test_flag(&peer->flags[1], SIP_PAGE2_SELFDESTRUCT) ||
	    ast_test_flag(&peer->flags[1], SIP_PAGE2_RTAUTOCLEAR)) {
		peer = ASTOBJ_CONTAINER_UNLINK(&devicelist, peer);	/* Remove from peer list */
		ASTOBJ_UNREF(peer, sip_destroy_device);		/* Remove from memory */
	}

	return 0;
}

/*! \brief Get registration details from Asterisk DB */
GNURK void reg_source_db(struct sip_peer *peer)
{
	char data[256];
	struct in_addr in;
	int expiry;
	int port;
	char *scan, *addr, *port_str, *expiry_str, *username, *contact;

	if (ast_test_flag(&peer->flags[1], SIP_PAGE2_RT_FROMCONTACT)) 
		return;
	if (ast_db_get("SIP/Registry", peer->name, data, sizeof(data)))
		return;

	scan = data;
	addr = strsep(&scan, ":");
	port_str = strsep(&scan, ":");
	expiry_str = strsep(&scan, ":");
	username = strsep(&scan, ":");
	contact = scan;	/* Contact include sip: and has to be the last part of the database entry as long as we use : as a separator */

	if (!inet_aton(addr, &in))
		return;

	if (port_str)
		port = atoi(port_str);
	else
		return;

	if (expiry_str)
		expiry = atoi(expiry_str);
	else
		return;

	if (username)
		ast_copy_string(peer->defaultuser, username, sizeof(peer->defaultuser));
	if (contact)
		ast_copy_string(peer->fullcontact, contact, sizeof(peer->fullcontact));

	if (option_verbose > 2)
		ast_verbose(VERBOSE_PREFIX_3 "SIP Seeding peer from astdb: '%s' at %s@%s:%d for %d\n",
			    peer->name, peer->defaultuser, ast_inet_ntoa(in), port, expiry);

	memset(&peer->addr, 0, sizeof(peer->addr));
	peer->addr.sin_family = AF_INET;
	peer->addr.sin_addr = in;
	peer->addr.sin_port = htons(port);
	if (sipsocket_initialized()) {
		/* SIP isn't up yet, so schedule a poke only, pretty soon */
		if (peer->pokeexpire > -1)
			ast_sched_del(sched, peer->pokeexpire);
		peer->pokeexpire = ast_sched_add(sched, ast_random() % 5000 + 1, sip_poke_peer_s, peer);
	} else
		sip_poke_peer(peer);
	if (peer->expire > -1)
		ast_sched_del(sched, peer->expire);
	peer->expire = ast_sched_add(sched, (expiry + 10) * 1000, expire_register, peer);
	register_peer_exten(peer, TRUE);
}

/*! \brief Save contact header for 200 OK on INVITE */
static int parse_ok_contact(struct sip_dialog *pvt, struct sip_request *req)
{
	char contact[250]; 
	char *c;

	/* Look for brackets */
	ast_copy_string(contact, get_header(req, "Contact"), sizeof(contact));
	c = get_in_brackets(contact);

	/* Save full contact to call pvt for later bye or re-invite */
	ast_string_field_set(pvt, fullcontact, c);

	/* Save URI for later ACKs, BYE or RE-invites */
	ast_string_field_set(pvt, okcontacturi, c);

	/*! \todo We should return false for URI:s we can't handle,
		like sips:, tel:, mailto:,ldap: etc */
	return TRUE;		
}

/*! \brief Change the other partys IP address based on given contact */
static int set_address_from_contact(struct sip_dialog *pvt)
{
	struct hostent *hp;
	struct ast_hostent ahp;
	int port;
	char *c, *host, *pt;
	char *contact;


	if (ast_test_flag(&pvt->flags[0], SIP_NAT_ROUTE)) {
		/* NAT: Don't trust the contact field.  Just use what they came to us
		   with. */
		pvt->sa = pvt->recv;
		return 0;
	}


	/* Work on a copy */
	contact = ast_strdupa(pvt->fullcontact);

	/* XXX this code is repeated all over */
	/* Make sure it's a SIP URL */
	if (strncasecmp(contact, "sip:", 4)) {
		ast_log(LOG_NOTICE, "'%s' is not a valid SIP contact (missing sip:) trying to use anyway\n", contact);
	} else
		contact += 4;

	/* Ditch arguments */
	/* XXX this code is replicated also shortly below */
	contact = strsep(&contact, ";");	/* trim ; and beyond */

	/* Grab host */
	host = strchr(contact, '@');
	if (!host) {	/* No username part */
		host = contact;
		c = NULL;
	} else {
		*host++ = '\0';
	}
	pt = strchr(host, ':');
	if (pt) {
		*pt++ = '\0';
		port = atoi(pt);
	} else
		port = STANDARD_SIP_PORT;

	/* XXX This could block for a long time XXX */
	/* We should only do this if it's a name, not an IP */
	hp = ast_gethostbyname(host, &ahp);
	if (!hp)  {
		ast_log(LOG_WARNING, "Invalid host name in Contact: (can't resolve in DNS) : '%s'\n", host);
		return -1;
	}
	pvt->sa.sin_family = AF_INET;
	memcpy(&pvt->sa.sin_addr, hp->h_addr, sizeof(pvt->sa.sin_addr));
	pvt->sa.sin_port = htons(port);

	return 0;
}


/*! \brief Parse contact header and save registration (peer registration) */
static enum parse_register_result parse_register_contact(struct sip_dialog *pvt, struct sip_peer *peer, struct sip_request *req)
{
	char contact[BUFSIZ]; 
	char data[BUFSIZ];
	const char *expires = get_header(req, "Expires");
	int localexpiry = atoi(expires);
	char *curi, *n, *pt;
	int port;
	const char *useragent;
	struct hostent *hp;
	struct ast_hostent ahp;
	struct sockaddr_in oldsin;

	ast_copy_string(contact, get_header(req, "Contact"), sizeof(contact));

	if (ast_strlen_zero(expires)) {	/* No expires header */
		expires = strcasestr(contact, ";expires=");
		if (expires) {
			/* XXX bug here, we overwrite the string */
			expires = strsep((char **) &expires, ";"); /* trim ; and beyond */
			if (sscanf(expires + 9, "%d", &localexpiry) != 1)
				localexpiry = expiry.default_expiry;
		} else {
			/* Nothing has been specified */
			localexpiry = expiry.default_expiry;
		}
	}
	if (localexpiry < expiry.min_expiry)
		return PARSE_REGISTER_FAILED_MINEXPIRY;

	/* Look for brackets */
	curi = contact;
	if (strchr(contact, '<') == NULL)	/* No <, check for ; and strip it */
		strsep(&curi, ";");	/* This is Header options, not URI options */
	curi = get_in_brackets(contact);

	/* if they did not specify Contact: or Expires:, they are querying
	   what we currently have stored as their contact address, so return
	   it
	*/
	if (ast_strlen_zero(curi) && ast_strlen_zero(expires)) {
		/* If we have an active registration, tell them when the registration is going to expire */
		if (peer->expire > -1 && !ast_strlen_zero(peer->fullcontact))
			pvt->expiry = ast_sched_when(sched, peer->expire);
		return PARSE_REGISTER_QUERY;
	} else if (!strcasecmp(curi, "*") || !localexpiry) {	/* Unregister this peer */
		/* This means remove all registrations and return OK */
		memset(&peer->addr, 0, sizeof(peer->addr));
		if (peer->expire > -1)
			ast_sched_del(sched, peer->expire);
		peer->expire = -1;

		destroy_association(peer);
		
		register_peer_exten(peer, 0);	/* Add extension from regexten= setting in sip.conf */
		peer->fullcontact[0] = '\0';
		peer->useragent[0] = '\0';
		peer->sipoptions = 0;
		peer->lastms = 0;

		if (option_verbose > 2)
			ast_verbose(VERBOSE_PREFIX_3 "Unregistered SIP '%s'\n", peer->name);
			manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Unregistered\r\n", peer->name);
		return PARSE_REGISTER_UPDATE;
	}

	/* Store whatever we got as a contact from the client */
	ast_copy_string(peer->fullcontact, curi, sizeof(peer->fullcontact));

	/* For the 200 OK, we should use the received contact */
	ast_string_field_build(pvt, our_contact, "<%s>", curi);

	/* Make sure it's a SIP URL */
	if (strncasecmp(curi, "sip:", 4)) {
		ast_log(LOG_NOTICE, "'%s' is not a valid SIP contact (missing sip:) trying to use anyway\n", curi);
	} else
		curi += 4;
	/* Ditch q */
	curi = strsep(&curi, ";");
	/* Grab host */
	n = strchr(curi, '@');
	if (!n) {
		n = curi;
		curi = NULL;
	} else
		*n++ = '\0';
	pt = strchr(n, ':');
	if (pt) {
		*pt++ = '\0';
		port = atoi(pt);
	} else
		port = STANDARD_SIP_PORT;
	oldsin = peer->addr;
	if (!ast_test_flag(&peer->flags[0], SIP_NAT_ROUTE)) {
		/* XXX This could block for a long time XXX */
		hp = ast_gethostbyname(n, &ahp);
		if (!hp)  {
			ast_log(LOG_WARNING, "Invalid host '%s'\n", n);
			return PARSE_REGISTER_FAILED;
		}
		peer->addr.sin_family = AF_INET;
		memcpy(&peer->addr.sin_addr, hp->h_addr, sizeof(peer->addr.sin_addr));
		peer->addr.sin_port = htons(port);
	} else {
		/* Don't trust the contact field.  Just use what they came to us
		   with */
		peer->addr = pvt->recv;
	}

	/* Save SIP options profile */
	peer->sipoptions = pvt->sipoptions;

	if (curi) {	/* Overwrite the default username from config at registration */
		ast_copy_string(peer->defaultuser, curi, sizeof(peer->defaultuser));
	} else
		peer->defaultuser[0] = '\0';

	if (peer->expire > -1)
		ast_sched_del(sched, peer->expire);
	if (localexpiry > expiry.max_expiry)
		localexpiry = expiry.max_expiry;
	//if (localexpiry < expiry.min_expiry)
		//localexpiry = expiry.min_expiry;
	peer->expire = ast_test_flag(&peer->flags[0], SIP_REALTIME) ? -1 :
		ast_sched_add(sched, (localexpiry + 10) * 1000, expire_register, peer);
	pvt->expiry = localexpiry;
	snprintf(data, sizeof(data), "%s:%d:%d:%s:%s", ast_inet_ntoa(peer->addr.sin_addr), ntohs(peer->addr.sin_port), localexpiry, peer->defaultuser, peer->fullcontact);
	if (!ast_test_flag(&peer->flags[1], SIP_PAGE2_RT_FROMCONTACT)) 
		ast_db_put("SIP/Registry", peer->name, data);
	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Registered\r\n", peer->name);

	/* Is this a new IP address for us? */
	if (inaddrcmp(&peer->addr, &oldsin)) {
		sip_poke_peer(peer);
		if (option_verbose > 2)
			ast_verbose(VERBOSE_PREFIX_3 "Registered SIP '%s' at %s port %d expires %d\n", peer->name, ast_inet_ntoa(peer->addr.sin_addr), ntohs(peer->addr.sin_port), localexpiry);
		register_peer_exten(peer, 1);
	}
	
	/* Save User agent */
	useragent = get_header(req, "User-Agent");
	if (strcasecmp(useragent, peer->useragent)) {	/* XXX copy if they are different ? */
		ast_copy_string(peer->useragent, useragent, sizeof(peer->useragent));
		if (option_verbose > 3)
			ast_verbose(VERBOSE_PREFIX_3 "Saved useragent \"%s\" for peer %s\n", peer->useragent, peer->name);  
	}
	return PARSE_REGISTER_UPDATE;
}

/*! \brief Remove route from route list */
void free_old_route(struct sip_route *route)
{
	struct sip_route *next;

	while (route) {
		next = route->next;
		free(route);
		route = next;
	}
}

/*! \brief List all routes - mostly for debugging */
static void list_route(struct sip_route *route)
{
	if (!route)
		ast_verbose("list_route: no route\n");
	else {
		for (;route; route = route->next)
			ast_verbose("list_route: hop: <%s>\n", route->hop);
	}
}

/*! \brief Build route list from Record-Route header */
static void build_route(struct sip_dialog *p, struct sip_request *req, int backwards)
{
	struct sip_route *thishop, *head, *tail;
	int start = 0;
	int len;
	const char *rr, *contact, *c;

	/* Once a persistant route is set, don't fool with it */
	if (p->route && p->route_persistant) {
		if (option_debug)
			ast_log(LOG_DEBUG, "build_route: Retaining previous route: <%s>\n", p->route->hop);
		return;
	}

	if (p->route) {
		free_old_route(p->route);
		p->route = NULL;
	}
	
	p->route_persistant = backwards;
	
	/* Build a tailq, then assign it to p->route when done.
	 * If backwards, we add entries from the head so they end up
	 * in reverse order. However, we do need to maintain a correct
	 * tail pointer because the contact is always at the end.
	 */
	head = NULL;
	tail = head;
	/* 1st we pass through all the hops in any Record-Route headers */
	for (;;) {
		/* Each Record-Route header */
		rr = __get_header(req, "Record-Route", &start);
		if (*rr == '\0')
			break;
		for (; (rr = strchr(rr, '<')) ; rr += len) { /* Each route entry */
			++rr;
			len = strcspn(rr, ">") + 1;
			/* Make a struct route */
			if ((thishop = ast_malloc(sizeof(*thishop) + len))) {
				/* ast_calloc is not needed because all fields are initialized in this block */
				ast_copy_string(thishop->hop, rr, len);
				if (option_debug > 1)
					ast_log(LOG_DEBUG, "build_route: Record-Route hop: <%s>\n", thishop->hop);
				/* Link in */
				if (backwards) {
					/* Link in at head so they end up in reverse order */
					thishop->next = head;
					head = thishop;
					/* If this was the first then it'll be the tail */
					if (!tail)
						tail = thishop;
				} else {
					thishop->next = NULL;
					/* Link in at the end */
					if (tail)
						tail->next = thishop;
					else
						head = thishop;
					tail = thishop;
				}
			}
		}
	}

	/* Only append the contact if we are dealing with a strict router */
	if (!head || (!ast_strlen_zero(head->hop) && strstr(head->hop,";lr") == NULL) ) {
		/* 2nd append the Contact: if there is one */
		/* Can be multiple Contact headers, comma separated values - we just take the first */
		contact = get_header(req, "Contact");
		if (!ast_strlen_zero(contact)) {
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "build_route: Contact hop: %s\n", contact);
			/* Look for <: delimited address */
			c = strchr(contact, '<');
			if (c) {
				/* Take to > */
				++c;
				len = strcspn(c, ">") + 1;
			} else {
				/* No <> - just take the lot */
				c = contact;
				len = strlen(contact) + 1;
			}
			if ((thishop = ast_malloc(sizeof(*thishop) + len))) {
				/* ast_calloc is not needed because all fields are initialized in this block */
				ast_copy_string(thishop->hop, c, len);
				thishop->next = NULL;
				/* Goes at the end */
				if (tail)
					tail->next = thishop;
				else
					head = thishop;
			}
		}
	}

	/* Store as new route */
	p->route = head;

	/* For debugging dump what we ended up with */
	if (sip_debug_test_pvt(p))
		list_route(p->route);
}

/*! \brief Change onhold state of a peer using a pvt structure */
GNURK void sip_peer_hold(struct sip_dialog *p, int hold)
{
	struct sip_peer *peer = find_device(p->peername, NULL, 1);

	if (!peer)
		return;

	/* If they put someone on hold, increment the value... otherwise decrement it */
	if (hold)
		peer->onHold++;
	else if (hold > 0)
		peer->onHold--;

	/* Request device state update */
	ast_device_state_changed("SIP/%s", peer->name);

	return;
}

/*! \brief Callback for the devicestate notification (SUBSCRIBE) support subsystem
\note	If you add an "hint" priority to the extension in the dial plan,
	you will get notifications on device state changes */
static int cb_extensionstate(char *context, char* exten, int state, void *data)
{
	struct sip_dialog *p = data;

	switch(state) {
	case AST_EXTENSION_DEACTIVATED:	/* Retry after a while */
	case AST_EXTENSION_REMOVED:	/* Extension is gone */
		if (p->autokillid > -1)
			sip_cancel_destroy(p);	/* Remove subscription expiry for renewals */
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);	/* Delete subscription in 32 secs */
		ast_verbose(VERBOSE_PREFIX_2 "Extension state: Watcher for hint %s %s. Notify User %s\n", exten, state == AST_EXTENSION_DEACTIVATED ? "deactivated" : "removed", p->peername);
		p->stateid = -1;
		p->subscribed = NONE;
		append_history(p, "Subscribestatus", "%s", state == AST_EXTENSION_REMOVED ? "HintRemoved" : "Deactivated");
		break;
	default:	/* Tell user */
		p->laststate = state;
		break;
	}
	transmit_state_notify(p, state, 1, FALSE);

	if (option_verbose > 1)
		ast_verbose(VERBOSE_PREFIX_1 "Extension Changed %s new state %s for Notify User %s\n", exten, ast_extension_state2str(state), p->peername);
	return 0;
}

/*! \brief Send a fake 401 Unauthorized response when the administrator
  wants to hide the names of local users/peers from fishers
 */
static void transmit_fake_auth_response(struct sip_dialog *p, struct sip_request *req, int reliable)
{
	ast_string_field_build(p, randdata, "%08lx", ast_random());	/* Create nonce for challenge */
	transmit_response_with_auth(p, "401 Unauthorized", req, p->randdata, reliable, "WWW-Authenticate", 0);
}

/*!
 * Terminate the uri at the first ';' or space.
 * Technically we should ignore escaped space per RFC3261 (19.1.1 etc)
 * but don't do it for the time being. Remember the uri format is:
 *
 *	sip:user:password@host:port;uri-parameters?headers
 *	sips:user:password@host:port;uri-parameters?headers
 *
 */
static char *terminate_uri(char *uri)
{
	char *t = uri;
	while (*t && *t > ' ' && *t != ';')
		t++;
	*t = '\0';
	return uri;
}

/*! \brief Verify registration of user 
	- Registration is done in several steps, first a REGISTER without auth
	  to get a challenge (nonce) then a second one with auth
	- Registration requests are only matched with peers that are marked as "dynamic"
 */
static enum check_auth_result register_verify(struct sip_dialog *p, struct sockaddr_in *sin,
					      struct sip_request *req, char *uri)
{
	enum check_auth_result res = AUTH_NOT_FOUND;
	struct sip_peer *peer;
	char tmp[256];
	char *name, *c;
	char *domain;

	terminate_uri(uri);	/* warning, overwrite the string */

	ast_copy_string(tmp, get_header(req, "To"), sizeof(tmp));
	ast_uri_decode(tmp);

	c = get_in_brackets(tmp);
	c = strsep(&c, ";");	/* Ditch ;user=phone */

	if (!strncmp(c, "sip:", 4)) {
		name = c + 4;
	} else {
		name = c;
		ast_log(LOG_NOTICE, "Invalid to address: '%s' from %s (missing sip:) trying to use anyway...\n", c, ast_inet_ntoa(sin->sin_addr));
	}

	/* Strip off the domain name */
	if ((c = strchr(name, '@'))) {
		*c++ = '\0';
		domain = c;
		if ((c = strchr(domain, ':')))	/* Remove :port */
			*c = '\0';
		if (domains_configured()) {
			if (!check_sip_domain(domain, NULL, 0)) {
				transmit_response(p, "404 Not found (unknown domain)", &p->initreq);
				return AUTH_UNKNOWN_DOMAIN;
			}
		}
	}

	ast_string_field_set(p, exten, name);
	build_contact(p);
	peer = find_device(name, NULL, 1);
	if (!(peer && ast_apply_ha(peer->ha, sin))) {
		/* Peer fails ACL check */
		if (peer)
			ASTOBJ_UNREF(peer, sip_destroy_device);
		peer = NULL;
	}
	if (peer) {
		/* Set Frame packetization */
		if (p->rtp) {
			ast_rtp_codec_setpref(p->rtp, &peer->prefs);
			p->autoframing = peer->autoframing;
		}
		if (!ast_test_flag(&peer->flags[1], SIP_PAGE2_DYNAMIC)) {
			ast_log(LOG_ERROR, "Peer '%s' is trying to register, but not configured as host=dynamic\n", peer->name);
		} else {
			ast_copy_flags(&p->flags[0], &peer->flags[0], SIP_NAT);
			transmit_response(p, "100 Trying", req);
			if (!(res = check_auth(p, req, peer->name, peer->secret, peer->md5secret, SIP_REGISTER, uri, XMIT_UNRELIABLE, ast_test_flag(req, SIP_PKT_IGNORE)))) {
				sip_cancel_destroy(p);

				/* We have a succesful registration attemp with proper authentication,
				   now, update the peer */
				switch (parse_register_contact(p, peer, req)) {
				case PARSE_REGISTER_FAILED_MINEXPIRY:
					transmit_response_with_attachment(WITH_MINEXPIRY, p, "423 Interval too small", req, XMIT_UNRELIABLE);
					peer->lastmsgssent = -1;
					res = 0;
					break;
				case PARSE_REGISTER_FAILED:
					ast_log(LOG_WARNING, "Failed to parse contact info\n");
					transmit_response_with_attachment(WITH_DATE, p, "400 Bad Request", req, XMIT_UNRELIABLE);
					peer->lastmsgssent = -1;
					res = 0;
					break;
				case PARSE_REGISTER_QUERY:
					transmit_response_with_attachment(WITH_DATE, p, "200 OK", req, XMIT_UNRELIABLE);
					peer->lastmsgssent = -1;
					res = 0;
					break;
				case PARSE_REGISTER_UPDATE:
					update_peer(peer, p->expiry);
					/* Say OK and ask subsystem to retransmit msg counter */
					transmit_response_with_attachment(WITH_DATE, p, "200 OK", req, XMIT_UNRELIABLE);
					if (!ast_test_flag((&peer->flags[1]), SIP_PAGE2_SUBSCRIBEMWIONLY))
						peer->lastmsgssent = -1;
					res = 0;
					break;
				}
			} 
		}
	}
	if (!peer && global.autocreatepeer) {
		/* Create peer if we have autocreate mode enabled */
		peer = temp_peer(name);
		if (peer) {
			ASTOBJ_CONTAINER_LINK(&devicelist, peer);
			sip_cancel_destroy(p);
			switch (parse_register_contact(p, peer, req)) {
			case PARSE_REGISTER_FAILED_MINEXPIRY:
				transmit_response_with_attachment(WITH_MINEXPIRY, p, "423 Interval too small", req, XMIT_UNRELIABLE);
				peer->lastmsgssent = -1;
				res = 0;
			case PARSE_REGISTER_FAILED:
				ast_log(LOG_WARNING, "Failed to parse contact info\n");
				transmit_response_with_attachment(WITH_DATE, p, "400 Bad Request", req, XMIT_UNRELIABLE);
				peer->lastmsgssent = -1;
				res = 0;
				break;
			case PARSE_REGISTER_QUERY:
				transmit_response_with_attachment(WITH_DATE, p, "200 OK", req, XMIT_UNRELIABLE);
				peer->lastmsgssent = -1;
				res = 0;
				break;
			case PARSE_REGISTER_UPDATE:
				/* Say OK and ask subsystem to retransmit msg counter */
				transmit_response_with_attachment(WITH_DATE, p, "200 OK", req, XMIT_UNRELIABLE);
				manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Registered\r\n", peer->name);
				peer->lastmsgssent = -1;
				res = 0;
				break;
			}
		}
	}
	if (!res) {
		ast_device_state_changed("SIP/%s", peer->name);
	}
	if (res < 0) {
		switch (res) {
		case AUTH_SECRET_FAILED:
			/* Wrong password in authentication. Go away, don't try again until you fixed it */
			transmit_response(p, "403 Forbidden (Bad auth)", &p->initreq);
			break;
		case AUTH_USERNAME_MISMATCH:
			/* Username and digest username does not match. 
			   Asterisk uses the From: username for authentication. We need the
			   users to use the same authentication user name until we support
			   proper authentication by digest auth name */
			transmit_response(p, "403 Authentication user name does not match account name", &p->initreq);
			break;
		case AUTH_NOT_FOUND:
			if (global.alwaysauthreject) {
				transmit_fake_auth_response(p, &p->initreq, 1);
			} else {
				/* URI not found */
				transmit_response(p, "404 Not found", &p->initreq);
			}
			break;
		default:
			break;
		}
		if (option_debug > 1) {
			const char *reason = "";

			switch (res) {
			case AUTH_SECRET_FAILED:
				reason = "Bad password";
				break;
			case AUTH_USERNAME_MISMATCH:
				reason = "Bad digest user";
				break;
			case AUTH_NOT_FOUND:
				reason = "Peer not found";
				break;
			default:
				break;
			}
			ast_log(LOG_DEBUG, "SIP REGISTER attempt failed for %s : %s\n",
				peer->name, reason);
		}
	}
	if (peer)
		ASTOBJ_UNREF(peer, sip_destroy_device);

	return res;
}

/*! \brief Lock dialog list lock and find matching pvt lock  
	- Their tag is fromtag, our tag is to-tag
	- This means that in some transactions, totag needs to be their tag :-)
	  depending upon the direction
*/
GNURK struct sip_dialog *get_sip_dialog_byid_locked(const char *callid, const char *totag, const char *fromtag) 
{
	struct sip_dialog *sip_dialog_ptr;

	dialoglist_lock();

	if (option_debug > 3 && totag)
		ast_log(LOG_DEBUG, "Looking for callid %s (fromtag %s totag %s)\n", callid, fromtag ? fromtag : "<no fromtag>", totag ? totag : "<no totag>");

	/* Search interfaces and find the match */
	for (sip_dialog_ptr = dialoglist; sip_dialog_ptr; sip_dialog_ptr = sip_dialog_ptr->next) {
		if (!strcmp(sip_dialog_ptr->callid, callid)) {
			int match = 1;
			char *ourtag = sip_dialog_ptr->tag;

			/* Go ahead and lock it (and its owner) before returning */
			dialog_lock(sip_dialog_ptr, TRUE);

			/* Check if tags match. If not, this is not the call we want
			   (With a forking SIP proxy, several call legs share the
			   call id, but have different tags)
			*/
			if (strcmp(fromtag, sip_dialog_ptr->theirtag) || strcmp(totag, ourtag))
				match = 0;

			if (!match) {
				dialog_lock(sip_dialog_ptr, FALSE);
				continue;
			}

			if (option_debug > 3 && totag)				 
				ast_log(LOG_DEBUG, "Matched %s call - their tag is %s Our tag is %s\n",
					ast_test_flag(&sip_dialog_ptr->flags[0], SIP_OUTGOING) ? "OUTGOING": "INCOMING",
					sip_dialog_ptr->theirtag, sip_dialog_ptr->tag);

			/* deadlock avoidance... */
			while (sip_dialog_ptr->owner && ast_channel_trylock(sip_dialog_ptr->owner)) {
				dialog_lock(sip_dialog_ptr, FALSE);
				usleep(1);
				dialog_lock(sip_dialog_ptr, TRUE);
			}
			break;
		}
	}
	dialoglist_unlock();
	if (option_debug > 3 && !sip_dialog_ptr)
		ast_log(LOG_DEBUG, "Found no match for callid %s to-tag %s from-tag %s\n", callid, totag, fromtag);
	return sip_dialog_ptr;
}

/*! \brief Call transfer support (old way, deprecated by the IETF)--*/
static int get_also_info(struct sip_dialog *p, struct sip_request *oreq)
{
	char tmp[256] = "", *c, *a;
	struct sip_request *req = oreq ? oreq : &p->initreq;
	struct sip_refer *referdata = p->refer;
	const char *transfer_context = NULL;
	
	ast_copy_string(tmp, get_header(req, "Also"), sizeof(tmp));
	c = get_in_brackets(tmp);

	ast_uri_decode(c);
	
	if (strncmp(c, "sip:", 4)) {
		ast_log(LOG_WARNING, "Huh?  Not a SIP header in Also: transfer (%s)?\n", c);
		return -1;
	}
	c += 4;

	if ((a = strchr(c, ';'))) 	/* Remove arguments */
		*a = '\0';

	if ((a = strchr(c, '@'))) {	/* Separate Domain */
		*a++ = '\0';
		ast_copy_string(referdata->refer_to_domain, a, sizeof(referdata->refer_to_domain));
	}
	
	
	if (sip_debug_test_pvt(p))
		ast_verbose("Looking for %s in %s\n", c, p->context);

	if (p->owner)	/* Mimic behaviour in res_features.c */
		transfer_context = pbx_builtin_getvar_helper(p->owner, "TRANSFER_CONTEXT");

	/* By default, use the context in the channel sending the REFER */
	if (ast_strlen_zero(transfer_context)) {
		transfer_context = S_OR(p->owner->macrocontext,
					S_OR(p->context, global.default_context));
	}
	if (ast_exists_extension(NULL, transfer_context, c, 1, NULL)) {
		/* This is a blind transfer */
		if (option_debug)
			ast_log(LOG_DEBUG,"SIP Bye-also transfer to Extension %s@%s \n", c, transfer_context);
		ast_copy_string(referdata->refer_to, c, sizeof(referdata->refer_to));
		ast_copy_string(referdata->referred_by, "", sizeof(referdata->referred_by));
		ast_copy_string(referdata->refer_contact, "", sizeof(referdata->refer_contact));
		referdata->refer_call = NULL;
		/* Set new context */
		ast_string_field_set(p, context, transfer_context);
		return 0;
	} else if (ast_canmatch_extension(NULL, p->context, c, 1, NULL)) {
		return 1;
	}

	return -1;
}
/*! \brief check Via: header for hostname, port and rport request/answer */
static void check_via(struct sip_dialog *p, struct sip_request *req)
{
	char via[256];
	char *c, *pt;
	struct hostent *hp;
	struct ast_hostent ahp;

	ast_copy_string(via, get_header(req, "Via"), sizeof(via));

	/* Check for rport */
	c = strstr(via, ";rport");
	if (c && (c[6] != '='))	/* rport query, not answer */
		ast_set_flag(&p->flags[0], SIP_NAT_ROUTE);

	c = strchr(via, ';');
	if (c) 
		*c = '\0';

	c = strchr(via, ' ');
	if (c) {
		*c = '\0';
		c = ast_skip_blanks(c+1);
		if (strcasecmp(via, "SIP/2.0/UDP")) {
			ast_log(LOG_WARNING, "Don't know how to respond via '%s'\n", via);
			return;
		}
		pt = strchr(c, ':');
		if (pt)
			*pt++ = '\0';	/* remember port pointer */
		hp = ast_gethostbyname(c, &ahp);
		if (!hp) {
			ast_log(LOG_WARNING, "'%s' is not a valid host\n", c);
			return;
		}
		memset(&p->sa, 0, sizeof(p->sa));
		p->sa.sin_family = AF_INET;
		memcpy(&p->sa.sin_addr, hp->h_addr, sizeof(p->sa.sin_addr));
		p->sa.sin_port = htons(pt ? atoi(pt) : STANDARD_SIP_PORT);

		if (sip_debug_test_pvt(p)) {
			const struct sockaddr_in *dst = sip_real_dst(p);
			ast_verbose("Sending to %s : %d (%s)\n", ast_inet_ntoa(dst->sin_addr), ntohs(dst->sin_port), sip_nat_mode(p));
		}
	}
}

/*! \brief  Check if matching user or peer is defined 
 	Match user on From: user name and peer on IP/port
	This is used on first invite (not re-invites) and subscribe requests 
    \return 0 on success, non-zero on failure
*/
static enum check_auth_result check_user_full(struct sip_dialog *p, struct sip_request *req,
					      int sipmethod, char *uri, enum xmittype reliable,
					      struct sockaddr_in *sin, struct sip_peer **authpeer)
{
	struct sip_peer *device = NULL;
	char from[256], *c;
	char *of;
	char rpid_num[50];
	const char *rpid;
	enum check_auth_result res = AUTH_SUCCESSFUL;
	char *t;
	char calleridname[50];
	int debug = sip_debug_test_addr(sin);
	struct ast_variable *tmpvar = NULL, *v = NULL;
	enum objecttype devicematch = SIP_UNKNOWN;
	char *uri2 = ast_strdupa(uri);

	/* Terminate URI */
	t = uri2;
	while (*t && *t > 32 && *t != ';')
		t++;
	*t = '\0';
	ast_copy_string(from, get_header(req, "From"), sizeof(from));	/* XXX bug in original code, overwrote string */
	ast_uri_decode(from);
	/* XXX here tries to map the username for invite things */
	memset(calleridname, 0, sizeof(calleridname));
	get_calleridname(from, calleridname, sizeof(calleridname));
	if (calleridname[0])
		ast_string_field_set(p, cid_name, calleridname);

	rpid = get_header(req, "Remote-Party-ID");
	memset(rpid_num, 0, sizeof(rpid_num));
	if (!ast_strlen_zero(rpid)) 
		p->callingpres = get_rpid_num(rpid, rpid_num, sizeof(rpid_num));

	of = get_in_brackets(from);
	if (ast_strlen_zero(p->exten)) {
		char *t = uri2;
		if (!strncmp(t, "sip:", 4))
			t+= 4;
		ast_string_field_set(p, exten, t);
		t = strchr(p->exten, '@');
		if (t)
			*t = '\0';
		if (ast_strlen_zero(p->our_contact))
			build_contact(p);
	}
	/* save the URI part of the From header */
	ast_string_field_set(p, from, of);
	if (strncmp(of, "sip:", 4))
		ast_log(LOG_NOTICE, "From address missing 'sip:', using it anyway\n");
	else
		of += 4;
	/* Get just the username part */
	if ((c = strchr(of, '@'))) {
		char *tmp;
		*c = '\0';
		if ((c = strchr(of, ':')))
			*c = '\0';
		tmp = ast_strdupa(of);
		if (ast_is_shrinkable_phonenumber(tmp))
			ast_shrink_phone_number(tmp);
		ast_string_field_set(p, cid_num, tmp);
	}
	if (ast_strlen_zero(of))
		return AUTH_SUCCESSFUL;

	if (p->registry && p->registry->peer)	/* We already know this device from registry */
		device = p->registry->peer;
	else
		/* Find device in device list */
		device = find_device(of, NULL, 1);
	if (device && !ast_apply_ha(device->ha, sin)) {
		ASTOBJ_UNREF(device,sip_destroy_device);
		device = NULL;
	}
	/* Secondly match on IP/port (will in the future only be applied to trunks, not devices */
	if (!device) {
		/* Look for peer based on the IP address we received data from */
		/* If peer is registered from this IP address or have this as a default
		   IP address, this call is from the peer 
		*/
		device = find_device(NULL, &p->recv, 1);
	}
	if (device && !ast_apply_ha(device->ha, sin)) {
		ASTOBJ_UNREF(device,sip_destroy_device);
		device = NULL;
	}
	if (device)
		devicematch = SIP_PEER;		/* We matched on a peer */
	/* No device found */
	if (!device) {
		if (debug)
			ast_verbose("Found no matching peer or user for '%s:%d'\n", ast_inet_ntoa(p->recv.sin_addr), ntohs(p->recv.sin_port));

		/* do we allow guests? */
		if (!global.allowguest)
			res = -1;  /* we don't want any guests, authentication will fail */
		return res;
	}

	/* Ok, we have a device, let's check authentication if needed */
	ast_copy_flags(&p->flags[0], &device->flags[0], SIP_FLAGS_TO_COPY);
	ast_copy_flags(&p->flags[1], &device->flags[1], SIP_PAGE2_FLAGS_TO_COPY);

	/* Copy SIP extensions profile to peer */
	if (p->sipoptions)
		device->sipoptions = p->sipoptions;

	/* copy channel vars */
	for (v = device->chanvars ; v ; v = v->next) {
		if ((tmpvar = ast_variable_new(v->name, v->value))) {
			tmpvar->next = p->chanvars; 
			p->chanvars = tmpvar;
		}
	}
	p->prefs = device->prefs;
	/* Set Frame packetization */
	if (p->rtp) {
		ast_rtp_codec_setpref(p->rtp, &p->prefs);
		p->autoframing = device->autoframing;
	}

	replace_cid(p, rpid_num, calleridname);
	
	do_setnat(p, ast_test_flag(&p->flags[0], SIP_NAT_ROUTE));

	if (device->maxms && device->lastms)
		p->timer_t1 = device->lastms;
	if (ast_test_flag(&device->flags[0], SIP_INSECURE_INVITE)) {
		/* Pretend there is no required authentication */
		ast_string_field_free(p, peersecret);
		ast_string_field_free(p, peermd5secret);
	}
	/* Now, check auth */
	if (!(res = check_auth(p, req, device->name, device->secret, device->md5secret, sipmethod, uri, reliable, ast_test_flag(req, SIP_PKT_IGNORE)))) {
		/* We have positive authentication, let's configure this SIP session */
		sip_cancel_destroy(p);
		ast_copy_flags(&p->flags[0], &device->flags[0], SIP_FLAGS_TO_COPY);
		ast_copy_flags(&p->flags[1], &device->flags[1], SIP_PAGE2_FLAGS_TO_COPY);
		/* Copy SIP extensions profile from INVITE */
		if (p->sipoptions)
			device->sipoptions = p->sipoptions;
		/* If we have a call limit, set flag */
		if (device->call_limit)
			ast_set_flag(&p->flags[0], SIP_CALL_LIMIT);
		if (!ast_strlen_zero(device->context))
			ast_string_field_set(p, context, device->context);
		if (!ast_strlen_zero(device->cid_num) && !ast_strlen_zero(p->cid_num)) {
			char *tmp = ast_strdupa(device->cid_num);
			if (tmp) {
				if (ast_is_shrinkable_phonenumber(tmp))
					ast_shrink_phone_number(tmp);
				ast_string_field_set(p, cid_num, tmp);
			} else {
				ast_string_field_set(p, cid_num, device->cid_num);
			}
		}
		if (!ast_strlen_zero(device->cid_name) && !ast_strlen_zero(p->cid_num))
			ast_string_field_set(p, cid_name, device->cid_name);
		ast_string_field_set(p, peersecret, device->secret);
		ast_string_field_set(p, peermd5secret, device->md5secret);
		ast_string_field_set(p, fullcontact, device->fullcontact);
		ast_string_field_set(p, peername, device->name);
		ast_string_field_set(p, authname, device->name);
		if (!ast_strlen_zero(device->defaultuser)) {
			ast_string_field_set(p, peername, device->defaultuser);
			/* Use the default username for authentication on outbound calls */
			if(!ast_strlen_zero(device->authuser))
				ast_string_field_set(p, authname, device->authuser);
		}
		if (p->t38.peercapability)
			p->t38.jointcapability &= p->t38.peercapability;
		p->maxcallbitrate = device->maxcallbitrate;
		/* If we do not support video, remove video from call structure */
		if (!ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT) && p->vrtp) {
			ast_rtp_destroy(p->vrtp);
			p->vrtp = NULL;
		}
		ast_string_field_set(p, subscribecontext, device->subscribecontext);
		ast_string_field_set(p, accountcode, device->accountcode);
		ast_string_field_set(p, language, device->language);
		ast_string_field_set(p, mohsuggest, device->mohsuggest);
		ast_string_field_set(p, mohinterpret, device->mohinterpret);
		p->allowtransfer = device->allowtransfer;
		p->amaflags = device->amaflags;
		p->callgroup = device->callgroup;
		p->pickupgroup = device->pickupgroup;
		p->callingpres = device->callingpres;
		p->capability = device->capability;
		p->jointcapability = device->capability;
		p->prefs = device->prefs;
		if (p->peercapability)
			p->jointcapability &= p->peercapability;
		p->maxcallbitrate = device->maxcallbitrate;
		if (!ast_test_flag((&p->flags[1]), SIP_PAGE2_VIDEOSUPPORT) && p->vrtp) {
			ast_rtp_destroy(p->vrtp);
			p->vrtp = NULL;
		}
		if ((ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_RFC2833) || (ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_AUTO))
			p->noncodeccapability |= AST_RTP_DTMF;
		else
			p->noncodeccapability &= ~AST_RTP_DTMF;

		/* copy channel vars */
		for (v = device->chanvars ; v ; v = v->next) {
			if ((tmpvar = ast_variable_new(v->name, v->value))) {
				tmpvar->next = p->chanvars; 
				p->chanvars = tmpvar;
			}
		}	
		do_setnat(p, ast_test_flag(&p->flags[0], SIP_NAT_ROUTE));
		ast_string_field_set(p, peersecret, device->secret);
		ast_string_field_set(p, peermd5secret, device->md5secret);
		ast_string_field_set(p, subscribecontext, device->subscribecontext);
		ast_string_field_set(p, mohinterpret, device->mohinterpret);
		ast_string_field_set(p, mohsuggest, device->mohsuggest);
		if (device->callingpres)	/* Peer calling pres setting will override RPID */
			p->callingpres = device->callingpres;
	}
	if (device && debug)
		ast_verbose("Found %s '%s'\n", device->type & SIP_USER ? "user" : "peer", device->name);

	if (device)
		ASTOBJ_UNREF(device, sip_destroy_device);

	return res;
}

/*! \brief  Find user 
	If we get a match, this will add a reference pointer to the user object in ASTOBJ, that needs to be unreferenced
*/
static int check_user(struct sip_dialog *p, struct sip_request *req, int sipmethod, char *uri, enum xmittype reliable, struct sockaddr_in *sin)
{
	return check_user_full(p, req, sipmethod, uri, reliable, sin, NULL);
}

/*! \brief  Get text out of a SIP MESSAGE packet */
static int get_msg_text(char *buf, int len, struct sip_request *req)
{
	int x;
	int y;

	buf[0] = '\0';
	y = len - strlen(buf) - 5;
	if (y < 0)
		y = 0;
	for (x=0;x<req->lines;x++) {
		strncat(buf, req->line[x], y); /* safe */
		y -= strlen(req->line[x]) + 1;
		if (y < 0)
			y = 0;
		if (y != 0)
			strcat(buf, "\n"); /* safe */
	}
	return 0;
}


/*! \brief  Receive SIP MESSAGE method messages
\note	We only handle messages within current calls currently 
	Reference: RFC 3428 */
static void receive_message(struct sip_dialog *p, struct sip_request *req)
{
	char buf[1024];
	struct ast_frame f;
	const char *content_type = get_header(req, "Content-Type");

	if (strcmp(content_type, "text/plain")) { /* No text/plain attachment */
		transmit_response(p, "415 Unsupported Media Type", req); /* Good enough, or? */
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		return;
	}

	if (get_msg_text(buf, sizeof(buf), req)) {
		ast_log(LOG_WARNING, "Unable to retrieve text from %s\n", p->callid);
		transmit_response(p, "202 Accepted", req);
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		return;
	}

	if (p->owner) {
		if (sip_debug_test_pvt(p))
			ast_verbose("Message received: '%s'\n", buf);
		memset(&f, 0, sizeof(f));
		f.frametype = AST_FRAME_TEXT;
		f.subclass = 0;
		f.offset = 0;
		f.data = buf;
		f.datalen = strlen(buf);
		ast_queue_frame(p->owner, &f);
		transmit_response(p, "202 Accepted", req); /* We respond 202 accepted, since we relay the message */
	} else { /* Message outside of a call, we do not support that */
		ast_log(LOG_WARNING,"Received message to %s from %s, dropped it...\n  Content-Type:%s\n  Message: %s\n", get_header(req,"To"), get_header(req,"From"), content_type, buf);
		transmit_response(p, "405 Method Not Allowed", req); /* Good enough, or? */
	}
	sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
	return;
}

/*! \brief Remove temporary realtime objects from memory (CLI) */
GNURK int sip_prune_realtime(int fd, int argc, char *argv[])
{
	struct sip_peer *device;
	int prunepeer = FALSE;
	int multi = FALSE;
	char *name = NULL;
	regex_t regexbuf;

	switch (argc) {
	case 4:
		if (!strcasecmp(argv[3], "peer"))
			return RESULT_SHOWUSAGE;
		if (!strcasecmp(argv[3], "like"))
			return RESULT_SHOWUSAGE;
		if (!strcasecmp(argv[3], "all")) {
			multi = TRUE;
			prunepeer = TRUE;
		} else {
			prunepeer = TRUE;
			name = argv[3];
		}
		break;
	case 5:
		if (!strcasecmp(argv[4], "like"))
			return RESULT_SHOWUSAGE;
		if (!strcasecmp(argv[3], "all"))
			return RESULT_SHOWUSAGE;
		if (!strcasecmp(argv[3], "like")) {
			multi = TRUE;
			name = argv[4];
			prunepeer = TRUE;
		} else if (!strcasecmp(argv[3], "peer")) {
			prunepeer = TRUE;
			if (!strcasecmp(argv[4], "all"))
				multi = TRUE;
			else
				name = argv[4];
		} else
			return RESULT_SHOWUSAGE;
		break;
	case 6:
		if (strcasecmp(argv[4], "like"))
			return RESULT_SHOWUSAGE;
		if (!strcasecmp(argv[3], "peer")) {
			prunepeer = TRUE;
			name = argv[5];
		} else
			return RESULT_SHOWUSAGE;
		break;
	default:
		return RESULT_SHOWUSAGE;
	}

	if (multi && name) {
		if (regcomp(&regexbuf, name, REG_EXTENDED | REG_NOSUB))
			return RESULT_SHOWUSAGE;
	}

	if (multi) {
		if (prunepeer) {
			int pruned = 0;

			ASTOBJ_CONTAINER_WRLOCK(&devicelist);
			ASTOBJ_CONTAINER_TRAVERSE(&devicelist, 1, do {
				ASTOBJ_RDLOCK(iterator);
				if (name && regexec(&regexbuf, iterator->name, 0, NULL, 0)) {
					ASTOBJ_UNLOCK(iterator);
					continue;
				};
				if (ast_test_flag(&iterator->flags[1], SIP_PAGE2_RTCACHEFRIENDS)) {
					ASTOBJ_MARK(iterator);
					pruned++;
				}
				ASTOBJ_UNLOCK(iterator);
			} while (0) );
			if (pruned) {
				ASTOBJ_CONTAINER_PRUNE_MARKED(&devicelist, sip_destroy_device);
				ast_cli(fd, "%d peers pruned.\n", pruned);
			} else
				ast_cli(fd, "No peers found to prune.\n");
			ASTOBJ_CONTAINER_UNLOCK(&devicelist);
		}
	} else {
		if (prunepeer) {
			if ((device = ASTOBJ_CONTAINER_FIND_UNLINK(&devicelist, name))) {
				if (!ast_test_flag((&device->flags[1]), SIP_PAGE2_RTCACHEFRIENDS)) {
					ast_cli(fd, "Device '%s' is not a Realtime peer, cannot be pruned.\n", name);
					ASTOBJ_CONTAINER_LINK(&devicelist, device);
				} else
					ast_cli(fd, "Peer '%s' pruned.\n", name);
				ASTOBJ_UNREF(device, sip_destroy_device);
			} else
				ast_cli(fd, "Device '%s' not found.\n", name);
		}
	}

	return RESULT_SUCCESS;
}


/*! \brief Dump SIP history to debug log file at end of lifespan for SIP dialog */
GNURK void sip_dump_history(struct sip_dialog *dialog)
{
	int x = 0;
	struct sip_history *hist;

	if (!dialog)
		return;

	if (!option_debug && !sipdebug) {
		ast_log(LOG_NOTICE, "You must have debugging enabled (SIP or Asterisk) in order to dump SIP history.\n");
		return;
	}

	ast_log(LOG_DEBUG, "\n---------- SIP HISTORY for '%s' \n", dialog->callid);
	if (dialog->subscribed)
		ast_log(LOG_DEBUG, "  * Subscription\n");
	else
		ast_log(LOG_DEBUG, "  * SIP Call\n");
	if (dialog->history)
		AST_LIST_TRAVERSE(dialog->history, hist, list)
			ast_log(LOG_DEBUG, "  %-3.3d. %s\n", ++x, hist->event);
	if (!x)
		ast_log(LOG_DEBUG, "Call '%s' has no history\n", dialog->callid);
	ast_log(LOG_DEBUG, "\n---------- END SIP HISTORY for '%s' \n", dialog->callid);
}


/*! \brief  Receive SIP INFO Message
\note    Doesn't read the duration of the DTMF signal */
static void handle_request_info(struct sip_dialog *p, struct sip_request *req)
{
	char buf[1024];
	unsigned int event;
	const char *c = get_header(req, "Content-Type");

	if (ast_test_flag(req, SIP_PKT_IGNORE))  {
		transmit_response(p, "200 OK", req);
		return;
	}

	/* All replies to INFO are final */
	dialogstatechange(p, DIALOG_STATE_TERMINATED);

	/* Need to check the media/type */
	if (!strcasecmp(c, "application/dtmf-relay") ||
	    !strcasecmp(c, "application/vnd.nortelnetworks.digits")) {

		if (p->state == DIALOG_STATE_TRYING) {	/* INFO outside of a dialog */
			transmit_final_response(p, "481 Call leg/transaction does not exist", req, XMIT_UNRELIABLE); /* Should return error */
			return;
		}

		/* Try getting the "signal=" part */
		if (ast_strlen_zero(c = get_body(req, "Signal")) && ast_strlen_zero(c = get_body(req, "d"))) {
			ast_log(LOG_WARNING, "Unable to retrieve DTMF signal from INFO message from %s\n", p->callid);
			transmit_response(p, "200 OK", req); /* Should return error */
			return;
		} else
			ast_copy_string(buf, c, sizeof(buf));
	

		if (ast_strlen_zero(buf)) {
			/* Nothing there folks, move on. */
			transmit_response(p, "200 OK", req);
			return;
		}
		/* We have a DTMF code in the attachment */

		if (buf[0] == '*')
			event = 10;
		else if (buf[0] == '#')
			event = 11;
		else if ((buf[0] >= 'A') && (buf[0] <= 'D'))
			event = 12 + buf[0] - 'A';
		else
			event = atoi(buf);
		if (event == 16) {
			/* send a FLASH event */
			struct ast_frame f = { AST_FRAME_CONTROL, AST_CONTROL_FLASH, };
			ast_queue_frame(p->owner, &f);
			if (sipdebug)
				ast_verbose("* DTMF-relay event received: FLASH\n");
		} else {
			/* send a DTMF event */
			struct ast_frame f = { AST_FRAME_DTMF, };
			if (event < 10) {
				f.subclass = '0' + event;
			} else if (event < 11) {
				f.subclass = '*';
			} else if (event < 12) {
				f.subclass = '#';
			} else if (event < 16) {
				f.subclass = 'A' + (event - 12);
			}
			ast_queue_frame(p->owner, &f);
			if (sipdebug)
				ast_verbose("* DTMF-relay event received: %c\n", f.subclass);
		}
		transmit_response(p, "200 OK", req);
		return;
	} else if (!strcasecmp(c, "application/media_control+xml")) {
		/* Eh, we'll just assume it's a fast picture update for now */
		if (p->owner)
			ast_queue_control(p->owner, AST_CONTROL_VIDUPDATE);
		transmit_response(p, "200 OK", req);
		return;
	} else if (!ast_strlen_zero(c = get_header(req, "X-ClientCode"))) {
		/* Client code (from SNOM phone) */
		if (ast_test_flag(&p->flags[0], SIP_USECLIENTCODE)) {
			if (p->owner && p->owner->cdr)
				ast_cdr_setuserfield(p->owner, c);
			if (p->owner && ast_bridged_channel(p->owner) && ast_bridged_channel(p->owner)->cdr)
				ast_cdr_setuserfield(ast_bridged_channel(p->owner), c);
			transmit_response(p, "200 OK", req);
		} else {
			transmit_response(p, "415 Unsupported media type", req);
		}
		return;
	}
	/* Other type of INFO message, not really understood by Asterisk */
	/* if (get_msg_text(buf, sizeof(buf), req)) { */

	ast_log(LOG_WARNING, "Unable to parse INFO message from %s. Content %s\n", p->callid, buf);
	transmit_response(p, "415 Unsupported media type", req);
	return;
}

/*! \brief Cli command to send SIP notify to peer */
GNURK int sip_notify(int fd, int argc, char *argv[])
{
	struct ast_variable *varlist;
	int i;

	if (argc < 4)
		return RESULT_SHOWUSAGE;

	if (!notify_types) {
		ast_cli(fd, "No %s file found, or no types listed there\n", notify_config);
		return RESULT_FAILURE;
	}

	varlist = ast_variable_browse(notify_types, argv[2]);

	if (!varlist) {
		ast_cli(fd, "Unable to find notify type '%s'\n", argv[2]);
		return RESULT_FAILURE;
	}

	for (i = 3; i < argc; i++) {
		struct sip_dialog *p;
		struct sip_request req;
		struct ast_variable *var;

		if (!(p = sip_alloc(NULL, NULL, FALSE, SIP_NOTIFY))) {
			ast_log(LOG_WARNING, "Unable to build sip pvt data for notify (memory/socket error)\n");
			return RESULT_FAILURE;
		}

		if (create_addr(p, argv[i])) {
			/* Maybe they're not registered, etc. */
			sip_destroy(p);
			ast_cli(fd, "Could not create address for '%s'\n", argv[i]);
			continue;
		}

		initreqprep(&req, p, SIP_NOTIFY);

		for (var = varlist; var; var = var->next)
			add_header(&req, var->name, var->value);

		/* Recalculate our side, and recalculate Call ID */
		if (sip_ouraddrfor(&p->sa.sin_addr, &p->ourip))
			p->ourip = sipnet.__ourip;
		build_via(p, FALSE);
		build_callid_pvt(p);
		ast_cli(fd, "Sending NOTIFY of type '%s' to '%s'\n", argv[2], argv[i]);
		transmit_sip_request(p, &req);
		sip_scheddestroy(p, -1);
	}

	return RESULT_SUCCESS;
}

/*! \brief Read SIP header (dialplan function) */
static int func_header_read(struct ast_channel *chan, char *function, char *data, char *buf, size_t len) 
{
	struct sip_dialog *p;
	const char *content = NULL;
	AST_DECLARE_APP_ARGS(args,
		AST_APP_ARG(header);
		AST_APP_ARG(number);
	);
	int i, number, start = 0;

 	if (ast_strlen_zero(data)) {
		ast_log(LOG_WARNING, "This function requires a header name.\n");
		return -1;
	}

	ast_channel_lock(chan);
	if (chan->tech != &sip_tech) {
		ast_log(LOG_WARNING, "This function can only be used on SIP channels.\n");
		ast_channel_unlock(chan);
		return -1;
	}

	AST_STANDARD_APP_ARGS(args, data);
	if (!args.number) {
		number = 1;
	} else {
		sscanf(args.number, "%d", &number);
		if (number < 1)
			number = 1;
	}

	p = chan->tech_pvt;

	/* If there is no private structure, this channel is no longer alive */
	if (!p) {
		ast_channel_unlock(chan);
		return -1;
	}

	for (i = 0; i < number; i++)
		content = __get_header(&p->initreq, args.header, &start);

	if (ast_strlen_zero(content)) {
		ast_channel_unlock(chan);
		return -1;
	}

	ast_copy_string(buf, content, len);
	ast_channel_unlock(chan);

	return 0;
}

static struct ast_custom_function sip_header_function = {
	.name = "SIP_HEADER",
	.synopsis = "Gets the specified SIP header from the INVITE",
	.syntax = "SIP_HEADER(<name>[,<number>])",
	.desc = "Since there are several headers (such as Via) which can occur multiple\n"
	"times, SIP_HEADER takes an optional second argument to specify which header with\n"
	"that name to retrieve. Headers start at offset 1.\n",
	.read = func_header_read,
};

/*! \brief  ${SIPPEER()} Dialplan function - reads peer data */
static int function_sippeer(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len)
{
	struct sip_peer *peer;
	char *colname;

	if ((colname = strchr(data, ':')))	/*! \todo Will be deprecated after 1.4 */
		*colname++ = '\0';
	else if ((colname = strchr(data, '|')))
		*colname++ = '\0';
	else
		colname = "ip";

	if (!(peer = find_device(data, NULL, 1)))
		return -1;

	if (!strcasecmp(colname, "ip")) {
		ast_copy_string(buf, peer->addr.sin_addr.s_addr ? ast_inet_ntoa(peer->addr.sin_addr) : "", len);
	} else  if (!strcasecmp(colname, "status")) {
		peer_status(peer, buf, len);
	} else  if (!strcasecmp(colname, "language")) {
		ast_copy_string(buf, peer->language, len);
	} else  if (!strcasecmp(colname, "regexten")) {
		ast_copy_string(buf, peer->regexten, len);
	} else  if (!strcasecmp(colname, "limit")) {
		snprintf(buf, len, "%d", peer->call_limit);
	} else  if (!strcasecmp(colname, "curcalls")) {
		snprintf(buf, len, "%d", peer->inUse);
	} else  if (!strcasecmp(colname, "accountcode")) {
		ast_copy_string(buf, peer->accountcode, len);
	} else  if (!strcasecmp(colname, "useragent")) {
		ast_copy_string(buf, peer->useragent, len);
	} else  if (!strcasecmp(colname, "mailbox")) {
		ast_copy_string(buf, peer->mailbox, len);
	} else  if (!strcasecmp(colname, "context")) {
		ast_copy_string(buf, peer->context, len);
	} else  if (!strcasecmp(colname, "expire")) {
		snprintf(buf, len, "%d", peer->expire);
	} else  if (!strcasecmp(colname, "dynamic")) {
		ast_copy_string(buf, (ast_test_flag(&peer->flags[1], SIP_PAGE2_DYNAMIC) ? "yes" : "no"), len);
	} else  if (!strcasecmp(colname, "callerid_name")) {
		ast_copy_string(buf, peer->cid_name, len);
	} else  if (!strcasecmp(colname, "callerid_num")) {
		ast_copy_string(buf, peer->cid_num, len);
	} else  if (!strcasecmp(colname, "codecs")) {
		ast_getformatname_multiple(buf, len -1, peer->capability);
	} else  if (!strncasecmp(colname, "codec[", 6)) {
		char *codecnum;
		int index = 0, codec = 0;
		
		codecnum = colname + 6;	/* move past the '[' */
		codecnum = strsep(&codecnum, "]"); /* trim trailing ']' if any */
		index = atoi(codecnum);
		if((codec = ast_codec_pref_index(&peer->prefs, index))) {
			ast_copy_string(buf, ast_getformatname(codec), len);
		}
	}

	ASTOBJ_UNREF(peer, sip_destroy_device);

	return 0;
}

/*! \brief Structure to declare a dialplan function: SIPPEER */
struct ast_custom_function sippeer_function = {
	.name = "SIPPEER",
	.synopsis = "Gets SIP peer information",
	.syntax = "SIPPEER(<peername>[|item])",
	.read = function_sippeer,
	.desc = "Valid items are:\n"
	"- ip (default)          The IP address.\n"
	"- mailbox               The configured mailbox.\n"
	"- context               The configured context.\n"
	"- expire                The epoch time of the next expire.\n"
	"- dynamic               Is it dynamic? (yes/no).\n"
	"- callerid_name         The configured Caller ID name.\n"
	"- callerid_num          The configured Caller ID number.\n"
	"- codecs                The configured codecs.\n"
	"- status                Status (if qualify=yes).\n"
	"- regexten              Registration extension\n"
	"- limit                 Call limit (call-limit)\n"
	"- curcalls              Current amount of calls \n"
	"                        Only available if call-limit is set\n"
	"- language              Default language for peer\n"
	"- accountcode           Account code for this peer\n"
	"- useragent             Current user agent id for peer\n"
	"- codec[x]              Preferred codec index number 'x' (beginning with zero).\n"
	"\n"
};

/*! \brief ${SIPCHANINFO()} Dialplan function - reads sip channel data */
static int function_sipchaninfo_read(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len)
{
	struct sip_dialog *p;

	*buf = 0;
	
 	if (!data) {
		ast_log(LOG_WARNING, "This function requires a parameter name.\n");
		return -1;
	}

	ast_channel_lock(chan);
	if (chan->tech != &sip_tech) {
		ast_log(LOG_WARNING, "This function can only be used on SIP channels.\n");
		ast_channel_unlock(chan);
		return -1;
	}

	p = chan->tech_pvt;

	/* If there is no private structure, this channel is no longer alive */
	if (!p) {
		ast_channel_unlock(chan);
		return -1;
	}

	if (!strcasecmp(data, "peerip")) {
		ast_copy_string(buf, p->sa.sin_addr.s_addr ? ast_inet_ntoa(p->sa.sin_addr) : "", len);
	} else  if (!strcasecmp(data, "recvip")) {
		ast_copy_string(buf, p->recv.sin_addr.s_addr ? ast_inet_ntoa(p->recv.sin_addr) : "", len);
	} else  if (!strcasecmp(data, "from")) {
		ast_copy_string(buf, p->from, len);
	} else  if (!strcasecmp(data, "uri")) {
		ast_copy_string(buf, p->uri, len);
	} else  if (!strcasecmp(data, "useragent")) {
		ast_copy_string(buf, p->useragent, len);
	} else  if (!strcasecmp(data, "peername")) {
		ast_copy_string(buf, p->peername, len);
	} else if (!strcasecmp(data, "t38passthrough")) {
		if (p->t38.state == T38_DISABLED)
			ast_copy_string(buf, "0", sizeof("0"));
		else    /* T38 is offered or enabled in this call */
			ast_copy_string(buf, "1", sizeof("1"));
	} else {
		ast_channel_unlock(chan);
		return -1;
	}
	ast_channel_unlock(chan);

	return 0;
}

/*! \brief Structure to declare a dialplan function: SIPCHANINFO */
static struct ast_custom_function sipchaninfo_function = {
	.name = "SIPCHANINFO",
	.synopsis = "Gets the specified SIP parameter from the current channel",
	.syntax = "SIPCHANINFO(item)",
	.read = function_sipchaninfo_read,
	.desc = "Valid items are:\n"
	"- peerip                The IP address of the peer.\n"
	"- recvip                The source IP address of the peer.\n"
	"- from                  The URI from the From: header.\n"
	"- uri                   The URI from the Contact: header.\n"
	"- useragent             The useragent.\n"
	"- peername              The name of the peer.\n"
	"- t38passthrough        1 if T38 is offered or enabled in this channel, otherwise 0\n"
};


/*! \brief Check pending actions on SIP call */
static void check_pendings(struct sip_dialog *p)
{
	if (ast_test_flag(&p->flags[0], SIP_PENDINGBYE)) {
		/* if we can't BYE, then this is really a pending CANCEL */
		if (!ast_test_flag(&p->flags[0], SIP_CAN_BYE))
			transmit_request_with_auth(p, SIP_CANCEL, p->ocseq, 1, 0);
			/* Actually don't destroy us yet, wait for the 487 on our original 
			   INVITE, but do set an autodestruct just in case we never get it. */
		else 
			transmit_request_with_auth(p, SIP_BYE, 0, 1, 1);
		ast_clear_flag(&p->flags[0], SIP_PENDINGBYE);	
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
	} else if (ast_test_flag(&p->flags[0], SIP_NEEDREINVITE)) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Sending pending reinvite on '%s'\n", p->callid);
		/* Didn't get to reinvite yet, so do it now */
		transmit_reinvite_with_sdp(p, FALSE);
		ast_clear_flag(&p->flags[0], SIP_NEEDREINVITE);	
	}
}

/*! \brief Handle SIP response to INVITE dialogue */
static void handle_response_invite(struct sip_dialog *p, int resp, char *rest, struct sip_request *req)
{
	int outgoing = ast_test_flag(&p->flags[0], SIP_OUTGOING);
	int res = 0;
	int reinvite = (p->owner && p->owner->_state == AST_STATE_UP);
	struct ast_channel *bridgepeer = NULL;
	
	if (option_debug > 3) {
		if (reinvite)
			ast_log(LOG_DEBUG, "SIP response %d to RE-invite on %s call %s\n", resp, outgoing ? "outgoing" : "incoming", p->callid);
		else
			ast_log(LOG_DEBUG, "SIP response %d to standard invite\n", resp);
	}

	//sif (ast_test_flag(&p->flags[0], SIP_ALREADYGONE)) { /* This call is already gone */
	if (p->state == DIALOG_STATE_TERMINATED) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Got response on call that is already terminated: %s (ignoring)\n", p->callid);
		return;
	}

	/* Acknowledge sequence number - This only happens on INVITE from SIP-call */
	if (p->initid > -1) {
		/* Don't auto congest anymore since we've gotten something useful back */
		ast_sched_del(sched, p->initid);
		p->initid = -1;
	}

	/* RFC3261 says we must treat every 1xx response (but not 100)
	   that we don't recognize as if it was 183.
	*/
	if ((resp > 100) &&
	    (resp < 200) &&
	    (resp != 180) &&
	    (resp != 183))
		resp = 183;

	if (p->state == DIALOG_STATE_TRYING)
		dialogstatechange(p, DIALOG_STATE_PROCEEDING);	/* We do have any type of response */
	/* If we got 1xx reply WITH tag, it has to be DIALOG_STATE_EARLY */

	switch (resp) {
	case 100:	/* Trying */
		if (!ast_test_flag(req, SIP_PKT_IGNORE))
			sip_cancel_destroy(p);
		check_pendings(p);
		break;
	case 180:	/* 180 Ringing */
		if (!ast_test_flag(req, SIP_PKT_IGNORE))
			sip_cancel_destroy(p);
		if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner) {
			ast_queue_control(p->owner, AST_CONTROL_RINGING);
			if (p->owner->_state != AST_STATE_UP) {
				ast_setstate(p->owner, AST_STATE_RINGING);
			}
		}
		if (find_sdp(req)) {
			res = process_sdp(p, req);
			if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner) {
				/* Queue a progress frame only if we have SDP in 180 */
				ast_queue_control(p->owner, AST_CONTROL_PROGRESS);
			}
		}
		ast_set_flag(&p->flags[0], SIP_CAN_BYE);
		check_pendings(p);
		break;
	case 183:	/* Session progress */
		if (!ast_test_flag(req, SIP_PKT_IGNORE))
			sip_cancel_destroy(p);
		/* Ignore 183 Session progress without SDP */
		if (find_sdp(req)) {
			res = process_sdp(p, req);
			if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner) {
				/* Queue a progress frame */
				ast_queue_control(p->owner, AST_CONTROL_PROGRESS);
			}
		}
		dialogstatechange(p, DIALOG_STATE_EARLY);	/* We do have any type of response */
		ast_set_flag(&p->flags[0], SIP_CAN_BYE);
		check_pendings(p);
		break;
	case 200:	/* 200 OK on invite - someone's answering our call */
		if (!ast_test_flag(req, SIP_PKT_IGNORE))
			sip_cancel_destroy(p);
		dialogstatechange(p, DIALOG_STATE_CONFIRMED);	/* We do have any type of response */
		p->authtries = 0;
		if (find_sdp(req)) {
			if ((res = process_sdp(p, req)) && !ast_test_flag(req, SIP_PKT_IGNORE))
				if (!reinvite)
					/* This 200 OK's SDP is not acceptable, so we need to ack, then hangup */
					/* For re-invites, we try to recover */
					ast_set_flag(&p->flags[0], SIP_PENDINGBYE);	
		}

		/* Parse contact header for continued conversation */
		/* When we get 200 OK, we know which device (and IP) to contact for this call */
		/* This is important when we have a SIP proxy between us and the phone */
		if (outgoing) {
			update_call_counter(p, DEC_CALL_RINGING);
			parse_ok_contact(p, req);
			if(set_address_from_contact(p)) {
				/* Bad contact - we don't know how to reach this device */
				/* We need to ACK, but then send a bye */
				/* OEJ: Possible issue that may need a check:
					If we have a proxy route between us and the device,
					should we care about resolving the contact
					or should we just send it?
				*/
				if (!ast_test_flag(req, SIP_PKT_IGNORE))
					ast_set_flag(&p->flags[0], SIP_PENDINGBYE);	
			} 

			/* Save Record-Route for any later requests we make on this dialogue */
			build_route(p, req, 1);
		}
		
		if (p->owner && (p->owner->_state == AST_STATE_UP) && (bridgepeer = ast_bridged_channel(p->owner))) { /* if this is a re-invite */
			struct sip_dialog *bridgepvt = NULL;

			if (!bridgepeer->tech) {
				ast_log(LOG_WARNING, "Ooooh.. no tech!  That's REALLY bad\n");
				break;
			}
			if (!strcasecmp(bridgepeer->tech->type,"SIP")) {
				bridgepvt = (struct sip_dialog*)(bridgepeer->tech_pvt);
				if (bridgepvt->udptl) {
					if (p->t38.state == T38_PEER_REINVITE) {
						sip_handle_t38_reinvite(bridgepeer, p, 0);
					} else if (p->t38.state == T38_DISABLED && bridgepeer && (bridgepvt->t38.state == T38_ENABLED)) {
						ast_log(LOG_WARNING, "RTP re-inivte after T38 session not handled yet !\n");
						/* Insted of this we should somehow re-invite the other side of the bridge to RTP */
						/* XXXX Should we really destroy this session here, without any response at all??? */
						sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
					}
				} else {
					if (option_debug > 1)
						ast_log(LOG_DEBUG, "Strange... The other side of the bridge does not have a udptl struct\n");
					dialog_lock(bridgepvt, TRUE);
					bridgepvt->t38.state = T38_DISABLED;
					dialog_lock(bridgepvt, FALSE);
					if (option_debug)
						ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", bridgepvt->t38.state, bridgepeer->tech->type);
					p->t38.state = T38_DISABLED;
					if (option_debug > 1)
						ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
				}
			} else {
				/* Other side is not a SIP channel */
				if (option_debug > 1)
					ast_log(LOG_DEBUG, "Strange... The other side of the bridge is not a SIP channel\n");
				p->t38.state = T38_DISABLED;
				if (option_debug > 1)
					ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
			}
		}
		if ((p->t38.state == T38_LOCAL_REINVITE) || (p->t38.state == T38_LOCAL_DIRECT)) {
			/* If there was T38 reinvite and we are supposed to answer with 200 OK than this should set us to T38 negotiated mode */
			p->t38.state = T38_ENABLED;
			if (option_debug)
				ast_log(LOG_DEBUG, "T38 changed state to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
		}

		if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner) {
			if (!reinvite) {
				ast_queue_control(p->owner, AST_CONTROL_ANSWER);
			} else {	/* RE-invite */
				ast_queue_frame(p->owner, &ast_null_frame);
			}
		} else {
			 /* It's possible we're getting an 200 OK after we've tried to disconnect
				  by sending CANCEL */
			/* First send ACK, then send bye */
			if (!ast_test_flag(req, SIP_PKT_IGNORE))
				ast_set_flag(&p->flags[0], SIP_PENDINGBYE);	
		}
		/* If I understand this right, the branch is different for a non-200 ACK only */
		transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, TRUE);
		ast_set_flag(&p->flags[0], SIP_CAN_BYE);
		check_pendings(p);
		break;
	case 300: /* Multiple Choices */
	case 301: /* Moved permenantly */
	case 302: /* Moved temporarily */
	case 305: /* Use Proxy */
		transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, FALSE);
		ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
		stop_media_flows(p);	/* Stop RTP, VRTP and UDPTL */
		parse_moved_contact(p, req);
		if (p->owner)
			ast_queue_control(p->owner, AST_CONTROL_BUSY);
		break;
	case 407: /* Proxy authentication */
	case 401: /* Www auth */
		/* First we ACK */
		transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, FALSE);
		if (p->options)
			p->options->auth_type = resp;

		/* Then we AUTH */
		ast_string_field_free(p, theirtag);	/* forget their old tag, so we don't match tags when getting response */
		//??? dialogstatechange(p, DIALOG_STATE_TERMINATED_AUTH);	
		if (!ast_test_flag(req, SIP_PKT_IGNORE)) {
			if (p->authtries == MAX_AUTHTRIES || do_proxy_auth(p, req, resp, SIP_INVITE, 1)) {
				ast_log(LOG_NOTICE, "Failed to authenticate on INVITE to '%s'\n", get_header(&p->initreq, "From"));
				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
				ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
				if (p->owner)
					ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
				dialogstatechange(p, DIALOG_STATE_TERMINATED);	
			}
		}
		break;
	case 403: /* Forbidden */
		/* First we ACK */
		transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, FALSE);
		ast_log(LOG_WARNING, "Received response: \"Forbidden\" from '%s'\n", get_header(&p->initreq, "From"));
		if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner)
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
		ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
		break;
	case 404: /* Not found */
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, FALSE);
		if (p->owner && !ast_test_flag(req, SIP_PKT_IGNORE))
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
		break;
	case 481: /* Call leg does not exist */
		/* Could be REFER or INVITE */
		ast_log(LOG_WARNING, "Re-invite to non-existing call leg on other UA. SIP dialog '%s'. Giving up.\n", p->callid);
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, FALSE);
		break;
	case 491: /* Pending */
		/* we have to wait a while, then retransmit */
		/* Transmission is rescheduled, so everything should be taken care of.
			We should support the retry-after at some point */
		/*! \todo fix 491 pending support */
		break;
	case 488: /* Not acceptable here - codec error */
	case 501: /* Not implemented */
		transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, FALSE);
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		if (p->owner)
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		break;
	case 486: /* Busy here */
	case 600: /* Busy everywhere */
	case 603: /* Decline */
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, FALSE);
		ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
		stop_media_flows(p);	/* Stop RTP, VRTP and UDPTL */
		if (p->owner)
			ast_queue_control(p->owner, AST_CONTROL_BUSY);
		break;
	}
}

/* \brief Handle SIP response in REFER transaction
	We've sent a REFER, now handle responses to it 
  */
static void handle_response_refer(struct sip_dialog *p, int resp, char *rest, struct sip_request *req)
{
	switch (resp) {
	case 202:   /* Transfer accepted */
		/* We need  to do something here */
		/* The transferee is now sending INVITE to target */
		p->refer->status = REFER_ACCEPTED;
		/* Now wait for next message */
		if (option_debug > 2)
			ast_log(LOG_DEBUG, "Got 202 accepted on transfer\n");
		/* We should hang along, waiting for NOTIFY's here */
		break;

	case 401:   /* Not www-authorized on SIP method */
	case 407:   /* Proxy auth */
		if (ast_strlen_zero(p->authname)) {
			ast_log(LOG_WARNING, "Asked to authenticate REFER to %s:%d but we have no matching peer or realm auth!\n",
				ast_inet_ntoa(p->recv.sin_addr), ntohs(p->recv.sin_port));
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
		}
		if (p->authtries > 1 || do_proxy_auth(p, req, resp, SIP_REFER, 0)) {
			ast_log(LOG_NOTICE, "Failed to authenticate on REFER to '%s'\n", get_header(&p->initreq, "From"));
			p->refer->status = REFER_NOAUTH;
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
		}
		break;


	case 500:   /* Server error */
	case 501:   /* Method not implemented */
		/* Return to the current call onhold */
		/* Status flag needed to be reset */
		ast_log(LOG_NOTICE, "SIP transfer to %s failed, call miserably fails. \n", p->refer->refer_to);
		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
		p->refer->status = REFER_FAILED;
		break;
	case 603:   /* Transfer declined */
		ast_log(LOG_NOTICE, "SIP transfer to %s declined, call miserably fails. \n", p->refer->refer_to);
		p->refer->status = REFER_FAILED;
		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
		break;
	}
}


/*! \brief Handle SIP response in dialogue */
/* XXX only called by handle_request */
static void handle_response(struct sip_dialog *p, int resp, char *rest, struct sip_request *req)
{
	struct ast_channel *owner;
	int sipmethod;
	int res = 1;
	const char *c = req->cseqheader;
	const char *msg = strchr(c, ' ');

	/* Find the method of the request this response is an reply to */
	if (!msg)
		msg = "";
	else
		msg++;
	sipmethod = find_sip_method(msg);

	owner = p->owner;
	if (owner) 
		owner->hangupcause = hangup_sip2cause(resp);

	/* Acknowledge whatever it is destined for */
	if ((resp >= 100) && (resp <= 199))	/* Provisional responses */
		__sip_semi_ack(p, req->seqno, 0, sipmethod);
	else	/* Final response */
		__sip_ack(p, req->seqno, 0, sipmethod, resp == 491 ? TRUE : FALSE);

	/* Get their tag if we haven't already */
	if (ast_strlen_zero(p->theirtag) || (resp >= 200)) {
		char tag[128];

		gettag(req->to, tag, sizeof(tag));
		ast_string_field_set(p, theirtag, tag);
	}
	if (p->relatedpeer && p->method == SIP_OPTIONS) {
		/* We don't really care what the response is, just that it replied back. 
		   Well, as long as it's not a 100 response...  since we might
		   need to hang around for something more "definitive" */

		return handle_response_peerpoke(p, resp, req);
	}

	switch(resp) {
	case 100:	/* 100 Trying */
		if (sipmethod == SIP_INVITE) 
			handle_response_invite(p, resp, rest, req);
		break;
	case 183:	/* 183 Session Progress */
		if (sipmethod == SIP_INVITE) 
			handle_response_invite(p, resp, rest, req);
		break;
	case 180:	/* 180 Ringing */
		if (sipmethod == SIP_INVITE) 
			handle_response_invite(p, resp, rest, req);
		break;
	case 200:	/* 200 OK */
		p->authtries = 0;	/* Reset authentication counter */
		if (sipmethod == SIP_MESSAGE) {
			/* We successfully transmitted a message */
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
		} else if (sipmethod == SIP_CANCEL) {
			if (option_debug)
				ast_log(LOG_DEBUG, "Got 200 OK on CANCEL\n");

			/* Wait for 487, then destroy */
		} else if (sipmethod == SIP_INVITE) {
			handle_response_invite(p, resp, rest, req);
		} else if (sipmethod == SIP_NOTIFY) {
			/* They got the notify, this is the end */
			if (p->owner) {
				if (!p->refer) {
					ast_log(LOG_WARNING, "Notify answer on an owned channel? - %s\n", p->owner->name);
					ast_queue_hangup(p->owner);
				} else if (option_debug > 3) 
					ast_log(LOG_DEBUG, "Got OK on REFER Notify message\n");
			} else {
				if (p->subscribed == NONE) 
					ast_set_flag(&p->flags[0], SIP_NEEDDESTROY); 
			}
			dialogstatechange(p, DIALOG_STATE_TERMINATED);
		} else if (sipmethod == SIP_REGISTER) 
			res = handle_response_register(p, resp, rest, req, req->seqno);
		else if (sipmethod == SIP_BYE)		/* Ok, we're ready to go */
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY); 
		break;
	case 202:   /* Transfer accepted */
		if (sipmethod == SIP_REFER) 
			handle_response_refer(p, resp, rest, req);
		break;
	case 401: /* Not www-authorized on SIP method */
	case 407: /* Proxy auth required */
		if (sipmethod == SIP_INVITE)
			handle_response_invite(p, resp, rest, req);
		else if (sipmethod == SIP_REFER)
			handle_response_refer(p, resp, rest, req);
		else if (p->registry && sipmethod == SIP_REGISTER)
			res = handle_response_register(p, resp, rest, req, req->seqno);
		else if (sipmethod == SIP_BYE) {
			if (ast_strlen_zero(p->authname))
				ast_log(LOG_WARNING, "Asked to authenticate %s, to %s:%d but we have no matching peer!\n",
						msg, ast_inet_ntoa(p->recv.sin_addr), ntohs(p->recv.sin_port));
			if (p->authtries == MAX_AUTHTRIES || do_proxy_auth(p, req, resp, sipmethod, 0)) {
				ast_log(LOG_NOTICE, "Failed to authenticate on %s to '%s'\n", msg, get_header(&p->initreq, "From"));
				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
			}
		} else {
			ast_log(LOG_WARNING, "Got authentication request (401) on unknown %s to '%s'\n", sip_method2txt(sipmethod), get_header(req, "To"));
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
		}
		break;
	case 403: /* Forbidden - we failed authentication */
		if (sipmethod == SIP_INVITE)
			handle_response_invite(p, resp, rest, req);
		else if (p->registry && sipmethod == SIP_REGISTER) 
			res = handle_response_register(p, resp, rest, req, req->seqno);
		else {
			ast_log(LOG_WARNING, "Forbidden - maybe wrong password on authentication for %s\n", msg);
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
		}
		break;
	case 404: /* Not found */
		if (p->registry && sipmethod == SIP_REGISTER)
			res = handle_response_register(p, resp, rest, req, req->seqno);
		else if (sipmethod == SIP_INVITE)
			handle_response_invite(p, resp, rest, req);
		else if (owner)
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		break;
	case 423: /* Interval too brief */
		if (sipmethod == SIP_REGISTER)
			res = handle_response_register(p, resp, rest, req, req->seqno);
		break;
	case 481: /* Call leg does not exist */
		if (sipmethod == SIP_INVITE) {
			/* First we ACK */
			transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, FALSE);
				ast_log(LOG_WARNING, "INVITE with REPLACEs failed to '%s'\n", get_header(&p->initreq, "From"));
			if (owner)
				ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
			dialogstatechange(p, DIALOG_STATE_TERMINATED);
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		} else if (sipmethod == SIP_REFER) {
			/* A transfer with Replaces did not work */
			/* OEJ: We should Set flag, cancel the REFER, go back
			to original call - but right now we can't */
			ast_log(LOG_WARNING, "Remote host can't match request %s to call '%s'. Giving up.\n", sip_method2txt(sipmethod), p->callid);
			if (owner)
				ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
		} else if (sipmethod == SIP_BYE) {
			/* The other side has no transaction to bye,
			just assume it's all right then */
			ast_log(LOG_WARNING, "Remote host can't match request %s to call '%s'. Giving up.\n", sip_method2txt(sipmethod), p->callid);
		} else if (sipmethod == SIP_CANCEL) {
			/* The other side has no transaction to cancel,
			just assume it's all right then */
			ast_log(LOG_WARNING, "Remote host can't match request %s to call '%s'. Giving up.\n", sip_method2txt(sipmethod), p->callid);
		} else {
			ast_log(LOG_WARNING, "Remote host can't match request %s to call '%s'. Giving up.\n", sip_method2txt(sipmethod), p->callid);
			/* Guessing that this is not an important request */
		}
		break;
	case 491: /* Pending */
		if (sipmethod == SIP_INVITE)
			handle_response_invite(p, resp, rest, req);
		else {
			if (option_debug)
				ast_log(LOG_DEBUG, "Got 491 on %s, unspported. Call ID %s\n", sip_method2txt(sipmethod), p->callid);
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
		}
		break;
	case 501: /* Not Implemented */
		if (sipmethod == SIP_INVITE)
			handle_response_invite(p, resp, rest, req);
		else if (sipmethod == SIP_REFER)
			handle_response_refer(p, resp, rest, req);
		else {
			ast_log(LOG_WARNING, "Host '%s' does not implement '%s'\n", ast_inet_ntoa(p->sa.sin_addr), msg);
		}
		break;
	case 603:	/* Declined transfer */
		if (sipmethod == SIP_REFER) {
			handle_response_refer(p, resp, rest, req);
			break;
		} else if (sipmethod == SIP_INVITE) {
			handle_response_invite(p, resp, rest, req);
			break;
		}
		/* Fallthrough */
	default:
		if ((resp >= 300) && (resp < 700)) {
			/* Fatal response */
			if ((option_verbose > 2) && (resp != 487))
				ast_verbose(VERBOSE_PREFIX_3 "Got SIP response %d \"%s\" back from %s\n", resp, rest, ast_inet_ntoa(p->sa.sin_addr));
			ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
			stop_media_flows(p);	/* Stop RTP, VRTP and UDPTL */
			/* XXX Locking issues?? XXX */
			switch(resp) {
			case 300: /* Multiple Choices */
			case 301: /* Moved permenantly */
			case 302: /* Moved temporarily */
			case 305: /* Use Proxy */
			case 486: /* Busy here */
			case 600: /* Busy everywhere */
				if (sipmethod == SIP_INVITE)
					handle_response_invite(p, resp, rest, req);
				break;
			case 487:	/* Response on INVITE that has been CANCELled */
				/* channel now destroyed - dec the inUse counter */
				if (owner)
					ast_queue_hangup(p->owner);
				update_call_counter(p, DEC_CALL_LIMIT);
				break;
			case 488: /* Not acceptable here - codec error */
				if (sipmethod == SIP_INVITE) {
					handle_response_invite(p, resp, rest, req);
					break;
				}
			case 482: 
				 /* So we treat this as a call
				 forward and hope we end up at the right place... */
				if (option_debug)
					ast_log(LOG_DEBUG, "Hairpin detected, setting up call forward for what it's worth\n");
				if (p->owner)
					ast_string_field_build(p->owner, call_forward,
							       "Local/%s@%s", p->peername, p->context);
					/* Fall through */
			case 480: /* Temporarily Unavailable */
			case 404: /* Not Found */
			case 410: /* Gone */
			case 400: /* Bad Request */
			case 500: /* Server error */
				if (sipmethod == SIP_REFER) {
					handle_response_refer(p, resp, rest, req);
					break;
				}
				/* Fall through */
			case 503: /* Service Unavailable */
				if (owner)
					ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
				break;
			default:
				/* Send hangup */	
				if (owner)
					ast_queue_hangup(p->owner);
				break;
			}
			/* ACK on invite */
			if (sipmethod == SIP_INVITE) 
				transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, FALSE);
			ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
			if (!p->owner)
				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
		} else if ((resp >= 100) && (resp < 200)) {
			if (sipmethod == SIP_INVITE) {
				if (!ast_test_flag(req, SIP_PKT_IGNORE))
					sip_cancel_destroy(p);
				if (find_sdp(req))
					process_sdp(p, req);
				if (p->owner) {
					/* Queue a progress frame */
					ast_queue_control(p->owner, AST_CONTROL_PROGRESS);
				}
			}
		} else
			ast_log(LOG_NOTICE, "Dont know how to handle a %d %s response from %s\n", resp, rest, p->owner ? p->owner->name : ast_inet_ntoa(p->sa.sin_addr));
	}
}


/*! \brief Turn off generator data 
	XXX Does this function belong in the SIP channel?
*/
GNURK void ast_quiet_chan(struct ast_channel *chan) 
{
	if (chan && chan->_state == AST_STATE_UP) {
		if (chan->generatordata)
			ast_deactivate_generator(chan);
	}
}

/*! \brief Handle incoming notifications 
 * \note Out of dialog NOTIFY messages are killed in match_or_create_dialog()
 	If implementing VMI support, that needs to change 
 */
static int handle_request_notify(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e)
{
	/* This is mostly a skeleton for future improvements */
	/* Mostly created to return proper answers on notifications on outbound REFER's */
	int res = 0;
	const char *event = get_header(req, "Event");
	char *eventid = NULL;
	char *sep;

	if( (sep = strchr(event, ';')) ) {	/* XXX bug here - overwriting string ? */
		*sep++ = '\0';
		eventid = sep;
	}
	
	if (option_debug > 1 && sipdebug)
		ast_log(LOG_DEBUG, "Got NOTIFY Event: %s\n", event);

	if (strcmp(event, "refer")) {
		/* We don't understand this event. */
		/* Here's room to implement incoming voicemail notifications :-) */
		transmit_response(p, "489 Bad event", req);
		if (!p->lastinvite) 
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		return -1;
	} else {
		/* Save nesting depth for now, since there might be other events we will
			support in the future */

		/* Handle REFER notifications */

		char buf[1024];
		char *cmd, *code;
		int respcode;
		int success = TRUE;

		/* EventID for each transfer... EventID is basically the REFER cseq 

		 We are getting notifications on a call that we transfered
		 We should hangup when we are getting a 200 OK in a sipfrag
		 Check if we have an owner of this event */
		
		/* Check the content type */
		if (strncasecmp(get_header(req, "Content-Type"), "message/sipfrag", strlen("message/sipfrag"))) {
			/* We need a sipfrag */
			transmit_response(p, "400 Bad request", req);
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			return -1;
		}

		/* Get the text of the attachment */
		if (get_msg_text(buf, sizeof(buf), req)) {
			ast_log(LOG_WARNING, "Unable to retrieve attachment from NOTIFY %s\n", p->callid);
			transmit_response(p, "400 Bad request", req);
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			return -1;
		}

		/*
		From the RFC...
		A minimal, but complete, implementation can respond with a single
   		NOTIFY containing either the body:
      			SIP/2.0 100 Trying
		
   		if the subscription is pending, the body:
      			SIP/2.0 200 OK
   		if the reference was successful, the body:
      			SIP/2.0 503 Service Unavailable
   		if the reference failed, or the body:
      			SIP/2.0 603 Declined

   		if the REFER request was accepted before approval to follow the
   		reference could be obtained and that approval was subsequently denied
   		(see Section 2.4.7).
		
		If there are several REFERs in the same dialog, we need to
		match the ID of the event header...
		*/
		if (option_debug > 2)
			ast_log(LOG_DEBUG, "* SIP Transfer NOTIFY Attachment: \n---%s\n---\n", buf);
		cmd = ast_skip_blanks(buf);
		code = cmd;
		/* We are at SIP/2.0 */
		while(*code && (*code > 32)) {	/* Search white space */
			code++;
		}
		*code++ = '\0';
		code = ast_skip_blanks(code);
		sep = code;
		sep++;
		while(*sep && (*sep > 32)) {	/* Search white space */
			sep++;
		}
		*sep++ = '\0';			/* Response string */
		respcode = atoi(code);
		switch (respcode) {
		case 100:	/* Trying: */
			/* Don't do anything yet */
			break;
		case 183:	/* Ringing: */
			/* Don't do anything yet */
			break;
		case 200:	/* OK: The new call is up, hangup this call */
			/* Hangup the call that we are replacing */
			break;
		case 301: /* Moved permenantly */
		case 302: /* Moved temporarily */
			/* Do we get the header in the packet in this case? */
			success = FALSE;
			break;
		case 503:	/* Service Unavailable: The new call failed */
				/* Cancel transfer, continue the call */
			success = FALSE;
			break;
		case 603:	/* Declined: Not accepted */
				/* Cancel transfer, continue the current call */
			success = FALSE;
			break;
		}
		if (!success) {
			ast_log(LOG_NOTICE, "Transfer failed. Sorry. Nothing further to do with this call\n");
		}
		
		/* Confirm that we received this packet */
		transmit_response(p, "200 OK", req);
		return res;
	};
}

/*! \brief Handle incoming OPTIONS request */
static int handle_request_options(struct sip_dialog *p, struct sip_request *req)
{
	int res;

	res = get_destination(p, req);
	build_contact(p);
	/* XXX Should we authenticate OPTIONS? XXX */
	if (ast_strlen_zero(p->context))
		ast_string_field_set(p, context, global.default_context);
	if (res < 0)
		transmit_response_with_attachment(WITH_ALLOW, p, "404 Not Found", req, XMIT_UNRELIABLE);
	else 
		transmit_response_with_attachment(WITH_ALLOW, p, "200 OK", req, XMIT_UNRELIABLE);
	/* Destroy if this OPTIONS was the opening request, but not if
	   it's in the middle of a normal call flow. */
	if (!p->lastinvite)
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);

	return res;
}

/*! \brief Handle the transfer part of INVITE with a replaces: header, 
    meaning a target pickup or an attended transfer */
static int handle_invite_replaces(struct sip_dialog *p, struct sip_request *req, int debug, struct sockaddr_in *sin)
{
	struct ast_frame *f;
	int earlyreplace = 0;
	int oneleggedreplace = 0;		/* Call with no bridge, propably IVR or voice message */
	struct ast_channel *c = p->owner;	/* Our incoming call */
	struct ast_channel *replacecall = p->refer->refer_call->owner;	/* The channel we're about to take over */
	struct ast_channel *targetcall;		/* The bridge to the take-over target */

	/* Check if we're in ring state */
	if (replacecall->_state == AST_STATE_RING)
		earlyreplace = 1;

	/* Check if we have a bridge */
	if (!(targetcall = ast_bridged_channel(replacecall))) {
		/* We have no bridge */
		if (!earlyreplace) {
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "	Attended transfer attempted to replace call with no bridge (maybe ringing). Channel %s!\n", replacecall->name);
			oneleggedreplace = 1;
		}
	} 
	if (option_debug > 3 && targetcall && targetcall->_state == AST_STATE_RINGING)
			ast_log(LOG_DEBUG, "SIP transfer: Target channel is in ringing state\n");

	if (option_debug > 3) {
		if (targetcall) 
			ast_log(LOG_DEBUG, "SIP transfer: Invite Replace incoming channel should bridge to channel %s while hanging up channel %s\n", targetcall->name, replacecall->name); 
		else
			ast_log(LOG_DEBUG, "SIP transfer: Invite Replace incoming channel should replace and hang up channel %s (one call leg)\n", replacecall->name); 
	}

	if (ast_test_flag(req, SIP_PKT_IGNORE)) {
		ast_log(LOG_NOTICE, "Ignoring this INVITE with replaces in a stupid way.\n");
		/* We should answer something here. If we are here, the
			call we are replacing exists, so an accepted 
			can't harm */
		transmit_response_with_attachment(WITH_SDP, p, "200 OK", req, XMIT_RELIABLE);
		/* Do something more clever here */
		ast_channel_unlock(c);
		dialog_lock(p->refer->refer_call, FALSE);
		return 1;
	} 
	if (!c) {
		/* What to do if no channel ??? */
		ast_log(LOG_ERROR, "Unable to create new channel.  Invite/replace failed.\n");
		transmit_response_reliable(p, "503 Service Unavailable", req);
		append_history(p, "Xfer", "INVITE/Replace Failed. No new channel.");
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		dialog_lock(p->refer->refer_call, FALSE);
		return 1;
	}
	append_history(p, "Xfer", "INVITE/Replace received");
	/* We have three channels to play with
		channel c: New incoming call
		targetcall: Call from PBX to target
		p->refer->refer_call: SIP pvt dialog from transferer to pbx.
		replacecall: The owner of the previous
		We need to masq C into refer_call to connect to 
		targetcall;
		If we are talking to internal audio stream, target call is null.
	*/

	/* Fake call progress */
	transmit_response(p, "100 Trying", req);
	ast_setstate(c, AST_STATE_RING);

	/* Masquerade the new call into the referred call to connect to target call 
	   Targetcall is not touched by the masq */

	/* Answer the incoming call and set channel to UP state */
	transmit_response_with_attachment(WITH_SDP, p, "200 OK", req, XMIT_RELIABLE);
	ast_setstate(c, AST_STATE_UP);
	
	/* Stop music on hold and other generators */
	ast_quiet_chan(replacecall);
	ast_quiet_chan(targetcall);
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "Invite/Replaces: preparing to masquerade %s into %s\n", c->name, replacecall->name);
	/* Unlock clone, but not original (replacecall) */
	ast_channel_unlock(c);

	/* Unlock dialog */
	dialog_lock(p->refer->refer_call, FALSE);

	/* Make sure that the masq does not free our PVT for the old call */
	ast_set_flag(&p->refer->refer_call->flags[0], SIP_DEFER_BYE_ON_TRANSFER);	/* Delay hangup */
		
	/* Prepare the masquerade - if this does not happen, we will be gone */
	if(ast_channel_masquerade(replacecall, c))
		ast_log(LOG_ERROR, "Failed to masquerade C into Replacecall\n");
	else if (option_debug > 3)
		ast_log(LOG_DEBUG, "Invite/Replaces: Going to masquerade %s into %s\n", c->name, replacecall->name);

	/* The masquerade will happen as soon as someone reads a frame from the channel */

	/* C should now be in place of replacecall */
	/* ast_read needs to lock channel */
	ast_channel_unlock(c);
	
	if (earlyreplace || oneleggedreplace ) {
		/* Force the masq to happen */
		if ((f = ast_read(replacecall))) {	/* Force the masq to happen */
			ast_frfree(f);
			f = NULL;
			if (option_debug > 3)
				ast_log(LOG_DEBUG, "Invite/Replace:  Could successfully read frame from RING channel!\n");
		} else {
			ast_log(LOG_WARNING, "Invite/Replace:  Could not read frame from RING channel \n");
		}
		c->hangupcause = AST_CAUSE_SWITCH_CONGESTION;
		ast_channel_unlock(replacecall);
	} else {	/* Bridged call, UP channel */
		if ((f = ast_read(replacecall))) {	/* Force the masq to happen */
			/* Masq ok */
			ast_frfree(f);
			f = NULL;
			if (option_debug > 2)
				ast_log(LOG_DEBUG, "Invite/Replace:  Could successfully read frame from channel! Masq done.\n");
		} else {
			ast_log(LOG_WARNING, "Invite/Replace:  Could not read frame from channel. Transfer failed\n");
		}
		ast_channel_unlock(replacecall);
	}
	dialog_lock(p->refer->refer_call, FALSE);

	ast_setstate(c, AST_STATE_DOWN);
	if (option_debug > 3) {
		struct ast_channel *test;
		ast_log(LOG_DEBUG, "After transfer:----------------------------\n");
		ast_log(LOG_DEBUG, " -- C:        %s State %s\n", c->name, ast_state2str(c->_state));
		if (replacecall)
			ast_log(LOG_DEBUG, " -- replacecall:        %s State %s\n", replacecall->name, ast_state2str(replacecall->_state));
		if (p->owner) {
			ast_log(LOG_DEBUG, " -- P->owner: %s State %s\n", p->owner->name, ast_state2str(p->owner->_state));
			test = ast_bridged_channel(p->owner);
			if (test)
				ast_log(LOG_DEBUG, " -- Call bridged to P->owner: %s State %s\n", test->name, ast_state2str(test->_state));
			else
				ast_log(LOG_DEBUG, " -- No call bridged to C->owner \n");
		} else 
			ast_log(LOG_DEBUG, " -- No channel yet \n");
		ast_log(LOG_DEBUG, "End After transfer:----------------------------\n");
	}

	ast_channel_unlock(p->owner);	/* Unlock new owner */
	dialog_lock(p, FALSE);

	/* The call should be down with no ast_channel, so hang it up */
	c->tech_pvt = NULL;
	ast_hangup(c);
	return 0;
}


/*! \brief Handle incoming INVITE request
\note 	If the INVITE has a Replaces header, it is part of an
 *	attended transfer. If so, we do not go through the dial
 *	plan but tries to find the active call and masquerade
 *	into it 
 */
static int handle_request_invite(struct sip_dialog *p, struct sip_request *req, int debug, struct sockaddr_in *sin, int *recount, char *e)
{
	int res = 1;
	int gotdest;
	const char *p_replaces;
	char *replace_id = NULL;
	const char *required;
	unsigned int required_profile = 0;
	struct ast_channel *c = NULL;		/* New channel */

	/* Find out what they support */
	if (!p->sipoptions) {
		const char *supported = get_header(req, "Supported");
		if (!ast_strlen_zero(supported))
			parse_sip_options(p, supported);
	}

	/* Find out what they require */
	required = get_header(req, "Require");
	if (!ast_strlen_zero(required)) {
		required_profile = parse_sip_options(NULL, required);
		if (required_profile && required_profile != SIP_OPT_REPLACES) {
			/* At this point we only support REPLACES */
			transmit_response_with_unsupported(p, "420 Bad extension (unsupported)", req, required);
			ast_log(LOG_WARNING,"Received SIP INVITE with unsupported required extension: %s\n", required);
			if (!p->lastinvite)
				sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			return -1;
		}
	}

	/* Check if this is a loop */
	if (ast_test_flag(&p->flags[0], SIP_OUTGOING) && p->owner && (p->owner->_state != AST_STATE_UP)) {
		/* This is a call to ourself.  Send ourselves an error code and stop
	   	processing immediately, as SIP really has no good mechanism for
	   	being able to call yourself */
		/* we need to check the tags and the branch. If they're different, this is
	   	  in fact a forked call through a SIP proxy somewhere. */
		transmit_final_response(p, "482 Loop Detected", req, XMIT_RELIABLE);
		return 0;
	}
	
	/* Check if we already have a pending invite. If so, then deny this one */
	if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->pendinginvite) {
		/* We already have a pending invite. Sorry. You are on hold. */
		transmit_response(p, "491 Request Pending", req);
		if (option_debug)
			ast_log(LOG_DEBUG, "Got INVITE on call where we already have pending INVITE, deferring that - %s\n", p->callid);
		/* No destruction here, we have a current dialog */
		return 0;
	}

	p_replaces = get_header(req, "Replaces");
	if (!ast_strlen_zero(p_replaces)) {
		/* We have a replaces header */
		char *ptr;
		char *fromtag = NULL;
		char *totag = NULL;
		char *start, *to;
		int error = 0;

		if (p->owner) {
			if (option_debug > 2)
				ast_log(LOG_DEBUG, "INVITE w Replaces on existing call? Refusing action. [%s]\n", p->callid);
			transmit_response(p, "400 Bad request", req);	/* The best way to not not accept the transfer */
			/* Do not destroy existing call */
			return -1;
		}

		if (sipdebug && option_debug > 2)
			ast_log(LOG_DEBUG, "INVITE part of call transfer. Replaces [%s]\n", p_replaces);
		/* Create a buffer we can manipulate */
		replace_id = ast_strdupa(p_replaces);
		ast_uri_decode(replace_id);

		if (!p->refer && !sip_refer_allocate(p)) {
			append_history(p, "Xfer", "INVITE/Replace Failed. Out of memory.");
			transmit_final_response(p, "500 Server Internal Error", req, XMIT_RELIABLE);
			return -1;
		}

		/*  Todo: (When we find phones that support this)
			if the replaces header contains ";early-only"
			we can only replace the call in early
			stage, not after it's up.

			If it's not in early mode, 486 Busy.
		*/
		
		/* Skip leading whitespace */
		replace_id = ast_skip_blanks(replace_id);

		start = replace_id;
		while ( (ptr = strsep(&start, ";")) ) {
			ptr = ast_skip_blanks(ptr); /* XXX maybe unnecessary ? */
			if ( (to = strcasestr(ptr, "to-tag=") ) )
				totag = to + 7;	/* skip the keyword */
			else if ( (to = strcasestr(ptr, "from-tag=") ) ) {
				fromtag = to + 9;	/* skip the keyword */
				fromtag = strsep(&fromtag, "&"); /* trim what ? */
			}
		}

		if (sipdebug && option_debug > 3) 
			ast_log(LOG_DEBUG,"Invite/replaces: Will use Replace-Call-ID : %s Fromtag: %s Totag: %s\n", replace_id, fromtag ? fromtag : "<no from tag>", totag ? totag : "<no to tag>");


		/* Try to find call that we are replacing 
			If we have a Replaces  header, we need to cancel that call if we succeed with this call 
		*/
		if ((p->refer->refer_call = get_sip_dialog_byid_locked(replace_id, totag, fromtag)) == NULL) {
			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-existent call id (%s)!\n", replace_id);
			transmit_final_response(p, "481 Call leg Does not exit (Replaces)", req, XMIT_RELIABLE);
			error = 1;
		}

		/* At this point, bot the pvt and the owner of the call to be replaced is locked */

		/* The matched call is the call from the transferer to Asterisk .
			We want to bridge the bridged part of the call to the 
			incoming invite, thus taking over the refered call */

		if (p->refer->refer_call == p) {
			ast_log(LOG_NOTICE, "INVITE with replaces into it's own call id (%s == %s)!\n", replace_id, p->callid);
			p->refer->refer_call = NULL;
			transmit_final_response(p, "400 Bad request", req, XMIT_RELIABLE);
			error = 1;
		}

		if (!error && !p->refer->refer_call->owner) {
			/* Oops, someting wrong anyway, no owner, no call */
			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-existing call id (%s)!\n", replace_id);
			/* Check for better return code */
			transmit_final_response(p, "481 Call leg Does not exit (Replaces)", req, XMIT_RELIABLE);
			error = 1;
		}

		if (!error && p->refer->refer_call->owner->_state != AST_STATE_RING && p->refer->refer_call->owner->_state != AST_STATE_UP ) {
			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-ringing or active call id (%s)!\n", replace_id);
			transmit_final_response(p, "603 Declined (Replaces)", req, XMIT_RELIABLE);
			error = 1;
		}

		if (error) {	/* Give up this dialog */
			append_history(p, "Xfer", "INVITE/Replace Failed.");
			dialog_lock(p, FALSE);
			if (p->refer->refer_call) {
				dialog_lock(p->refer->refer_call, FALSE);
				ast_channel_unlock(p->refer->refer_call->owner);
			}
			return -1;
		}
	}


	/* Check if this is an INVITE that sets up a new dialog or
	   a re-invite in an existing dialog */

	if (!ast_test_flag(req, SIP_PKT_IGNORE)) {
		sip_cancel_destroy(p);
		/* This also counts as a pending invite */
		p->pendinginvite = req->seqno;
		check_via(p, req);

		if (!p->owner) {	/* Not a re-invite */
			/* Use this as the basis */
			copy_request(&p->initreq, req);
			if (debug)
				ast_verbose("Using INVITE request as basis request - %s\n", p->callid);
			append_history(p, "Invite", "New call: %s", p->callid);
			parse_ok_contact(p, req);
		} else {	/* Re-invite on existing call */
			/* Handle SDP here if we already have an owner */
			if (find_sdp(req)) {
				if (process_sdp(p, req)) {
					transmit_response(p, "488 Not acceptable here", req);
					if (!p->lastinvite)
						sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
					return -1;
				}
			} else {
				p->jointcapability = p->capability;
				if (option_debug)
					ast_log(LOG_DEBUG, "Hm....  No sdp for the moment\n");
			}
			if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY)) /* This is a response, note what it was for */
				append_history(p, "ReInv", "Re-invite received");
		}
	} else if (debug)
		ast_verbose("Ignoring this INVITE request\n");

	
	if (!p->lastinvite && !ast_test_flag(req, SIP_PKT_IGNORE) && !p->owner) {
		/* This is a new invite */
		/* Handle authentication if this is our first invite */
		res = check_user(p, req, SIP_INVITE, e, XMIT_RELIABLE, sin);
		if (res == AUTH_CHALLENGE_SENT)
			return 0; 
		if (res < 0) { /* Something failed in authentication */
			if (res == AUTH_FAKE_AUTH) {
				ast_log(LOG_NOTICE, "Sending fake auth rejection for user %s\n", get_header(req, "From"));
				transmit_fake_auth_response(p, req, 1);
			} else {
  				ast_log(LOG_NOTICE, "Failed to authenticate user %s\n", get_header(req, "From"));
				transmit_response_reliable(p, "403 Forbidden", req);
  			}
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			ast_string_field_free(p, theirtag);
			return 0;
		}

		/* We have a succesful authentication, process the SDP portion if there is one */
		if (find_sdp(req)) {
			if (process_sdp(p, req)) {
				/* Unacceptable codecs */
				transmit_final_response(p, "488 Not acceptable here", req, XMIT_RELIABLE);
				if (option_debug)
					ast_log(LOG_DEBUG, "No compatible codecs for this SIP call.\n");
				return -1;
			}
		} else {	/* No SDP in invite, call control session */
			p->jointcapability = p->capability;
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "No SDP in Invite, third party call control\n");
		}

		/* Initialize the context if it hasn't been already */
		if (ast_strlen_zero(p->context))
			ast_string_field_set(p, context, global.default_context);


		/* Check number of concurrent calls -vs- incoming limit HERE */
		if (option_debug)
			ast_log(LOG_DEBUG, "Checking SIP call limits for device %s\n", p->peername);
		if ((res = update_call_counter(p, INC_CALL_LIMIT))) {
			if (res < 0) {
				ast_log(LOG_NOTICE, "Failed to place call for user %s, too many calls\n", p->peername);
				transmit_final_response(p, "480 Temporarily Unavailable", req, XMIT_RELIABLE);
			}
			return 0;
		}
		gotdest = get_destination(p, NULL);	/* Get destination right away */
		get_rdnis(p, NULL);			/* Get redirect information */
		extract_uri(p, req);			/* Get the Contact URI */
		build_contact(p);			/* Build our contact header */
		if (p->rtp) {
			ast_rtp_setdtmf(p->rtp, ast_test_flag(&p->flags[0], SIP_DTMF) != SIP_DTMF_INFO);
			ast_rtp_setdtmfcompensate(p->rtp, ast_test_flag(&p->flags[1], SIP_PAGE2_RFC2833_COMPENSATE));
		}

		if (!replace_id && gotdest) {	/* No matching extension found */
			char *response;
			if (gotdest == 1 && ast_test_flag(&p->flags[1], SIP_PAGE2_ALLOWOVERLAP))
				response = "484 Address Incomplete";
			else
				response = "404 Not Found";
			transmit_final_response(p, response, req, XMIT_RELIABLE);
			update_call_counter(p, DEC_CALL_LIMIT);
		} else {
			/* If no extension was specified, use the s one */
			/* Basically for calling to IP/Host name only */
			if (ast_strlen_zero(p->exten))
				ast_string_field_set(p, exten, "s");
			/* Initialize our tag */	

			make_our_tag(p->tag, sizeof(p->tag));

			/* First invitation - create the channel */
			c = sip_new(p, AST_STATE_DOWN, S_OR(p->peername, NULL));
			*recount = 1;

			/* Save Record-Route for any later requests we make on this dialogue */
			build_route(p, req, 0);

			if (c) {
				/* Pre-lock the call */
				ast_channel_lock(c);
			}
		}
	} else {
		if (option_debug > 1 && sipdebug) {
			if (!ast_test_flag(req, SIP_PKT_IGNORE))
				ast_log(LOG_DEBUG, "Got a SIP re-invite for call %s\n", p->callid);
			else
				ast_log(LOG_DEBUG, "Got a SIP re-transmit of INVITE for call %s\n", p->callid);
		}
		c = p->owner;
	}

	if (!ast_test_flag(req, SIP_PKT_IGNORE) && p)
		p->lastinvite = req->seqno;

	if (replace_id) { 	/* Attended transfer or call pickup - we're the target */
		/* Go and take over the target call */
		if (sipdebug && option_debug > 3)
			ast_log(LOG_DEBUG, "Sending this call to the invite/replcaes handler %s\n", p->callid);
		return handle_invite_replaces(p, req, debug, sin);
	}


	if (c) {	/* We have a call  -either a new call or an old one (RE-INVITE) */
		switch(c->_state) {
		case AST_STATE_DOWN:
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "%s: New call is still down.... Trying... \n", c->name);
			transmit_response(p, "100 Trying", req);
			ast_setstate(c, AST_STATE_RING);
			if (strcmp(p->exten, ast_pickup_ext())) {	/* Call to extension -start pbx on this call */
				enum ast_pbx_result res;
				const char *response = NULL;

				res = ast_pbx_start(c);

				switch(res) {
				case AST_PBX_FAILED:
					ast_log(LOG_WARNING, "Failed to start PBX :(\n");
					response = "503 Unavailable";
					break;
				case AST_PBX_CALL_LIMIT:
					ast_log(LOG_WARNING, "Failed to start PBX (call limit reached) \n");
					response = "480 Temporarily Unavailable";
					break;
				case AST_PBX_SUCCESS:
					/* nothing to do */
					break;
				}
				if (response)
					transmit_final_response(p, response, req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);

				if (res) {
					/* Unlock locks so ast_hangup can do its magic */
					ast_channel_unlock(c);
					dialog_lock(p, FALSE);
					ast_hangup(c);
					dialog_lock(p, TRUE);
					c = NULL;
				}
			} else {	/* Pickup call in call group */
				ast_channel_unlock(c);
				if (ast_pickup_call(c)) {
					ast_log(LOG_NOTICE, "Nothing to pick up for %s\n", p->callid);
					transmit_final_response(p, "503 Unavailable", req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);
					ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
					/* Unlock locks so ast_hangup can do its magic */
					dialog_lock(p, FALSE);
					c->hangupcause = AST_CAUSE_CALL_REJECTED;
				} else {
					dialog_lock(p, FALSE);
					ast_setstate(c, AST_STATE_DOWN);
					c->hangupcause = AST_CAUSE_NORMAL_CLEARING;
				}
				ast_hangup(c);
				dialog_lock(p, TRUE);
				c = NULL;
			}
			break;
		case AST_STATE_RING:
			transmit_response(p, "100 Trying", req);
			if (!p->owner)
				dialogstatechange(p, DIALOG_STATE_PROCEEDING);
			break;
		case AST_STATE_RINGING:
			transmit_response(p, "180 Ringing", req);
			if (!p->owner)
				dialogstatechange(p, DIALOG_STATE_EARLY);
			break;
		case AST_STATE_UP:
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "%s: This call is UP.... \n", c->name);

			if (p->t38.state == T38_PEER_REINVITE) {
				struct ast_channel *bridgepeer = NULL;
				struct sip_dialog *bridgepvt = NULL;
				
				if ((bridgepeer = ast_bridged_channel(p->owner))) {
					/* We have a bridge, and this is re-invite to switchover to T38 so we send re-invite with T38 SDP, to other side of bridge*/
					/*! XXX: we should also check here does the other side supports t38 at all !!! XXX */
					if (!strcasecmp(bridgepeer->tech->type, "SIP")) { /* If we are bridged to SIP channel */
						bridgepvt = (struct sip_dialog*)bridgepeer->tech_pvt;
						if (bridgepvt->t38.state == T38_DISABLED) {
							if (bridgepvt->udptl) { /* If everything is OK with other side's udptl struct */
								/* Send re-invite to the bridged channel */
								sip_handle_t38_reinvite(bridgepeer, p, 1);
							} else { /* Something is wrong with peers udptl struct */
								ast_log(LOG_WARNING, "Strange... The other side of the bridge don't have udptl struct\n");
								dialog_lock(bridgepvt, TRUE);
								bridgepvt->t38.state = T38_DISABLED;
								dialog_lock(bridgepvt, FALSE);
								if (option_debug > 1)
									ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", bridgepvt->t38.state, bridgepeer->name);
								transmit_final_response(p, "488 Not Acceptable here", req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);
							}
						} else {
							/* The other side is already setup for T.38 most likely so we need to acknowledge this too */
							transmit_response_with_attachment(WITH_T38_SDP, p, "200 OK", req, XMIT_CRITICAL);
							dialogstatechange(p, DIALOG_STATE_CONFIRMED);
							p->t38.state = T38_ENABLED;
							if (option_debug)
								ast_log(LOG_DEBUG, "T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
						}
					} else {
						/* Other side is not a SIP channel */
						transmit_final_response(p, "488 Not Acceptable here", req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);
						p->t38.state = T38_DISABLED;
						if (option_debug > 1)
							ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
					}
				} else {
					/* we are not bridged in a call */
					transmit_response_with_attachment(WITH_T38_SDP, p, "200 OK", req, XMIT_CRITICAL);
					dialogstatechange(p, DIALOG_STATE_CONFIRMED);
					p->t38.state = T38_ENABLED;
					if (option_debug)
						ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
				}
			} else if (p->t38.state == T38_DISABLED) { /* Channel doesn't have T38 offered or enabled */
				int sendok = TRUE;

				/* If we are bridged to a channel that has T38 enabled than this is a case of RTP re-invite after T38 session */
				/* so handle it here (re-invite other party to RTP) */
				struct ast_channel *bridgepeer = NULL;
				struct sip_dialog *bridgepvt = NULL;
				if ((bridgepeer = ast_bridged_channel(p->owner))) {
					if (!strcasecmp(bridgepeer->tech->type, sip_tech.type)) {
						bridgepvt = (struct sip_dialog*)bridgepeer->tech_pvt;
						/* Does the bridged peer have T38 ? */
						if (bridgepvt->t38.state == T38_ENABLED) {
							ast_log(LOG_WARNING, "RTP re-invite after T38 session not handled yet !\n");
							/* Insted of this we should somehow re-invite the other side of the bridge to RTP */
							transmit_final_response(p, "488 Not Acceptable here (unsupported)", req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);
							sendok = FALSE;
						} 
						/* No bridged peer with T38 enabled*/
					}
				} 

				/* This is a normal call and we can accept it - let's rock and roll! */
				if (sendok)
					transmit_response_with_attachment(WITH_SDP, p, "200 OK", req, XMIT_CRITICAL);
				dialogstatechange(p, DIALOG_STATE_CONFIRMED);

			}
			break;
		default:
			ast_log(LOG_WARNING, "Don't know how to handle INVITE in state %d\n", c->_state);
			transmit_response(p, "100 Trying", req);
			break;
		}
	} else {
		if (p && (p->autokillid == -1)) {
			const char *msg;

			if (!p->jointcapability)
				msg = "488 Not Acceptable Here (codec error)";
			else {
				ast_log(LOG_NOTICE, "Unable to create/find SIP channel for this INVITE\n");
				msg = "503 Unavailable";
			}
			transmit_final_response(p, msg, req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);
		}
	}
	return res;
}

/*! \brief Handle incoming CANCEL request */
static int handle_request_cancel(struct sip_dialog *p, struct sip_request *req)
{
		
	check_via(p, req);
	ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
	
	if (p->owner && p->owner->_state == AST_STATE_UP) {
		/* This call is up, cancel is ignored, we need a bye */
		transmit_response(p, "200 OK", req);
		if (option_debug)
			ast_log(LOG_DEBUG, "Got CANCEL on an answered call. Ignoring... \n");
		return 0;
	}
	stop_media_flows(p);
	if (p->owner)
		ast_queue_hangup(p->owner);
	else
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
	if (p->initreq.len > 0) {
		transmit_response_reliable(p, "487 Request Terminated", &p->initreq);
		transmit_response(p, "200 OK", req);
		return 1;
	} else {
		transmit_response(p, "481 Call Leg Does Not Exist", req);
		return 0;
	}
}

/*! \brief Handle incoming BYE request */
static int handle_request_bye(struct sip_dialog *p, struct sip_request *req)
{
	struct ast_channel *c=NULL;
	int res;
	struct ast_channel *bridged_to;
	char *audioqos = NULL, *videoqos = NULL;
	
	if (p->pendinginvite && !ast_test_flag(&p->flags[0], SIP_OUTGOING) && !ast_test_flag(req, SIP_PKT_IGNORE))
		transmit_response_reliable(p, "487 Request Terminated", &p->initreq);

	copy_request(&p->initreq, req);
	check_via(p, req);
	ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	

	if (p->rtp) {
		audioqos = ast_rtp_get_quality(p->rtp);
		if (p->owner)
			pbx_builtin_setvar_helper(p->owner, "RTPAUDIOQOS", audioqos);
	}
	if (p->vrtp) {
		videoqos = ast_rtp_get_quality(p->vrtp);
		if (p->owner)
			pbx_builtin_setvar_helper(p->owner, "RTPVIDEOQOS", videoqos);
	}

	/* Get RTCP quality before end of call */
	if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY) || p->owner) {
		if (p->rtp)
			append_history(p, "RTCPaudio", "Quality:%s", audioqos);
		if (p->vrtp)
			append_history(p, "RTCPvideo", "Quality:%s", videoqos);
	}

	stop_media_flows(p);
	if (!ast_strlen_zero(get_header(req, "Also"))) {
		ast_log(LOG_NOTICE, "Client '%s' using deprecated BYE/Also transfer method.  Ask vendor to support REFER instead\n",
			ast_inet_ntoa(p->recv.sin_addr));
		if (ast_strlen_zero(p->context))
			ast_string_field_set(p, context, global.default_context);
		res = get_also_info(p, req);
		if (!res) {
			c = p->owner;
			if (c) {
				bridged_to = ast_bridged_channel(c);
				if (bridged_to) {
					/* Don't actually hangup here... */
					ast_queue_control(c, AST_CONTROL_UNHOLD);
					ast_async_goto(bridged_to, p->context, p->refer->refer_to,1);
				} else
					ast_queue_hangup(p->owner);
			}
		} else {
			ast_log(LOG_WARNING, "Invalid transfer information from '%s'\n", ast_inet_ntoa(p->recv.sin_addr));
			if (p->owner)
				ast_queue_hangup(p->owner);
		}
	} else if (p->owner) {
		ast_queue_hangup(p->owner);
		if (option_debug > 2)
			ast_log(LOG_DEBUG, "Received bye, issuing owner hangup\n.");
	} else {
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		if (option_debug > 2)
			ast_log(LOG_DEBUG, "Received bye, no owner, selfdestruct soon.\n.");
	}
	transmit_response(p, "200 OK", req);

	return 1;
}

/*! \brief Handle incoming MESSAGE request */
static int handle_request_message(struct sip_dialog *p, struct sip_request *req)
{
	if (!ast_test_flag(req, SIP_PKT_IGNORE)) {
		if (ast_test_flag(req, SIP_PKT_DEBUG))
			ast_verbose("Receiving message!\n");
		receive_message(p, req);
	} else
		transmit_final_response(p, "202 Accepted", req, XMIT_UNRELIABLE);
	return 1;
}

/*! \brief  Handle incoming SUBSCRIBE request */
static int handle_request_subscribe(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e)
{
	int gotdest;
	int res = 0;
	int firststate = AST_EXTENSION_REMOVED;
	struct sip_peer *authpeer = NULL;
	const char *event = get_header(req, "Event");	/* Get Event package name */
	const char *accept = get_header(req, "Accept");
	int resubscribe = (p->subscribed != NONE);
	static int subscribe_counter = 0;

	if (p->initreq.headers) {	
		/* We already have a dialog */
		if (p->initreq.method != SIP_SUBSCRIBE) {
			/* This is a SUBSCRIBE within another SIP dialog, which we do not support */
			/* For transfers, this could happen, but since we haven't seen it happening, let us just refuse this */
 			transmit_response(p, "403 Forbidden (within dialog)", req);
			/* Do not destroy session, since we will break the call if we do */
			if (option_debug)
				ast_log(LOG_DEBUG, "Got a subscription within the context of another call, can't handle that - %s (Method %s)\n", p->callid, sip_method2txt(p->initreq.method));
			return 0;
		} else if (ast_test_flag(req, SIP_PKT_DEBUG)) {
			if (option_debug) {
				if (resubscribe)
					ast_log(LOG_DEBUG, "Got a re-subscribe on existing subscription %s\n", p->callid);
				else
					ast_log(LOG_DEBUG, "Got a new subscription %s (possibly with auth)\n", p->callid);
			}
		}
	}

	/* Check if we have a global disallow setting on subscriptions. 
		if so, we don't have to check peer/user settings after auth, which saves a lot of processing
	*/
	if (!global.allowsubscribe) {
		transmit_final_response(p, "403 Forbidden (policy)", req, XMIT_UNRELIABLE);
		return 0;
	}
	subscribe_counter ++;
	if (option_debug > 2)
		ast_log(LOG_DEBUG, "-SUBSCRIPTIONS- Concurrent counter: %d\n", subscribe_counter);


	if (!ast_test_flag(req, SIP_PKT_IGNORE) && !p->initreq.headers) {	/* Set up dialog, new subscription */
		/* Use this as the basis */
		if (ast_test_flag(req, SIP_PKT_DEBUG))
			ast_verbose("Creating new subscription\n");

		/* This call is no longer outgoing if it ever was */
		ast_clear_flag(&p->flags[0], SIP_OUTGOING);
		copy_request(&p->initreq, req);
		check_via(p, req);
	} else if (ast_test_flag(req, SIP_PKT_DEBUG) && ast_test_flag(req, SIP_PKT_IGNORE))
		ast_verbose("Ignoring this SUBSCRIBE request\n");

	/* Find parameters to Event: header value and remove them for now */
	event = strsep((char **)&event, ";");	/* XXX bug here, overwrite string */

	/* Handle authentication if this is our first subscribe */
	res = check_user_full(p, req, SIP_SUBSCRIBE, e, 0, sin, &authpeer);
	/* if an authentication response was sent, we are done here */
	if (res == AUTH_CHALLENGE_SENT) {
		if (authpeer)
			ASTOBJ_UNREF(authpeer, sip_destroy_device);
		subscribe_counter--;
		return 0;
	}
	if (res < 0) {
		if (res == AUTH_FAKE_AUTH) {
			ast_log(LOG_NOTICE, "Sending fake auth rejection for user %s\n", get_header(req, "From"));
			transmit_fake_auth_response(p, req, 1);
		} else {
			ast_log(LOG_NOTICE, "Failed to authenticate user %s for SUBSCRIBE\n", get_header(req, "From"));
			transmit_final_response(p, "403 Forbidden", req, XMIT_UNRELIABLE);
		}
		if (authpeer)
			ASTOBJ_UNREF(authpeer, sip_destroy_device);
		subscribe_counter--;
		return 0;
	}

	/* Check if this user/peer is allowed to subscribe at all */
	if (!ast_test_flag(&p->flags[1], SIP_PAGE2_ALLOWSUBSCRIBE)) {
		transmit_final_response(p, "403 Forbidden (policy)", req, XMIT_UNRELIABLE);
		if (authpeer)
			ASTOBJ_UNREF(authpeer, sip_destroy_device);
		subscribe_counter--;
		return 0;
	}

	/* Get destination right away */
	gotdest = get_destination(p, NULL);

	/* Initialize the context if it hasn't been already;
	   note this is done _after_ handling any domain lookups,
	   because the context specified there is for calls, not
	   subscriptions
	*/
	if (!ast_strlen_zero(p->subscribecontext))
		ast_string_field_set(p, context, p->subscribecontext);
	else if (ast_strlen_zero(p->context))
		ast_string_field_set(p, context, global.default_context);

	build_contact(p);
	if (gotdest) {
		transmit_final_response(p, "404 Not Found", req, XMIT_UNRELIABLE);
		if (authpeer)
			ASTOBJ_UNREF(authpeer, sip_destroy_device);
		subscribe_counter--;
		return 0;
	} else {
		/* XXX reduce nesting here */
		/* Initialize tag for new subscriptions */	
		if (ast_strlen_zero(p->tag))
			make_our_tag(p->tag, sizeof(p->tag));

		if (!strcmp(event, "presence") || !strcmp(event, "dialog")) { /* Presence, RFC 3842 */
			if (authpeer)
				ASTOBJ_UNREF(authpeer, sip_destroy_device);

			/* Header from Xten Eye-beam Accept: multipart/related, application/rlmi+xml, application/pidf+xml, application/xpidf+xml */
			/* Polycom phones only handle xpidf+xml, even if they say they can
			   handle pidf+xml as well
			*/
			if (strstr(p->useragent, "Polycom")) {
				p->subscribed = XPIDF_XML;
			} else if (strstr(accept, "application/pidf+xml")) {
 				p->subscribed = PIDF_XML;         /* RFC 3863 format */
 			} else if (strstr(accept, "application/dialog-info+xml")) {
 				p->subscribed = DIALOG_INFO_XML;
 				/* IETF draft: draft-ietf-sipping-dialog-package-05.txt */
 			} else if (strstr(accept, "application/cpim-pidf+xml")) {
 				p->subscribed = CPIM_PIDF_XML;    /* RFC 3863 format */
 			} else if (strstr(accept, "application/xpidf+xml")) {
 				p->subscribed = XPIDF_XML;        /* Early pre-RFC 3863 format with MSN additions (Microsoft Messenger) */
			} else {
 				/* Can't find a format for events that we know about */
				transmit_final_response(p, "489 Bad Event", req, XMIT_UNRELIABLE);
				subscribe_counter--;
 				return 0;
 			}
 		} else if (!strcmp(event, "message-summary")) { 
			char *resp = NULL;
			int error = FALSE;
			if (!ast_strlen_zero(accept) && strcmp(accept, "application/simple-message-summary")) {
				/* Format requested that we do not support */
				resp = "406 Not acceptable";
				if (option_debug > 1)
					ast_log(LOG_DEBUG, "Received SIP mailbox subscription for unknown format: %s\n", accept);
			}
			/* Looks like they actually want a mailbox status 
			  This version of Asterisk supports mailbox subscriptions
			  The subscribed URI needs to exist in the dial plan
			  In most devices, this is configurable to the voicemailmain extension you use
			*/
			if (!authpeer || ast_strlen_zero(authpeer->mailbox)) {
				resp = "404 Not found (no mailbox)";
				ast_log(LOG_NOTICE, "Received SIP subscribe for peer without mailbox: %s\n", authpeer ? authpeer->name : "<no peername>");
				return 0;
			}
			if (error) {
				transmit_final_response(p, resp, req, XMIT_UNRELIABLE);
				if (authpeer)
					ASTOBJ_UNREF(authpeer, sip_destroy_device);
				subscribe_counter--;
				return 0;
			}

 			p->subscribed = MWI_NOTIFICATION;
			if (authpeer->mwipvt && authpeer->mwipvt != p)	/* Destroy old PVT if this is a new one */
				/* We only allow one subscription per peer */
				sip_destroy(authpeer->mwipvt);
			authpeer->mwipvt = p;		/* Link from peer to pvt */
			p->relatedpeer = authpeer;	/* Link from pvt to peer */
		} else { /* At this point, Asterisk does not understand the specified event */
			transmit_final_response(p, "489 Bad Event", req, XMIT_UNRELIABLE);
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "Received SIP subscribe for unknown event package: %s\n", event);
			if (authpeer)
				ASTOBJ_UNREF(authpeer, sip_destroy_device);
			subscribe_counter--;
			return 0;
		}
		/* Now, subscribe to status events from the PBX core */
		if (p->subscribed != MWI_NOTIFICATION && !resubscribe)
			p->stateid = ast_extension_state_add(p->context, p->exten, cb_extensionstate, p);
	}

	if (!ast_test_flag(req, SIP_PKT_IGNORE) && p)
		p->lastinvite = req->seqno;

	p->expiry = atoi(get_header(req, "Expires"));
	if (p->expiry < expiry.min_expiry && p->expiry > 0) {
		transmit_response_with_attachment(WITH_MINEXPIRY, p, "423 Interval too small", req, XMIT_UNRELIABLE);
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		subscribe_counter--;
		return 0;
	}
	

	/* SKREP check dialog state instead of NEEDDESTROY */
	if (p && p->state < DIALOG_STATE_TERMINATED) {
	// if (p && !ast_test_flag(&p->flags[0], SIP_NEEDDESTROY)) {

		/* check if the requested expiry-time is within the approved limits from sip.conf */
		if (p->expiry > expiry.max_expiry)
			p->expiry = expiry.max_expiry;

		if (sipdebug || option_debug > 1) {
			if (p->subscribed == MWI_NOTIFICATION && p->relatedpeer)
				ast_log(LOG_DEBUG, "Adding subscription for mailbox notification - peer %s Mailbox %s\n", p->relatedpeer->name, p->relatedpeer->mailbox);
			else
				ast_log(LOG_DEBUG, "Adding subscription for extension %s context %s for peer %s\n", p->exten, p->context, p->peername);
		}
		if (p->autokillid > -1)
			sip_cancel_destroy(p);	/* Remove subscription expiry for renewals */
		if (p->expiry > 0)
			sip_scheddestroy(p, (p->expiry + 10) * 1000);	/* Set timer for destruction of call at expiration */

		if (p->subscribed == MWI_NOTIFICATION) {
			transmit_response(p, "200 OK", req);
			if (p->relatedpeer) {	/* Send first notification */
				ASTOBJ_WRLOCK(p->relatedpeer);
				sip_send_mwi_to_peer(p->relatedpeer);
				ASTOBJ_UNLOCK(p->relatedpeer);
			}
		} else {
			if ((firststate = ast_extension_state(NULL, p->context, p->exten)) < 0) {

				ast_log(LOG_ERROR, "Got SUBSCRIBE for extension %s@%s from %s, but there is no hint for that extension\n", p->exten, p->context, ast_inet_ntoa(p->sa.sin_addr));
				transmit_final_response(p, "404 Not Found", req, XMIT_UNRELIABLE);
				subscribe_counter--;
				return 0;
			} 
			struct sip_dialog *p_old;

			transmit_response(p, "200 OK", req);
			dialogstatechange(p, DIALOG_STATE_CONFIRMED);
			transmit_state_notify(p, firststate, 1, FALSE);	/* Send first notification */
			append_history(p, "Subscribestatus", "%s", ast_extension_state2str(firststate));
			/* hide the 'complete' exten/context in the refer_to field for later display */
			ast_string_field_build(p, subscribeuri, "%s@%s", p->exten, p->context);

			/* remove any old subscription from this peer for the same exten/context,
		   	as the peer has obviously forgotten about it and it's wasteful to wait
		   	for it to expire and send NOTIFY messages to the peer only to have them
		   	ignored (or generate errors)
			*/
			dialoglist_lock();
			for (p_old = dialoglist; p_old; p_old = p_old->next) {
				if (p_old == p)
					continue;
				if (p_old->initreq.method != SIP_SUBSCRIBE)
					continue;
				if (p_old->subscribed == NONE)
					continue;
				dialog_lock(p_old, TRUE);
				if (!strcmp(p_old->peername, p->peername)) {
					if (!strcmp(p_old->exten, p->exten) &&
					    !strcmp(p_old->context, p->context)) {
						ast_set_flag(&p_old->flags[0], SIP_NEEDDESTROY);
						dialog_lock(p_old, FALSE);
						break;
					}
				}
				dialog_lock(p_old, FALSE);
			}
			dialoglist_unlock();
		}
		if (!p->expiry)
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
	}
	subscribe_counter--;
	return 1;
}

/*! \brief Handle incoming REGISTER request */
static int handle_request_register(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e)
{
	enum check_auth_result res;

	static int register_counter = 0;

	register_counter ++;
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "-REGISTRATIONS- register counter %d\n", register_counter);

	/* Use this as the basis */
	if (ast_test_flag(req, SIP_PKT_DEBUG))
		ast_verbose("Using latest REGISTER request as basis request\n");
	copy_request(&p->initreq, req);
	check_via(p, req);
	if ((res = register_verify(p, sin, req, e)) < 0) {
		const char *reason = "";

		switch (res) {
		case AUTH_SECRET_FAILED:
			reason = "Wrong password";
			break;
		case AUTH_USERNAME_MISMATCH:
			reason = "Username/auth name mismatch";
			break;
		case AUTH_NOT_FOUND:
			reason = "No matching peer found";
			break;
		case AUTH_UNKNOWN_DOMAIN:
			reason = "Not a local domain";
			break;
		default:
			break;
		}
		ast_log(LOG_NOTICE, "Registration from '%s' failed for '%s' - %s\n",
			get_header(req, "To"), ast_inet_ntoa(sin->sin_addr),
			reason);
	}
	if (res < 1) {
		/* Destroy the session, but keep us around for just a bit in case they don't
		   get our 200 OK */
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
	}
	append_history(p, "RegRequest", "%s : Account %s", res ? "Failed": "Succeeded", get_header(req, "To"));
	register_counter--;
	return res;
}

/*! \brief Handle incoming SIP requests (methods) 
\note	This is where all incoming requests go first   */
/* called with p and p->owner locked */
GNURK int handle_request(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, int *recount, int *nounlock)
{
	/* Called with p->lock held, as well as p->owner->lock if appropriate, keeping things
	   relatively static */
	struct sip_request resp;
	const char *cmd;
	const char *cseq;
	const char *useragent;
	int len;
	int respid;
	int res = 0;
	int debug = sip_debug_test_pvt(p);
	char *e;
	int error = 0;

	/* Clear out potential response */
	memset(&resp, 0, sizeof(resp));

	/* Get Method and Cseq */
	cseq = req->cseqheader;
	cmd = req->header[0];

	/* Must have Cseq */
	if (ast_strlen_zero(cmd) || ast_strlen_zero(cseq)) {
		ast_log(LOG_ERROR, "Missing Cseq. Dropping this SIP message, it's incomplete.\n");
		error = 1;
	} else {
		int seqno;
		/* Can we do this earlier in parse_request? */
		if (!error && sscanf(cseq, "%d%n", &seqno, &len) != 1) {
			ast_log(LOG_ERROR, "No seqno in '%s'. Dropping incomplete message.\n", cmd);
			error = 1;
		}
	}

	if (error) {
		if (!p->initreq.header)	/* New call */
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	/* Make sure we destroy this dialog */
		return -1;
	}

	/* Get the command XXX */

	cmd = req->rlPart1;
	e = req->rlPart2;

	/* Save useragent of the client */
	useragent = get_header(req, "User-Agent");
	if (!ast_strlen_zero(useragent))
		ast_string_field_set(p, useragent, useragent);

	/* Find out SIP method for incoming request */
	if (req->method == SIP_RESPONSE) {	/* Response to our request */
		/* Response to our request -- Do some sanity checks */	
		if (!p->initreq.headers) {
			if (option_debug)
				ast_log(LOG_DEBUG, "That's odd...  Got a response on a call we dont know about. Cseq %d Cmd %s\n", req->seqno, cmd);
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
			return 0;
		} else if (p->ocseq < req->seqno) {
			if (option_debug)
				ast_log(LOG_DEBUG, "Ignoring out of order response %d (expecting %d)\n", req->seqno, p->ocseq);
			return -1;
		} else if (p->ocseq != req->seqno) {
			/* ignore means "don't do anything with it" but still have to 
			   respond appropriately  
				In fact, it really means that we have to resend the response
				but in this version of chan_sip we haven't got it in memory...
			*/
			ast_set_flag(req, SIP_PKT_IGNORE);
			ast_set_flag(req, SIP_PKT_IGNORE_RESP);
			append_history(p, "Ignore", "Ignoring this retransmit\n");
		}
	
		e = ast_skip_blanks(e);
		if (sscanf(e, "%d %n", &respid, &len) != 1) {
			ast_log(LOG_WARNING, "Invalid response: '%s'\n", e);
		} else {
			/* More SIP ridiculousness, we have to ignore bogus contacts in 100 etc responses */
			if ((respid == 200) || ((respid >= 300) && (respid <= 399)))
				extract_uri(p, req);
			handle_response(p, respid, e + len, req);
		}
		return 0;
	}

	/* New SIP request coming in 
	   (could be new request in existing SIP dialog as well...) 
	 */			
	
	p->method = req->method;	/* Find out which SIP method they are using */
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "**** Received %s - Command in SIP %s\n", sip_method2txt(p->method), cmd); 

	if (p->icseq && (p->icseq > req->seqno)) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Ignoring too old SIP packet packet %d (expecting >= %d)\n", req->seqno, p->icseq);
		if (req->method != SIP_ACK)
			transmit_response(p, "503 Server error", req);	/* We must respond according to RFC 3261 sec 12.2 */
		return -1;
	} else if (p->icseq &&
		   p->icseq == req->seqno &&
		   req->method != SIP_ACK &&
		   (p->method != SIP_CANCEL || ast_test_flag(&p->flags[0], SIP_ALREADYGONE))) {
		/* ignore means "don't do anything with it" but still have to 
		   respond appropriately.  We do this if we receive a repeat of
		   the last sequence number  */
		ast_set_flag(req, SIP_PKT_IGNORE);
		ast_set_flag(req, SIP_PKT_IGNORE_REQ);
		if (option_debug > 2)
			ast_log(LOG_DEBUG, "Ignoring SIP message because of retransmit (%s Seqno %d, ours %d)\n", sip_method2txt(p->method), p->icseq, req->seqno);
	}
		
	if (req->seqno >= p->icseq)
		/* Next should follow monotonically (but not necessarily 
		   incrementally -- thanks again to the genius authors of SIP --
		   increasing */
		p->icseq = req->seqno;

	/* Find their tag if we haven't got it */
	if (ast_strlen_zero(p->theirtag)) {
		char tag[128];

		gettag(req->from, tag, sizeof(tag));
		ast_string_field_set(p, theirtag, tag);
	}
	snprintf(p->lastmsg, sizeof(p->lastmsg), "Rx: %s", cmd);

	/* If this is a request packet without a from tag, it's not
		correct according to RFC 3261  */
	/* Check if this a new request in a new dialog with a totag already attached to it,
		RFC 3261 - section 12.2 - and we don't want to mess with recovery  */

	if (!p->initreq.headers && ast_test_flag(req, SIP_PKT_WITH_TOTAG)) {
		/* If this is a first request and it got a to-tag, it is not for us */
		if (!ast_test_flag(req, SIP_PKT_IGNORE) && req->method == SIP_INVITE)
			transmit_response_reliable(p, "481 Call/Transaction Does Not Exist", req);
		else if (req->method != SIP_ACK)
			transmit_response(p, "481 Call/Transaction Does Not Exist", req);
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		return res;
	}

	/* Handle various incoming SIP methods in requests */
	switch (p->method) {
	case SIP_OPTIONS:
		res = handle_request_options(p, req);
		break;
	case SIP_INVITE:
		res = handle_request_invite(p, req, debug, sin, recount, e);
		break;
	case SIP_REFER:
		res = handle_request_refer(p, req, debug, req->seqno, nounlock);
		break;
	case SIP_CANCEL:
		res = handle_request_cancel(p, req);
		break;
	case SIP_BYE:
		res = handle_request_bye(p, req);
		break;
	case SIP_MESSAGE:
		res = handle_request_message(p, req);
		break;
	case SIP_SUBSCRIBE:
		res = handle_request_subscribe(p, req, sin, e);
		break;
	case SIP_REGISTER:
		res = handle_request_register(p, req, sin, e);
		break;
	case SIP_INFO:
		handle_request_info(p, req);
		break;
	case SIP_NOTIFY:
		res = handle_request_notify(p, req, sin, e);
		break;
	case SIP_ACK:
		/* Make sure we don't ignore this */
		/* ACK on 200 OK */
		if (req->seqno == p->pendinginvite) {
			p->pendinginvite = 0;
			__sip_ack(p, req->seqno, SIP_PKT_RESPONSE, 0, FALSE);
			if (find_sdp(req)) {
				if (process_sdp(p, req))
					return -1;
			} 
			check_pendings(p);
		}
		/* Got an ACK that we did not match with active dialog. 
		   We have given a final response */
		if (!p->lastinvite && ast_strlen_zero(p->randdata))
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
		break;
	default:
		transmit_response_with_attachment(WITH_ALLOW, p, "501 Method Not Implemented", req, XMIT_UNRELIABLE);
		ast_log(LOG_NOTICE, "Unknown SIP command '%s' from '%s'\n", 
			cmd, ast_inet_ntoa(p->sa.sin_addr));
		/* If this is some new method, and we don't have a call, destroy it now */
		if (!p->initreq.headers)
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
		break;
	}
	return res;
}

/*! \brief Send message waiting indication to alert peer that they've got voicemail */
static int sip_send_mwi_to_peer(struct sip_peer *peer)
{
	/* Called with devicelist lock, but releases it */
	struct sip_dialog *p;
	int newmsgs, oldmsgs;

	/* Check for messages */
	ast_app_inboxcount(peer->mailbox, &newmsgs, &oldmsgs);
	
	peer->lastmsgcheck = time(NULL);
	
	/* Return now if it's the same thing we told them last time */
	if (((newmsgs << 8) | (oldmsgs)) == peer->lastmsgssent) {
		return 0;
	}
	
	
	peer->lastmsgssent = ((newmsgs << 8) | (oldmsgs));

	if (peer->mwipvt) {
		/* Base message on subscription */
		p = peer->mwipvt;
	} else {
		/* Build temporary dialog for this message */
		if (!(p = sip_alloc(NULL, NULL, FALSE, SIP_NOTIFY))) 
			return -1;
		if (create_addr_from_peer(p, peer)) {
			/* Maybe they're not registered, etc. */
			sip_destroy(p);
			return 0;
		}
		/* Recalculate our side, and recalculate Call ID */
		if (sip_ouraddrfor(&p->sa.sin_addr, &p->ourip))
			p->ourip = sipnet.__ourip;
		build_via(p, FALSE);
		build_callid_pvt(p);
		/* Destroy this session after 32 secs */
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
	}
	/* Send MWI */
	ast_set_flag(&p->flags[0], SIP_OUTGOING);
	transmit_notify_with_mwi(p, newmsgs, oldmsgs, peer->vmexten);
	return 0;
}

/*! \brief Check whether peer needs a new MWI notification check */
static int does_peer_need_mwi(struct sip_peer *peer)
{
	time_t t = time(NULL);

	if (ast_test_flag(&peer->flags[1], SIP_PAGE2_SUBSCRIBEMWIONLY) &&
	    !peer->mwipvt) {	/* We don't have a subscription */
		peer->lastmsgcheck = t;	/* Reset timer */
		return FALSE;
	}

	if (!ast_strlen_zero(peer->mailbox) && (t - peer->lastmsgcheck) > global.mwitime)
		return TRUE;

	return FALSE;
}


/*! \brief Check if we need to send RTP keepalive or hangup, due to RTP timers */
static void check_rtp_timeout(struct sip_dialog *sip, time_t t)
{
	/* Do we have a channel that is UP and do we handle RTP inside the box? */
	if (!(sip->rtp && sip->owner && (sip->owner->_state == AST_STATE_UP) &&
	    !sip->redirip.sin_addr.s_addr) )
		return;

	/* Do we need to sent RTP keepalive ? */
	if (sip->lastrtptx && sip->rtpkeepalive &&
	    (t > sip->lastrtptx + sip->rtpkeepalive)) {
		/* Need to send an empty RTP packet */
		sip->lastrtptx = time(NULL);
		ast_rtp_sendcng(sip->rtp, 0);
	}

	if (sip->lastrtprx && (sip->rtptimeout || sip->rtpholdtimeout) &&
	    (t > sip->lastrtprx + sip->rtptimeout)) {
		/* Might be a timeout now -- see if we're on hold */
		struct sockaddr_in sin;
		ast_rtp_get_peer(sip->rtp, &sin);
		if (sin.sin_addr.s_addr || 
		    (sip->rtpholdtimeout && (t > sip->lastrtprx + sip->rtpholdtimeout))) {
			/* Needs a hangup */
			if (!sip->rtptimeout)
				return;
			while (sip->owner && ast_channel_trylock(sip->owner)) {
				dialog_lock(sip, FALSE);
				usleep(1);
				dialog_lock(sip, TRUE);
			}
			if (!sip->owner) 
				return;

			if (ast_rtp_get_bridged(sip->rtp)) 
				ast_log(LOG_NOTICE, "'%s' will not be disconnected in %ld seconds because it is directly bridged to another RTP stream\n", sip->owner->name, (long) (t - sip->lastrtprx));
			else {
				ast_log(LOG_NOTICE, "Disconnecting call '%s' for lack of RTP activity in %ld seconds\n",
					sip->owner->name,
					(long) (t - sip->lastrtprx));
				/* Issue a softhangup */
				ast_softhangup_nolock(sip->owner, AST_SOFTHANGUP_DEV);
			} 
			ast_channel_unlock(sip->owner);
			/* forget the timeouts for this call, since a hangup
			   has already been requested and we don't want to
			   repeatedly request hangups
			*/
			sip->rtptimeout = 0;
			sip->rtpholdtimeout = 0;
		}
	}
}

/*! \brief The SIP monitoring thread 
\note	This thread monitors all the SIP sessions and peers that needs notification of mwi
	(and thus do not have a separate thread) indefinitely 
*/
static void *do_monitor(void *data)
{
	int res;
	struct sip_dialog *sip;
	struct sip_peer *peer = NULL;
	time_t t;
	int fastrestart = FALSE;
	int lastpeernum = -1;
	int curpeernum;
	int reloading;

	/* Add an I/O event to our SIP UDP socket */
	if (sipsocket_initialized())
		sipnet.read_id = ast_io_add(io, sipnet.sipsock, sipsock_read, AST_IO_IN, NULL);
	
	/* From here on out, we die whenever asked */
	for(;;) {
		/* Check for a reload request */
		ast_mutex_lock(&sip_reload_lock);
		reloading = sip_reloading;
		sip_reloading = FALSE;
		ast_mutex_unlock(&sip_reload_lock);
		if (reloading) {
			if (option_verbose > 0)
				ast_verbose(VERBOSE_PREFIX_1 "Reloading SIP\n");
			sip_do_reload(sip_reloadreason);

			/* Change the I/O fd of our UDP socket */
			if (sipsocket_initialized())
				sipnet.read_id = ast_io_change(io, sipnet.read_id, sipnet.sipsock, NULL, 0, NULL);
		}
		/* Check for interfaces needing to be killed */
		dialoglist_lock();
restartsearch:		
		t = time(NULL);
		/* don't scan the interface list if it hasn't been a reasonable period
		   of time since the last time we did it (when MWI is being sent, we can
		   get back to this point every millisecond or less)
		*/
		for (sip = dialoglist; !fastrestart && sip; sip = sip->next) {
			dialog_lock(sip, TRUE);
			/* Check RTP timeouts and kill calls if we have a timeout set and do not get RTP */
			check_rtp_timeout(sip, t);
			/* If we have sessions that needs to be destroyed, do it now */
			if (ast_test_flag(&sip->flags[0], SIP_NEEDDESTROY) && !sip->packets &&
			    !sip->owner) {
				dialog_lock(sip, FALSE);
				__sip_destroy(sip, TRUE, FALSE);
				goto restartsearch;
			}
			dialog_lock(sip, FALSE);
		}
		dialoglist_unlock();

		pthread_testcancel();
		/* Wait for sched or io */
		res = ast_sched_wait(sched);
		if ((res < 0) || (res > 1000))
			res = 1000;
		/* If we might need to send more mailboxes, don't wait long at all.*/
		if (fastrestart)
			res = 1;
		res = ast_io_wait(io, res);
		if (option_debug && res > 20)
			ast_log(LOG_DEBUG, "chan_sip: ast_io_wait ran %d all at once\n", res);
		ast_mutex_lock(&monlock);
		if (res >= 0)  {
			res = ast_sched_runq(sched);
			if (option_debug && res >= 20)
				ast_log(LOG_DEBUG, "chan_sip: ast_sched_runq ran %d all at once\n", res);
		}

		/* Send MWI notifications to peers - static and cached realtime peers */
		t = time(NULL);
		fastrestart = FALSE;
		curpeernum = 0;
		peer = NULL;
		/* Find next peer that needs mwi */
		ASTOBJ_CONTAINER_TRAVERSE(&devicelist, !peer, do {
			if ((curpeernum > lastpeernum) && does_peer_need_mwi(iterator)) {
				fastrestart = TRUE;
				lastpeernum = curpeernum;
				peer = ASTOBJ_REF(iterator);
			};
			curpeernum++;
		} while (0)
		);
		/* Send MWI to the peer */
		if (peer) {
			ASTOBJ_WRLOCK(peer);
			sip_send_mwi_to_peer(peer);
			ASTOBJ_UNLOCK(peer);
			ASTOBJ_UNREF(peer,sip_destroy_device);
		} else {
			/* Reset where we come from */
			lastpeernum = -1;
		}
		ast_mutex_unlock(&monlock);
	}
	/* Never reached */
	return NULL;
	
}

/*! \brief Start the channel monitor thread */
static int restart_monitor(void)
{
	/* If we're supposed to be stopped -- stay stopped */
	if (monitor_thread == AST_PTHREADT_STOP)
		return 0;
	ast_mutex_lock(&monlock);
	if (monitor_thread == pthread_self()) {
		ast_mutex_unlock(&monlock);
		ast_log(LOG_WARNING, "Cannot kill myself\n");
		return -1;
	}
	if (monitor_thread != AST_PTHREADT_NULL) {
		/* Wake up the thread */
		pthread_kill(monitor_thread, SIGURG);
	} else {
		/* Start a new monitor */
		if (ast_pthread_create_background(&monitor_thread, NULL, do_monitor, NULL) < 0) {
			ast_mutex_unlock(&monlock);
			ast_log(LOG_ERROR, "Unable to start monitor thread.\n");
			return -1;
		}
	}
	ast_mutex_unlock(&monlock);
	return 0;
}

/*! \brief Part of PBX channel interface
\note
\par	Return values:---

	If we have qualify on and the device is not reachable, regardless of registration
	state we return AST_DEVICE_UNAVAILABLE

	For peers with call limit:
		- not registered			AST_DEVICE_UNAVAILABLE
		- registered, no call			AST_DEVICE_NOT_INUSE
		- registered, active calls		AST_DEVICE_INUSE
		- registered, call limit reached	AST_DEVICE_BUSY
	For peers without call limit:
		- not registered			AST_DEVICE_UNAVAILABLE
		- registered				AST_DEVICE_NOT_INUSE
		- fixed IP (!dynamic)			AST_DEVICE_NOT_INUSE

	If we return AST_DEVICE_UNKNOWN, the device state engine will try to find
	out a state by walking the channel list.
*/
static int sip_devicestate(void *data)
{
	char *host;
	char *tmp;

	struct hostent *hp;
	struct ast_hostent ahp;
	struct sip_peer *p;

	int res = AST_DEVICE_INVALID;

	/* make sure data is not null. Maybe unnecessary, but better be safe */
	host = ast_strdupa(data ? data : "");
	if ((tmp = strchr(host, '@')))
		host = tmp + 1;

	if (option_debug > 2) 
		ast_log(LOG_DEBUG, "Checking device state for peer %s\n", host);

	if ((p = find_device(host, NULL, 1))) {
		if (p->addr.sin_addr.s_addr || p->defaddr.sin_addr.s_addr) {
			/* we have an address for the peer */
			/* if qualify is turned on, check the status */
			if (p->maxms && (p->lastms > p->maxms)) {
				res = AST_DEVICE_UNAVAILABLE;
			} else {
				/* qualify is not on, or the peer is responding properly */
				/* check call limit */
				if (p->call_limit && (p->inUse == p->call_limit))
					res = AST_DEVICE_BUSY;
				else if (p->call_limit && p->inUse)
					res = AST_DEVICE_INUSE;
				else
					res = AST_DEVICE_NOT_INUSE;
				if (p->onHold)
					res = AST_DEVICE_ONHOLD;
				else if (p->inRinging) {
					if (p->inRinging == p->inUse)
						res = AST_DEVICE_RINGING;
					else
						res = AST_DEVICE_RINGINUSE;
				}
			}
		} else {
			/* there is no address, it's unavailable */
			res = AST_DEVICE_UNAVAILABLE;
		}
		ASTOBJ_UNREF(p,sip_destroy_device);
	} else {
		hp = ast_gethostbyname(host, &ahp);
		if (hp)
			res = AST_DEVICE_UNKNOWN;
	}

	return res;
}

/*! \brief PBX interface function -build SIP pvt structure 
	SIP calls initiated by the PBX arrive here */
static struct ast_channel *sip_request_call(const char *type, int format, void *data, int *cause)
{
	int oldformat;
	struct sip_dialog *p;
	struct ast_channel *tmpc = NULL;
	char *ext, *host;
	char tmp[256];
	char *dest = data;

	oldformat = format;
	if (!(format &= ((AST_FORMAT_MAX_AUDIO << 1) - 1))) {
		ast_log(LOG_NOTICE, "Asked to get a channel of unsupported format %s while capability is %s\n", ast_getformatname(oldformat), ast_getformatname(global.capability));
		*cause = AST_CAUSE_BEARERCAPABILITY_NOTAVAIL;	/* Can't find codec to connect to host */
		return NULL;
	}
	if (option_debug)
		ast_log(LOG_DEBUG, "Asked to create a SIP channel with formats: %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), oldformat));

	if (!(p = sip_alloc(NULL, NULL, FALSE, SIP_INVITE))) {
		ast_log(LOG_ERROR, "Unable to build sip pvt data for '%s' (Out of memory or socket error)\n", (char *)data);
		*cause = AST_CAUSE_SWITCH_CONGESTION;
		return NULL;
	}

	if (!(p->options = ast_calloc(1, sizeof(*p->options)))) {
		sip_destroy(p);
		ast_log(LOG_ERROR, "Unable to build option SIP data structure - Out of memory\n");
		*cause = AST_CAUSE_SWITCH_CONGESTION;
		return NULL;
	}

	ast_copy_string(tmp, dest, sizeof(tmp));
	host = strchr(tmp, '@');
	if (host) {
		*host++ = '\0';
		ext = tmp;
	} else {
		ext = strchr(tmp, '/');
		if (ext) 
			*ext++ = '\0';
		host = tmp;
	}

	if (create_addr(p, host)) {
		*cause = AST_CAUSE_UNREGISTERED;
		if (option_debug > 2)
			ast_log(LOG_DEBUG, "Cant create SIP call - target device not registred\n");
		sip_destroy(p);
		return NULL;
	}
	if (ast_strlen_zero(p->peername) && ext)
		ast_string_field_set(p, peername, ext);
	/* Recalculate our side, and recalculate Call ID */
	if (sip_ouraddrfor(&p->sa.sin_addr, &p->ourip))
		p->ourip = sipnet.__ourip;
	build_via(p, FALSE);
	build_callid_pvt(p);
	
	/* We have an extension to call, don't use the full contact here */
	/* This to enable dialing registered peers with extension dialling,
	   like SIP/peername/extension 	
	   SIP/peername will still use the full contact */
	if (ext) {
		ast_string_field_set(p, peername, ext);
		ast_string_field_free(p, fullcontact);
	}
#if 0
	printf("Setting up to call extension '%s' at '%s'\n", ext ? ext : "<none>", host);
#endif
	p->prefcodec = oldformat;				/* Format for this call */
	dialog_lock(p, TRUE);
	tmpc = sip_new(p, AST_STATE_DOWN, host);	/* Place the call */
	dialog_lock(p, FALSE);
	if (!tmpc)
		sip_destroy(p);
	ast_update_use_count();
	restart_monitor();
	return tmpc;
}

/*! \brief Create temporary peer (used in autocreatepeer mode) */
static struct sip_peer *temp_peer(const char *name)
{
	struct sip_peer *peer;

	if (!(peer = ast_calloc(1, sizeof(*peer))))
		return NULL;

	sipcounters.autocreated_peers++;
	ASTOBJ_INIT(peer);
	peer->type = SIP_PEER;
	set_device_defaults(peer);

	ast_copy_string(peer->name, name, sizeof(peer->name));

	ast_set_flag(&peer->flags[1], SIP_PAGE2_SELFDESTRUCT);
	ast_set_flag(&peer->flags[1], SIP_PAGE2_DYNAMIC);
	peer->prefs = global.default_prefs;
	reg_source_db(peer);

	return peer;
}

static int sip_handle_t38_reinvite(struct ast_channel *chan, struct sip_dialog *pvt, int reinvite)
{
	struct sip_dialog *p;
	int flag = 0;
	
	p = chan->tech_pvt;
	if (!p || !pvt->udptl)
		return -1;
	
	/* Setup everything on the other side like offered/responded from first side */
	dialog_lock(p, TRUE);
	p->t38.jointcapability = p->t38.peercapability = pvt->t38.jointcapability;
	ast_udptl_set_far_max_datagram(p->udptl, ast_udptl_get_local_max_datagram(pvt->udptl));
	ast_udptl_set_local_max_datagram(p->udptl, ast_udptl_get_local_max_datagram(pvt->udptl));
	ast_udptl_set_error_correction_scheme(p->udptl, ast_udptl_get_error_correction_scheme(pvt->udptl));
	
	if (reinvite) {		/* If we are handling sending re-invite to the other side of the bridge */
		if (ast_test_flag(&p->flags[0], SIP_CAN_REINVITE) && ast_test_flag(&pvt->flags[0], SIP_CAN_REINVITE)) {
			ast_udptl_get_peer(pvt->udptl, &p->udptlredirip);
			flag =1;
		} else {
			memset(&p->udptlredirip, 0, sizeof(p->udptlredirip));
		}
		if (!ast_test_flag(&p->flags[0], SIP_GOTREFER)) {
			if (!p->pendinginvite) {
				if (option_debug > 2) {
					if (flag)
						ast_log(LOG_DEBUG, "Sending reinvite on SIP '%s' - It's UDPTL soon redirected to IP %s:%d\n", p->callid, ast_inet_ntoa(p->udptlredirip.sin_addr), ntohs(p->udptlredirip.sin_port));
					else
						ast_log(LOG_DEBUG, "Sending reinvite on SIP '%s' - It's UDPTL soon redirected to us (IP %s)\n", p->callid, ast_inet_ntoa(p->ourip));
				}
				transmit_reinvite_with_sdp(p, TRUE);
			} else if (!ast_test_flag(&p->flags[0], SIP_PENDINGBYE)) {
				if (option_debug > 2) {
					if (flag)
						ast_log(LOG_DEBUG, "Deferring reinvite on SIP '%s' - It's UDPTL will be redirected to IP %s:%d\n", p->callid, ast_inet_ntoa(p->udptlredirip.sin_addr), ntohs(p->udptlredirip.sin_port));
					else
						ast_log(LOG_DEBUG, "Deferring reinvite on SIP '%s' - It's UDPTL will be redirected to us (IP %s)\n", p->callid, ast_inet_ntoa(p->ourip));
				}
				ast_set_flag(&p->flags[0], SIP_NEEDREINVITE);
			}
		}
		/* Reset lastrtprx timer */
		p->lastrtprx = p->lastrtptx = time(NULL);
		dialog_lock(p, FALSE);
		return 0;
	} else {	/* If we are handling sending 200 OK to the other side of the bridge */
		if (ast_test_flag(&p->flags[0], SIP_CAN_REINVITE) && ast_test_flag(&pvt->flags[0], SIP_CAN_REINVITE)) {
			ast_udptl_get_peer(pvt->udptl, &p->udptlredirip);
			flag = 1;
		} else {
			memset(&p->udptlredirip, 0, sizeof(p->udptlredirip));
		}
		if (option_debug > 2) {
			if (flag)
				ast_log(LOG_DEBUG, "Responding 200 OK on SIP '%s' - It's UDPTL soon redirected to IP %s:%d\n", p->callid, ast_inet_ntoa(p->udptlredirip.sin_addr), ntohs(p->udptlredirip.sin_port));
			else
				ast_log(LOG_DEBUG, "Responding 200 OK on SIP '%s' - It's UDPTL soon redirected to us (IP %s)\n", p->callid, ast_inet_ntoa(p->ourip));
		}
		pvt->t38.state = T38_ENABLED;
		p->t38.state = T38_ENABLED;
		if (option_debug > 1) {
			ast_log(LOG_DEBUG, "T38 changed state to %d on channel %s\n", pvt->t38.state, pvt->owner ? pvt->owner->name : "<none>");
			ast_log(LOG_DEBUG, "T38 changed state to %d on channel %s\n", p->t38.state, chan ? chan->name : "<none>");
		}
		transmit_response_with_attachment(WITH_T38_SDP, p, "200 OK", &p->initreq, XMIT_CRITICAL);
		p->lastrtprx = p->lastrtptx = time(NULL);
		dialog_lock(p, FALSE);
		return 0;
	}
}


static char *synopsis_dtmfmode = "Change the dtmfmode for a SIP call";
static char *descrip_dtmfmode = "SIPDtmfMode(inband|info|rfc2833): Changes the dtmfmode for a SIP call\n";
static char *app_dtmfmode = "SIPDtmfMode";

static char *app_sipaddheader = "SIPAddHeader";
static char *synopsis_sipaddheader = "Add a SIP header to the outbound call";

static char *descrip_sipaddheader = ""
"  SIPAddHeader(Header: Content)\n"
"Adds a header to the INVITE of a SIP call placed with DIAL.\n"
"Remember to user the X-header if you are adding non-standard SIP\n"
"headers, like \"X-Asterisk-Accountcode:\". Use this with care.\n"
"Adding the wrong headers may jeopardize the SIP dialog.\n"
"Always returns 0\n";


/*! \brief Set the DTMFmode for an outbound SIP call (application) */
static int sip_dtmfmode(struct ast_channel *chan, void *data)
{
	struct sip_dialog *p;
	char *mode;
	if (data)
		mode = (char *)data;
	else {
		ast_log(LOG_WARNING, "This application requires the argument: info, inband, rfc2833\n");
		return 0;
	}
	ast_channel_lock(chan);
	if (chan->tech != &sip_tech) {
		ast_log(LOG_WARNING, "Call this application only on SIP incoming calls\n");
		ast_channel_unlock(chan);
		return 0;
	}
	p = chan->tech_pvt;
	if (!p) {
		ast_channel_unlock(chan);
		return 0;
	}
	dialog_lock(p, TRUE);
	if (!strcasecmp(mode, "info")) {
		ast_clear_flag(&p->flags[0], SIP_DTMF);
		ast_set_flag(&p->flags[0], SIP_DTMF_INFO);
	} else if (!strcasecmp(mode, "rfc2833")) {
		ast_clear_flag(&p->flags[0], SIP_DTMF);
		ast_set_flag(&p->flags[0], SIP_DTMF_RFC2833);
	} else if (!strcasecmp(mode, "inband")) { 
		ast_clear_flag(&p->flags[0], SIP_DTMF);
		ast_set_flag(&p->flags[0], SIP_DTMF_INBAND);
	} else
		ast_log(LOG_WARNING, "I don't know about this DTMF mode: %s\n",mode);
	if (ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_INBAND) {
		if (!p->vad) {
			p->vad = ast_dsp_new();
			ast_dsp_set_features(p->vad, DSP_FEATURE_DTMF_DETECT);
		}
	} else {
		if (p->vad) {
			ast_dsp_free(p->vad);
			p->vad = NULL;
		}
	}
	dialog_lock(p, FALSE);
	ast_channel_unlock(chan);
	return 0;
}

/*! \brief Add a SIP header to an outbound INVITE */
static int sip_addheader(struct ast_channel *chan, void *data)
{
	int no = 0;
	int ok = FALSE;
	char varbuf[30];
	char *inbuf = (char *) data;
	
	if (ast_strlen_zero(inbuf)) {
		ast_log(LOG_WARNING, "This application requires the argument: Header\n");
		return 0;
	}
	ast_channel_lock(chan);

	/* Check for headers */
	while (!ok && no <= 50) {
		no++;
		snprintf(varbuf, sizeof(varbuf), "_SIPADDHEADER%.2d", no);

		/* Compare without the leading underscore */
		if( (pbx_builtin_getvar_helper(chan, (const char *) varbuf + 1) == (const char *) NULL) )
			ok = TRUE;
	}
	if (ok) {
		pbx_builtin_setvar_helper (chan, varbuf, inbuf);
		if (sipdebug)
			ast_log(LOG_DEBUG,"SIP Header added \"%s\" as %s\n", inbuf, varbuf);
	} else {
		ast_log(LOG_WARNING, "Too many SIP headers added, max 50\n");
	}
	ast_channel_unlock(chan);
	return 0;
}

/*! \brief Transfer call before connect with a 302 redirect
\note	Called by the transfer() dialplan application through the sip_transfer()
	pbx interface function if the call is in ringing state 
\todo	Fix this function so that we wait for reply to the REFER and
	react to errors, denials or other issues the other end might have.
 */
static int sip_sipredirect(struct sip_dialog *p, const char *dest)
{
	char *cdest;
	char *extension, *host, *port;
	char tmp[80];

	cdest = ast_strdupa(dest);
	
	extension = strsep(&cdest, "@");
	host = strsep(&cdest, ":");
	port = strsep(&cdest, ":");
	if (ast_strlen_zero(extension)) {
		ast_log(LOG_ERROR, "Missing mandatory argument: extension\n");
		return 0;
	}

	/* we'll issue the redirect message here */
	if (!host) {
		char *localtmp;

		ast_copy_string(tmp, get_header(&p->initreq, "To"), sizeof(tmp));
		if (ast_strlen_zero(tmp)) {
			ast_log(LOG_ERROR, "Cannot retrieve the 'To' header from the original SIP request!\n");
			return 0;
		}
		if ((localtmp = strstr(tmp, "sip:")) && (localtmp = strchr(localtmp, '@'))) {
			char lhost[80], lport[80];

			memset(lhost, 0, sizeof(lhost));
			memset(lport, 0, sizeof(lport));
			localtmp++;
			/* This is okey because lhost and lport are as big as tmp */
			sscanf(localtmp, "%[^<>:; ]:%[^<>:; ]", lhost, lport);
			if (ast_strlen_zero(lhost)) {
				ast_log(LOG_ERROR, "Can't find the host address\n");
				return 0;
			}
			host = ast_strdupa(lhost);
			if (!ast_strlen_zero(lport)) {
				port = ast_strdupa(lport);
			}
		}
	}

	ast_string_field_build(p, our_contact, "Transfer <sip:%s@%s%s%s>", extension, host, port ? ":" : "", port ? port : "");
	transmit_response_reliable(p, "302 Moved Temporarily", &p->initreq);

	sip_scheddestroy(p, 32000);	/* Make sure we stop send this reply. */

	/* hangup here */
	return -1;
}

/*! \brief Reload module */
GNURK int sip_do_reload(enum channelreloadreason reason)
{
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "--------------- SIP reload started\n");

	clear_realm_authentication(authl);
	clear_sip_domains();
	authl = NULL;

	/* First, destroy all outstanding registry calls */
	/* This is needed, since otherwise active registry entries will not be destroyed */
	ASTOBJ_CONTAINER_TRAVERSE(&regl, 1, do {
		ASTOBJ_RDLOCK(iterator);
		if (iterator->call) {
			if (option_debug > 2)
				ast_log(LOG_DEBUG, "Destroying active SIP dialog for registry %s@%s\n", iterator->username, iterator->hostname);
			/* This will also remove references to the registry */
			sip_destroy(iterator->call);
		}
		ASTOBJ_UNLOCK(iterator);
	} while(0));

	/* Then, actually destroy users and registry */
	ASTOBJ_CONTAINER_DESTROYALL(&regl, sip_registry_destroy);
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "--------------- Done destroying registry list\n");
	ASTOBJ_CONTAINER_MARKALL(&devicelist);
	reload_config(reason);

	/* Prune peers who still are supposed to be deleted */
	ASTOBJ_CONTAINER_PRUNE_MARKED(&devicelist, sip_destroy_device);
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "--------------- Done destroying pruned peers\n");

	/* Send qualify (OPTIONS) to all peers */
	sip_poke_all_peers();

	/* Register with all services */
	sip_send_all_registers();

	if (option_debug > 3)
		ast_log(LOG_DEBUG, "--------------- SIP reload done\n");

	return 0;
}

/*! \brief Force reload of module from cli */
GNURK int sip_reload(int fd)
{

	ast_mutex_lock(&sip_reload_lock);
	if (sip_reloading) {
		ast_verbose("Previous SIP reload not yet done\n");
	} else {
		sip_reloading = TRUE;
		if (fd)
			sip_reloadreason = CHANNEL_CLI_RELOAD;
		else
			sip_reloadreason = CHANNEL_MODULE_RELOAD;
	}
	ast_mutex_unlock(&sip_reload_lock);
	restart_monitor();

	return 0;
}


/*! \brief  reload: Part of Asterisk module interface */
static int reload(void)
{
	return sip_reload(0);
}

/*! \brief  load_module: PBX load module - initialization */
static int load_module(void)
{
	ASTOBJ_CONTAINER_INIT(&devicelist);	/* Peer object list */
	ASTOBJ_CONTAINER_INIT(&regl);	/* Registry object list */

	if (!(sched = sched_context_create())) {
		ast_log(LOG_ERROR, "Unable to create scheduler context\n");
		return AST_MODULE_LOAD_FAILURE;
	}
	logdebug(4, "SIP3 :: Scheduler initialized...\n");

	if (!(io = io_context_create())) {
		ast_log(LOG_ERROR, "Unable to create I/O context\n");
		sched_context_destroy(sched);
		return AST_MODULE_LOAD_FAILURE;
	}
	logdebug(4, "SIP3 :: IO context initialized...\n");

	sip_reloadreason = CHANNEL_MODULE_LOAD;

	if(reload_config(sip_reloadreason))	/* Load the configuration from sip.conf */
		return AST_MODULE_LOAD_DECLINE;

	logdebug(4, "SIP3 :: Configuration loaded\n");

	/* Make sure we can register our sip channel type */
	if (ast_channel_register(&sip_tech)) {
		ast_log(LOG_ERROR, "Unable to register channel type 'SIP'\n");
		io_context_destroy(io);
		sched_context_destroy(sched);
		
		/* Isn't there more to destroy here? */
		return AST_MODULE_LOAD_FAILURE;
	}
	logdebug(4, "SIP3 :: Registered channel to PBX.\n");

	/* Tell the RTP and UDPTL subdriver that we're here */
	register_rtp_and_udptl();	/* See sip3_sdprtp.c */
	logdebug(4, "SIP3 :: Initialized RTP and UDPTL. Ready for action\n");

	/* Register dialplan applications */
	ast_register_application(app_dtmfmode, sip_dtmfmode, synopsis_dtmfmode, descrip_dtmfmode);
	ast_register_application(app_sipaddheader, sip_addheader, synopsis_sipaddheader, descrip_sipaddheader);

	/* Register dialplan functions */
	ast_custom_function_register(&sip_header_function);
	ast_custom_function_register(&sippeer_function);
	ast_custom_function_register(&sipchaninfo_function);
	ast_custom_function_register(&checksipdomain_function);

	/* Register manager commands */
	sip_cli_and_manager_commands_register();
	logdebug(4, "SIP3 :: Registered CLI and manager commands\n");
	sip_poke_all_peers();	
	logdebug(4, "SIP3 :: Scheduled poke of all peers\n");
	sip_send_all_registers();
	logdebug(4, "SIP3 :: Scheduled registration of services\n");
	
	/* And start the monitor for the first time */
	restart_monitor();
	logdebug(4, "SIP3 :: Monitor started. Ready for rock'n'roll! ---------------------------\n");

	return AST_MODULE_LOAD_SUCCESS;
}

static int unload_module(void)
{
	struct sip_dialog *p, *pl;
	
	/* First, take us out of the channel type list */
	ast_channel_unregister(&sip_tech);

	ast_custom_function_unregister(&sipchaninfo_function);
	ast_custom_function_unregister(&sippeer_function);
	ast_custom_function_unregister(&sip_header_function);
	ast_custom_function_unregister(&checksipdomain_function);

	ast_unregister_application(app_dtmfmode);
	ast_unregister_application(app_sipaddheader);
	sip_cli_and_manager_commands_unregister();

	unregister_rtp_and_udptl();	/* sip3_sdprtp.c */

	ast_manager_unregister("SIPpeers");
	ast_manager_unregister("SIPshowpeer");

	/* Hangup all dialogs if they have an owner */
	dialoglist_lock();
	for (p = dialoglist; p ; p = p->next) {
		if (p->owner)
			ast_softhangup(p->owner, AST_SOFTHANGUP_APPUNLOAD);
	}
	dialoglist_unlock();

	/* Kill the monitor thread */
	ast_mutex_lock(&monlock);
	if (monitor_thread && (monitor_thread != AST_PTHREADT_STOP)) {
		pthread_cancel(monitor_thread);
		pthread_kill(monitor_thread, SIGURG);
		pthread_join(monitor_thread, NULL);
	}
	monitor_thread = AST_PTHREADT_STOP;
	ast_mutex_unlock(&monlock);

	/* Destroy all the dialogs and free their memory */
	dialoglist_lock();
	p = dialoglist;
	while (p) {
		pl = p;
		p = p->next;
		__sip_destroy(pl, TRUE, TRUE);
	}
	dialoglist_unlock();
	dialoglist = NULL;

	/* Free memory for local network address mask */
	ast_free_ha(sipnet.localaddr);

	/* Destroy all device configurations in the device list */
	ASTOBJ_CONTAINER_DESTROYALL(&devicelist, sip_destroy_device);
	ASTOBJ_CONTAINER_DESTROY(&devicelist);

	/* Destroy all entries in the registry list */
	ASTOBJ_CONTAINER_DESTROYALL(&regl, sip_registry_destroy);
	ASTOBJ_CONTAINER_DESTROY(&regl);

	clear_realm_authentication(authl);
	clear_sip_domains();				/* Clear the list of hosted domains */

	close(sipnet.sipsock);				/* Close the network socket */
	sched_context_destroy(sched);
		
	return 0;
}

AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "Session Initiation Protocol, chan_sip3 version (SIP)",
		.load = load_module,
		.unload = unload_module,
		.reload = reload,
	       );
