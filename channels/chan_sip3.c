/* CODENAME PINEAPPLE - THIS IS VERY EXPERIMENTAL. 
   IF YOU USE THIS IN PRODUCTION, I WILL NOT SUPPORT YOU...
*
*  -- Mail bugs to oej@edvina.net, do not file them in the bug tracker
*/

/* To skip to source code, search for "-END-" */

/*
 * Asterisk -- An open source telephony toolkit.
 *
 * Copyright (C) 1999 - 2007, Digium, Inc.
 *
 * Mark Spencer <markster@digium.com>
 * Chan_sip3 changes by Olle E. Johansson <oej@edvina.net>
 *
 *
 *
 * See http://www.asterisk.org for more information about
 * the Asterisk project. Please do not directly contact
 * any of the maintainers of this project for assistance;
 * the project provides a web site, mailing lists and IRC
 * channels for your use.
 *
 * This program is free software, distributed under the terms of
 * the GNU General Public License Version 2. See the LICENSE file
 * at the top of the source tree.
 */

/*!
 * \file
 * \brief Implementation of Session Initiation Protocol
 * Version 3 of chan_sip
 *
 * \author Mark Spencer <markster@digium.com>
 * \author Olle E. Johansson <oej@edvina.net> (all the chan_sip3 changes)
 *
 * See Also:
 * \arg \ref AstCREDITS
 *
 * Implementation of RFC 3261 - without S/MIME, TCP and TLS support
 * Configuration file \link Config_sip sip.conf \endlink
 *
 *
 * \todo SIP over TCP
 * \todo SIP over TLS
 * \todo Better support of forking
 * \todo VIA branch tag transaction checking
 * \todo Transaction support
 *
 * \ingroup channel_drivers
 */

/*! \page chan_sip3_overview Chan_SIP3:: Overview
 *
 * \par Overview of the handling of SIP sessions
 * The SIP channel handles several types of SIP sessions, or dialogs,
 * not all of them being "telephone calls".
 * - Incoming calls that will be sent to the PBX core
 * - Outgoing calls, generated by the PBX
 * - SIP subscriptions and notifications of states and voicemail messages
 * - SIP registrations, both inbound and outbound
 * - SIP peer management (peerpoke, OPTIONS)
 * - SIP text messages
 *
 * In the SIP channel, there's a list of active SIP dialogs, which includes
 * all of these when they are active. "sip show channels" in the CLI will
 * show most of these, excluding subscriptions which are shown by
 * "sip show subscriptions"
 *
 * \par incoming packets
 * Incoming packets are received in the monitoring thread, then handled by
 * sipsock_read(). This function parses the packet and matches an existing
 * dialog or starts a new SIP dialog.
 * 
 * sipsock_read sends the packet to handle_request(), that parses a bit more.
 * if it's a response to an outbound request, it's sent to handle_response().
 * If it is a request, handle_request sends it to one of a list of functions
 * depending on the request type - INVITE, OPTIONS, REFER, BYE, CANCEL etc
 * sipsock_read locks the ast_channel if it exists (an active call) and
 * unlocks it after we have processed the SIP message.
 *
 * A new INVITE is sent to handle_request_invite(), that will end up
 * starting a new channel in the PBX, the new channel after that executing
 * in a separate channel thread. This is an incoming "call".
 * When the call is answered, either by a bridged channel or the PBX itself
 * the sip_answer() function is called.
 *
 * The actual media - Video or Audio - is mostly handled by the RTP subsystem
 * in rtp.c 
 * 
 * \par Outbound calls
 * Outbound calls are set up by the PBX through the sip_request_call()
 * function. After that, they are activated by sip_call().
 * 
 * \par Hanging up
 * The PBX issues a hangup on both incoming and outgoing calls through
 * the sip_hangup() function
 *
 * \section SIP3dialog Dialogs, packets, transactions
 *
 * This version of chan_sip has a concept of a SIP dialog (\ref sip_dialog) that
 * lives throughut a session - a call (INVITE), a registration (REGISTER)
 * or a subscription for status (SUBSCRIBE)... We do save new requests we
 * send in a queue (sip_dialog->packets) until they're acknowledged by the
 * remote party, when we remove them (sip_ack() )
 * 
 * For requests and responses, we store them in a structure called \ref sip_request
 * and process them. The matching between a response or a new request and an
 * existing dialog is done in match_or_create_dialog().
 *
 */

/*!	\page chan_sip3_00index Chan_sip3: Index over docs
	\title Chan_sip3 :: Index

	- \ref chan_sip3_overview
	- \subpage chan_sip3_start
	- \subpage chan_sip3_security
	- \subpage chan_sip3_objects
	- \subpage chan_sip3_registrydb
	- \subpage chan_sip3_files
	- \subpage chan_sip3_auth
	- \subpage chan_sip3_dialogs
	- \subpage chan_sip3_transactions
	- \subpage sip3_timer_doc
	- \subpage sip3_dialog_match
	- \subpage chan_sip3_dialstring
	- \subpage chan_sip3_natsupport

	\par todo Things to do, ideas
	- \subpage chan_sip3_todo
	- \subpage chan_sip3_subs

*/

/*! 
	\page chan_sip3_start Chan_sip3: Welcome to Codename Pineapple !

	\title Chan_sip3: What's this?
	This is a re-work of the SIP channel in Asterisk. 
	This channel will not be backwards compatible with the old 
	sip channel. In order to be more SIP compatible, I will have
	to break the backwards compatibility. That's why the old channel
	will still be around for a while.

	Chan_sip3 is the road towards security (see \ref chan_sip3_security).
	By adding a transaction layer and support for TCP connections, we can
	add TLS for the TCP connections and negotiate keys for secure media
	with SRTP.

	** This work is sponsored by voop.com - the Internet Dialtone.
	   I am open for more sponsors - contact me on oej@edvina.net

	\page chan_sip3_todo Chan_sip3: Things to do
	\b Done
	- Trying to reduce memory allocations for packets.
		- sipsock_read allocates a packet that stays in memory
		  until the transaction is finished. If it's an initial
		  request, it's flagged to stay in memory and kept until
		  destruction of the dialog (or replacement of initreq).
		- The issue here is parsing, since parsing destroys the
		  in-memory copy of the outbound message thus stopping
		  proper re-transmits. Added flag for parsing of packet,
		  trying to delay parsing until we send a response.
	- Added new CLI command "sip list configs" to list all configuration options 
	  Mostly for debugging

	- Added new configuration engine
	- Add T1 timer configuration settings
	- Added configurable T2 timer, see \ref sip3_timer_doc
	- Added time to astdb registry storage, so that expired registrations
	  won't be activated at restart
	- removed pedantic mode
	- added config option for qualify frequency timers
	- merged peermatch and sipregister branches
	- removed "type=user"
	- change "sip nodebug" to "sip debug off" and "sip debug" to "sip debug on" - done
	- change "sip history" and "nohistory" to "on/off" - done
	- "sip show/list peers" is now "sip show/list phones"
	- manager command renamed - SIPdevices and SIPshowdevice
	- Added "authuser" configuration option for trunks and services
	- Added "domain" configuration option for all devices
	- Fixed handling of too short registration times (sending 423)
	- T38 does no longer depend on canreinvite settings
	- removed userconf support (in favour of astum)

	\b Larger changes required outside of chan_sip
	- dnsmgr needs to follow DNS ttl
	- dnsmgr needs to handle SRV, NAPTR

	\b Halfdone
	- Added separate TOS setting for presence. Need to run setsockopt
	  in a locked socket for that to work on the SIP interface.

	\par Todo - architecture
	- check if the "defaultport" and "port" settings are working - port for remote peer?
	- dnsmgr needs to be integrated and updated
	- netsock?
	- thread and separate port for outbound registrations
	- receive queue between sipsock_read and handle_request
	- inbound call authentication

	\par Todo - ideas
	- Implement support for a:rtcp sdp (needs changes in the rtp interface)
	- Implement "busylimit" for signalling busy, but not enforcing a call limit
	- Use "accept-language" to set language tags in error messages etc
	- Implement "holdaction = music | sendhold"
	- Handle 423 Interval too brief on registrations
	- Accept-language to language tag.
	- Fix T4 implementation
		- Configuration setting implemented in global
	- Check if usereqphone is a global flag
	- Fix compact headers per peer
	- Always enable "alwaysauthreject" and remove that option
	- Check "insecure" option - do we still need it?
	- Only check for pickup code if callgroup/pickupgroups are specified in config
	- check resp 491 to INVITE processing
	- Make show devices and the completion support domains too
	- Fix realtime caching and optional loading
	- Clean up the authuser/username/peername mess!
		- authuser as a separate config option, please, please
	- Split up source code file
	- Add astum
	- Add auto-nat for RFC 1918 networks
	- Add type=device for peers
	- Add type=service for register= replacement
	- Add type=trunk definition, based on domain routing
	- Implement state engine for dialogs
	- Implement transactions
	- Implement state engine for transactions
	- Implement real realtime caching
	- Implement realtime static loading for MWI and qualify support
	- Implement remote MWI notification
	- Implement remote subscriptions
	- Implement improved SIP domain support
		- Document these ideas!
	- Prove transaction engine by implementing PRACK
	- Implement netsock API in this channel
	- Add File's multithreading code
	- Make debugaddr a ha list instead of one address and move it out of sipnet
	- Save the last sent request/response for re-transmits
	- RTP keepalives (STUN) for video
	- Clean up 302 redirect - remove "promisredir" setting 

	\b Maybe
	- add support for Path header
		the Path is arriving with Register requests, saved in location
		and used as a Route: header in the outbound request
	- Add support for the "norefersub" option
	- Add support for GRUU

	- ... And much more
*/
/*!
	\page chan_sip3_security	Chan_sip3: The road to SIP security

	Codename pineapple is the road towards SIP security. 

	- SIP/TLS is the way to secure signalling
	- In order to get there, we need TCP
	- In order to get TCP, we need a transaction state engine
	- We also need a separation of network transmission over
		reliable and unreliable transports and the SIP
		core
	- When we have that, we can add SRTP

 */
/*!
	\page chan_sip3_objects	Chan_sip3: Devices, trunks and services
	- \b phones are devices that connect to Asterisk. They register with  
	Asterisk acting as a SIP location server/registrar and use Asterisk 
	as the outbound SIP  proxy. They get calls from Asterisk and place 
	calls to Asterisk. The phone use one of  the SIP domains that are hosted 
	within your Asterisk server. (this is like the  
	current "friend")

	- \b service is when Asterisk is the UA, acting as a phone towards  
	another SIP server - we register with a SIP location server/registrar 
	to get incoming  calls. We place
	calls, masquerading as a phone (using the registrars domain).
	Currently, this is a mixture between a peer (matched on IP for  
	incoming calls) and a register= statement. In some cases, two 
	peers and a register= statement.  Very confusing.

	- \b trunk is when we exchange traffic with another server. We send  
	calls to their SIP domain and receive calls to our SIP domain. We may 
	use realm based authentication for the incoming part of the trunk 
	(not based on caller ID/From: header) and a combination of SIP domain and ACLs.
	This is currently handled by defining sip peers for outbound calls and
	separate SIP peers for inbound calls - where we match on IP. The
	problem with the IP matching is when a trunking partner use several
	SIP servers to connect to us, we need to define one peer per server
	instead of just matching on domain and then authenticate.

*/

/*!
	\page chan_sip3_subs Chan_sip3: Subscriptions

	\title Ideas for a new subscription system
	
	We need to move out the active subsriptions to a list
	of their own, like the registry. Do not keep them in
	the active dialog list, they're active subscriptions.

	Add a list of internal and external subscriptions.
	We need one object that "watches" URIs or extensions
	that is connected to subscribers. For several subscribers,
	we have only one internal or external subscription.

	Should the external subscription system be directly
	connected or go through the hint subsystem? Will this
	cause un-needed overhead?

	exten => johnny,hint,sipsubscribe::sip:johnny@johnnysdomain.com

*/

/*!
	\page chan_sip3_files Chan_sip3: Source code files
	\title Chan_sip3: Source Code Files

	\b \\channels

	- \b chan_sip3.c	The main source code file for the channel
				PBX interface

	\b \\channels\\sip3
	
	- \b sip3.h		The include file for structures and enums
	- \b sip3funcs.h	The include file for functions
	- \b sip3_cliami.c	Manager and CLI functions
	- \b sip3_sdprtp.c	SDP handling and RTP interface
	- \b sip3_callerid.c	CallerID, pres and RPID handling
	- \b sip3_monitor.c	The monitor thread (housekeeping)
	- \b sip3_dialog.c	SIP dialog support
	- \b sip3_auth.c	SIP authentication
	- \b sip3_config.c	Configuration
	- \b sip3_domain.c	SIP domain support
	- \b sip3_subscribe.c	SIP subscription support
	- \b sip3_parse.c	Parsing stuff
	- \b sip3_compose.c	Composing new requests and responses
	- \b sip3_refer.c	SIP transfer and parking support
	- \b sip3_network.c	Networks interface (UDP today)
	- \b sip3_services.c	Outbound registrations (services)
	- \b sip3_pokedevice.c	Peer management (health checks)
		
*/
/*!
 *	\page chan_sip3_transactions Chan_sip3: Implementing transactions
 *
 *	A SIP transaction is a request and one or several responses. 
 *	The INVITE transaction is special, it's a three-way handshake
 *		request - response - ack
 *	
 *	Responses are divided into temporary responses and final responses.
 *	A final response closes the transaction, temporary responses
 *	just updates the transaction.
 *
 *	Some transactions will open a new SIP dialog, some will not.
 *	Some transactions are allowed within an active dialog, some
 *	are not.
 *
 *	\title	Transactions and chan_sip
 *	The current version of chan_sip.c does not have much notion
 * 	of a SIP transaction or a dialog. Each transaction will update
 *	the dialog, so only the last request is remembered and the
 *	direction of the last request.
 *	
 *	While this can be seen as effective, it does not allow 
 * 	for situations with multiple concurrent transactions.
 *	Most importantly, the INVITE transaction can be open for
 *	a long time (Ringing) and other things may happen at
 *	the same time.
 *
 *	We do need to change chan_sip3 so that the transaction
 *	state engine works properly.

 * 	\title Random thoughts
 *	- Integrate sip_pkt and sip_request - done
 *	- Mark the UNACKed packets in dialog->packets with a flag
 *		Maybe two lists of packets, to keep it simple for do_monitor?
 *		Or a flag when we have no open transactions?
 *	- Use sip-request as "transaction holders" within sip_dialog
 *	- Keep them in Cseq order
 *	- Add transaction state
 *	- When do you delete them - 32 secs after first transmit 
 *	- Then we finally can fix the "ignore" ignorant stuff and resend last response
 *	- The first transaction that opened in a dialog needs to be saved for the
 *	  CANCEL/BYE (in an INVITE transaction)
 *	- For SUBSCRIBE dialogs, we need to keep the initial SUBSCRIBE
 *	  Then unacknowledged NOTIFY transactions. Keep the transaction
 *	  until timer expires
 *	- Queue system for incoming packets?
 *
 *	SIP_dialog
 *	   - sip_trans
 *		Request	(our or remote)
 *		response (our or remote)
 *	   - sip_trans
 *
 */
			/* -END- documentation pages */

#define CHAN_SIP3_MAIN

/* GNURK is a temporary marker of functions that are exposed outside of this code file 
   and possibly needs to move out */
#define GNURK

#include "asterisk.h"

ASTERISK_FILE_VERSION(__FILE__, "$Revision$")

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <errno.h>
#include <stdlib.h>
#include <fcntl.h>
#include <netdb.h>
#include <signal.h>
#include <sys/signal.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <arpa/inet.h>
#include <netinet/ip.h>
#include <regex.h>

#include "asterisk/lock.h"
#include "asterisk/channel.h"
#include "asterisk/config.h"
#include "asterisk/logger.h"
#include "asterisk/module.h"
#include "asterisk/pbx.h"
#include "asterisk/options.h"
#include "asterisk/sched.h"
#include "asterisk/io.h"
#include "asterisk/rtp.h"
#include "asterisk/udptl.h"
#include "asterisk/acl.h"
#include "asterisk/manager.h"
#include "asterisk/translate.h"
#include "asterisk/callerid.h"
#include "asterisk/cli.h"
#include "asterisk/app.h"
#include "asterisk/musiconhold.h"
#include "asterisk/dsp.h"
#include "asterisk/features.h"
#include "asterisk/srv.h"
#include "asterisk/astdb.h"
#include "asterisk/causes.h"
#include "asterisk/utils.h"
#include "asterisk/file.h"
#include "asterisk/astobj.h"
#include "asterisk/dnsmgr.h"
#include "asterisk/devicestate.h"
#include "asterisk/linkedlists.h"
#include "asterisk/stringfields.h"
#include "asterisk/monitor.h"
#include "asterisk/localtime.h"
#include "asterisk/abstract_jb.h"
#include "asterisk/compiler.h"

#include "sip3/sip3.h"
#include "sip3/sip3funcs.h"

#define SIPLABEL	sip3

/*------- GLOBAL VARIABLES ------------------------------------ */

/*! \brief various expiry times for registrations */
struct expiry_times expiry = {
	.min_expiry = DEFAULT_MIN_EXPIRY,        /*!< Minimum accepted registration time */
	.max_expiry = DEFAULT_MAX_EXPIRY,        /*!< Maximum accepted registration time */
	.default_expiry = DEFAULT_DEFAULT_EXPIRY,
	.expiry = DEFAULT_EXPIRY,		/*!< Is this ever used ??? */
};

/* Default setttings are used as a channel setting and as a default when
   configuring devices */
/*! Global settings only apply to the channel */
struct sip_globals global;

/* Object counters */
struct channel_counters sipcounters = { 0, 0, 0, 0, 0, 0, 0, 0};

/*! \brief Make sure we don't reload twice at the same time */
AST_MUTEX_DEFINE_STATIC(sip_reload_lock);

static int sip_reloading = FALSE;                      /*!< Flag for avoiding multiple reloads at the same time */
static enum channelreloadreason sip_reloadreason;      /*!< Reason for last reload/load of configuration */

struct sched_context *sched;     /*!< The scheduling context */
struct io_context *io;           /*!< The IO context */

/* --- Linked lists of various objects --------*/

struct sip_dialog *dialoglist = NULL;        /*!< List of concurrent SIP dialogs */
struct ast_config *notify_types;	     /*!< The list of manual NOTIFY types we know how to send */

/*---------------------------- Forward declarations of functions in chan_sip3.c */

/*--- PBX interface functions  - stays in this source code file */
static struct ast_channel *sip_request_call(const char *type, int format, void *data, int *cause);
static int sip_devicestate(void *data);
static int sip_sendtext(struct ast_channel *ast, const char *text);
static int sip_call(struct ast_channel *ast, char *dest, int timeout);
static int sip_hangup(struct ast_channel *ast);
static int sip_answer(struct ast_channel *ast);
static int sip_write(struct ast_channel *ast, struct ast_frame *frame);
static int sip_indicate(struct ast_channel *ast, int condition, const void *data, size_t datalen);
static int sip_transfer(struct ast_channel *ast, const char *dest);
static int sip_fixup(struct ast_channel *oldchan, struct ast_channel *newchan);
static int sip_senddigit_begin(struct ast_channel *ast, char digit);
static int sip_senddigit_end(struct ast_channel *ast, char digit, unsigned int duration);

static void receive_message(struct sip_dialog *p, struct sip_request *req);

/*--- Dialog management */
static int auto_congest(void *nothing);
static void list_route(struct sip_route *route);
static void build_route(struct sip_dialog *p, struct sip_request *req, int backwards);
static enum check_auth_result register_verify(struct sip_dialog *p, struct sockaddr_in *sin,
					      struct sip_request *req, char *uri);
static void check_pendings(struct sip_dialog *p);
static int sip_sipredirect(struct sip_dialog *p, const char *dest);

/*--- Codec handling / SDP */
GNURK void try_suggested_sip_codec(struct sip_dialog *p);

/*--- Authentication stuff */
static enum check_auth_result check_user_full(struct sip_dialog *p, struct sip_request *req,
		      int sipmethod, char *uri, enum xmittype reliable,
		      struct sockaddr_in *sin, struct sip_device **authpeer);
static int check_user(struct sip_dialog *p, struct sip_request *req, int sipmethod, char *uri, enum xmittype reliable, struct sockaddr_in *sin);

/*--- Misc functions */
static int sip_sipredirect(struct sip_dialog *p, const char *dest);

/*--- Device monitoring and Device/extension state handling */
static int cb_extensionstate(char *context, char* exten, int state, void *data);
static int sip_devicestate(void *data);

/*--- Applications, functions, CLI and manager command helpers */
GNURK int sip_notify(int fd, int argc, char *argv[]);
static int func_header_read(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len);
static int function_sippeer(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len);
static int function_sipchaninfo_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len);
static int sip_dtmfmode(struct ast_channel *chan, void *data);
static int sip_addheader(struct ast_channel *chan, void *data);

/*--- Debugging 
	Functions for enabling debug per IP or fully, or enabling history logging for
	a SIP dialog
*/
GNURK void sip_dump_history(struct sip_dialog *dialog);	/* Dump history to LOG_DEBUG at end of dialog, before destroying data */
GNURK inline int sip_debug_test_pvt(struct sip_dialog *p);

/*--- Device object handling */
static enum parse_register_result parse_register_contact(struct sip_dialog *pvt, struct sip_device *p, struct sip_request *req);

/*--- Parsing SIP requests and responses */
static int get_also_info(struct sip_dialog *p, struct sip_request *oreq);
static int parse_ok_contact(struct sip_dialog *pvt, struct sip_request *req);
static int set_address_from_contact(struct sip_dialog *pvt);
static void check_via(struct sip_dialog *p, struct sip_request *req);
static int get_msg_text(char *buf, int len, struct sip_request *req);

/*--- Constructing requests and responses */
static int create_addr_from_peer(struct sip_dialog *r, struct sip_device *peer);
static int add_vidupdate(struct sip_request *req);

/*------Request handling functions */
static int handle_request_invite(struct sip_dialog *p, struct sip_request *req, int debug, struct sockaddr_in *sin, int *recount, char *e);
static int handle_request_bye(struct sip_dialog *p, struct sip_request *req);
static int handle_request_register(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e);
static int handle_request_cancel(struct sip_dialog *p, struct sip_request *req);
static int handle_request_message(struct sip_dialog *p, struct sip_request *req);
static int handle_request_subscribe(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e);
static void handle_request_info(struct sip_dialog *p, struct sip_request *req);
static int handle_request_options(struct sip_dialog *p, struct sip_request *req);
static int handle_invite_replaces(struct sip_dialog *p, struct sip_request *req, int debug, struct sockaddr_in *sin);
static int handle_request_notify(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e);

/*------Response handling functions */
static void handle_response_invite(struct sip_dialog *p, int resp, char *rest, struct sip_request *req);
static void handle_response_refer(struct sip_dialog *p, int resp, char *rest, struct sip_request *req);
static void handle_response(struct sip_dialog *p, int resp, char *rest, struct sip_request *req);

/*------ T38 Support --------- */
static int sip_handle_t38_reinvite(struct ast_channel *chan, struct sip_dialog *pvt, int reinvite); /*!< T38 negotiation helper function */

/*! \brief Definition of this channel for PBX channel registration */
static const struct ast_channel_tech sip_tech = {
	.type = "SIP",
	.description = "Session Initiation Protocol (SIP)",
	.capabilities = ((AST_FORMAT_MAX_AUDIO << 1) - 1),
	.properties = AST_CHAN_TP_WANTSJITTER | AST_CHAN_TP_CREATESJITTER,
	.requester = sip_request_call,		/*!< Where we set up a call, but don't actually activate it */
	.devicestate = sip_devicestate,		/*!< Checking the status of a known SIP device */
	.call = sip_call,			/*!< Try calling Bob, says Alice */
	.hangup = sip_hangup,			/*!< Alice does not want to talk to Bob any more */
	.answer = sip_answer,			/*!< Bob answers the call */
	.read = sip_read,			/*!< Deliver media to the PBX */
	.write = sip_write,			/*!< Get media from the PBX side */
	.write_video = sip_write,		/*!< Get video media from the PBX side */
	.indicate = sip_indicate,		/*!< Get indications from the PBX side */
	.transfer = sip_transfer,		/*!< Transfer a call, severely broken */
	.fixup = sip_fixup,
	.send_digit_begin = sip_senddigit_begin,	/*!< DTMF support */
	.send_digit_end = sip_senddigit_end,		/*!< DTMF support */
	.bridge = ast_rtp_bridge,
	.early_bridge = ast_rtp_early_bridge,
	.send_text = sip_sendtext,		/*!< Get text from the PBX to send out */
};

/*! \brief This version of the sip channel tech has no send_digit_begin
 *  callback.  This is for use with channels using SIP INFO DTMF so that
 *  the core knows that the channel doesn't want DTMF BEGIN frames. */
static const struct ast_channel_tech sip_tech_info = {
	.type = "SIP",
	.description = "Session Initiation Protocol (SIP)",
	.capabilities = ((AST_FORMAT_MAX_AUDIO << 1) - 1),
	.properties = AST_CHAN_TP_WANTSJITTER | AST_CHAN_TP_CREATESJITTER,
	.requester = sip_request_call,		/*!< Where we set up a call, but don't actually activate it */
	.devicestate = sip_devicestate,		/*!< Checking the status of a known SIP device */
	.call = sip_call,			/*!< Try calling Bob, says Alice */
	.hangup = sip_hangup,			/*!< Alice does not want to talk to Bob any more */
	.answer = sip_answer,			/*!< Bob answers the call */
	.read = sip_read,			/*!< Deliver media to the PBX */
	.write = sip_write,			/*!< Get media from the PBX side */
	.write_video = sip_write,		/*!< Get video media from the PBX side */
	.indicate = sip_indicate,		/*!< Get indications from the PBX side */
	.transfer = sip_transfer,		/*!< Transfer a call, severely broken */
	.fixup = sip_fixup,
	.send_digit_end = sip_senddigit_end,		/*!< DTMF support */
	.bridge = ast_rtp_bridge,
	.early_bridge = ast_rtp_early_bridge,
	.send_text = sip_sendtext,		/*!< Get text from the PBX to send out */
};


/*! \brief Send SIP MESSAGE text within a call
	Called from PBX core sendtext() application */
static int sip_sendtext(struct ast_channel *ast, const char *text)
{
	struct sip_dialog *dialog = ast->tech_pvt;
	int debug = sip_debug_test_pvt(dialog);

	if (!dialog)
		return -1;
	if (ast_strlen_zero(text))
		return 0;
	if (debug)
		ast_verbose("Really sending text %s on %s\n", text, ast->name);
	transmit_message_with_text(dialog, text);
	return 0;	
}


/*! \brief Set nat mode on the various media streams */
GNURK void do_setnat(struct sip_dialog *dialog, int natflags)
{
	const char *mode = natflags ? "On" : "Off";

	if (dialog->rtp) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Setting NAT on RTP to %s\n", mode);
		ast_rtp_setnat(dialog->rtp, natflags);
	}
	if (dialog->vrtp) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Setting NAT on VRTP to %s\n", mode);
		ast_rtp_setnat(dialog->vrtp, natflags);
	}
	if (dialog->udptl) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Setting NAT on UDPTL to %s\n", mode);
		ast_udptl_setnat(dialog->udptl, natflags);
	}
}

/*! \brief Create address structure from device reference.
 *  return -1 on error, 0 on success.
 */
static int create_addr_from_peer(struct sip_dialog *dialog, struct sip_device *device)
{
	if ((device->addr.sin_addr.s_addr || device->defaddr.sin_addr.s_addr) &&
	    (!device->maxms || ((device->lastms >= 0)  && (device->lastms <= device->maxms)))) {
		dialog->sa = (device->addr.sin_addr.s_addr) ? device->addr : device->defaddr;
		dialog->recv = dialog->sa;
	} else 
		return -1;

	ast_copy_flags(&dialog->flags[0], &device->flags[0], SIP_FLAGS_TO_COPY);
	ast_copy_flags(&dialog->flags[1], &device->flags[1], SIP_PAGE2_FLAGS_TO_COPY);
	dialog->capability = device->capability;
	if (!ast_test_flag(&dialog->flags[1], SIP_PAGE2_VIDEOSUPPORT) && dialog->vrtp) {
		ast_rtp_destroy(dialog->vrtp);
		dialog->vrtp = NULL;
	}
	dialog->prefs = device->prefs;
	if (ast_test_flag(&dialog->flags[1], SIP_PAGE2_T38SUPPORT)) {
		dialog->t38.capability = global.t38_capability;
		if (dialog->udptl) {
			if (ast_udptl_get_error_correction_scheme(dialog->udptl) == UDPTL_ERROR_CORRECTION_FEC )
				dialog->t38.capability |= T38FAX_UDP_EC_FEC;
			else if (ast_udptl_get_error_correction_scheme(dialog->udptl) == UDPTL_ERROR_CORRECTION_REDUNDANCY )
				dialog->t38.capability |= T38FAX_UDP_EC_REDUNDANCY;
			else if (ast_udptl_get_error_correction_scheme(dialog->udptl) == UDPTL_ERROR_CORRECTION_NONE )
				dialog->t38.capability |= T38FAX_UDP_EC_NONE;
			dialog->t38.capability |= T38FAX_RATE_MANAGEMENT_TRANSFERED_TCF;
			if (option_debug > 1)
				ast_log(LOG_DEBUG,"Our T38 capability (%d)\n", dialog->t38.capability);
		}
		dialog->t38.jointcapability = dialog->t38.capability;
	} else if (dialog->udptl) {
		ast_udptl_destroy(dialog->udptl);
		dialog->udptl = NULL;
	}
	do_setnat(dialog, ast_test_flag(&dialog->flags[0], SIP_NAT) & SIP_NAT_ROUTE );

	if (dialog->rtp) {
		ast_rtp_setdtmf(dialog->rtp, ast_test_flag(&dialog->flags[0], SIP_DTMF) != SIP_DTMF_INFO);
		ast_rtp_setdtmfcompensate(dialog->rtp, ast_test_flag(&dialog->flags[1], SIP_PAGE2_RFC2833_COMPENSATE));
	}
	if (dialog->vrtp) {
		ast_rtp_setdtmf(dialog->vrtp, 0);
		ast_rtp_setdtmfcompensate(dialog->vrtp, 0);
	}

	/* Set Frame packetization */
	if (dialog->rtp) {
		ast_rtp_codec_setpref(dialog->rtp, &dialog->prefs);
		dialog->autoframing = device->autoframing;
	}

	/* XXX Why use username for all of this? */
	//ast_string_field_set(dialog, peername, device->defaultuser);

	ast_string_field_set(dialog, peername, device->name);
	/* Authuser is fromuser, and if that not is set, it's the defaultuser, if that's set */
	
	if (ast_strlen_zero(device->extra.fromuser))
		ast_string_field_set(dialog, authname, device->defaultuser);
	else
		ast_string_field_set(dialog, authname, device->extra.fromuser);
	ast_string_field_set(dialog, defaultuser, device->defaultuser);
	ast_string_field_set(dialog, peersecret, device->secret);
	ast_string_field_set(dialog, peermd5secret, device->md5secret);
	ast_string_field_set(dialog, tohost, device->extra.tohost);
	ast_string_field_set(dialog, mohinterpret, device->extra.mohinterpret);
	ast_string_field_set(dialog, mohsuggest, device->extra.mohsuggest);
	ast_string_field_set(dialog, fullcontact, device->fullcontact);
	if (!dialog->initreq && !ast_strlen_zero(device->extra.fromdomain)) {
		char *tmpcall;
		char *c;
		tmpcall = ast_strdupa(dialog->callid);
		c = strchr(tmpcall, '@');
		if (c) {
			*c = '\0';
			ast_string_field_build(dialog, callid, "%s@%s", tmpcall, device->extra.fromdomain);
		}
	}
	dialog->outboundproxy = obproxy_get(dialog, device);
	if (ast_strlen_zero(dialog->tohost))
		ast_string_field_set(dialog, tohost, ast_inet_ntoa(dialog->sa.sin_addr));
	if (!ast_strlen_zero(device->extra.fromdomain))
		ast_string_field_set(dialog, fromdomain, device->extra.fromdomain);
	if (!ast_strlen_zero(device->extra.fromuser))
		ast_string_field_set(dialog, fromuser, device->extra.fromuser);
	dialog->callgroup = device->callgroup;
	dialog->pickupgroup = device->pickupgroup;
	dialog->allowtransfer = device->allowtransfer;
	/* Set timer T1 to RTT for this peer (if known by qualify=) */
	/* Minimum is settable or default to 100 ms */
	if (device->maxms && device->lastms)
		dialog->timer_t1 = device->lastms < global.t1min ? global.t1min : device->lastms;
	if ((ast_test_flag(&dialog->flags[0], SIP_DTMF) == SIP_DTMF_RFC2833) ||
	    (ast_test_flag(&dialog->flags[0], SIP_DTMF) == SIP_DTMF_AUTO))
		dialog->noncodeccapability |= AST_RTP_DTMF;
	else
		dialog->noncodeccapability &= ~AST_RTP_DTMF;
	ast_string_field_set(dialog, context, device->extra.context);
	ast_rtp_set_rtptimeout(dialog->rtp, device->rtptimer.rtptimeout);
	ast_rtp_set_rtpholdtimeout(dialog->rtp, device->rtptimer.rtpholdtimeout);
	ast_rtp_set_rtpkeepalive(dialog->rtp, device->rtptimer.rtpkeepalive);
	if (dialog->vrtp) {
		ast_rtp_set_rtptimeout(dialog->vrtp, device->rtptimer.rtptimeout);
		ast_rtp_set_rtpholdtimeout(dialog->vrtp, device->rtptimer.rtpholdtimeout);
		ast_rtp_set_rtpkeepalive(dialog->vrtp, device->rtptimer.rtpkeepalive);
	}
	if (device->call_limit)
		ast_set_flag(&dialog->flags[0], SIP_CALL_LIMIT);
	dialog->maxcallbitrate = device->maxcallbitrate;
	
	return 0;
}

/*! \brief create address structure from peer name
 *      Or, if peer not found, find it in the global DNS 
 *      returns TRUE (-1) on failure, FALSE on success */
GNURK int create_addr(struct sip_dialog *dialog, const char *username, char *domain, const char *device)
{
	struct hostent *hp;
	struct ast_hostent ahp;
	struct sip_device *p = NULL;
	char *port;
	int portno;
	char host[MAXHOSTNAMELEN], *hostn;
	char peername[256];
	char todomain[256];
	int srvcheck = TRUE;


	dialog->sa.sin_family = AF_INET;
	dialog->timer_t1 = global.t1default; /* Default SIP retransmission timer T1 (RFC 3261) */
	if (!ast_strlen_zero(device)) {
		int res;

		p = find_device(device, NULL, 1);

		if (p)  {
			res = create_addr_from_peer(dialog, p);
			device_unref(p);
			return res;
		} else {
			if (option_verbose > 1)
				ast_verbose("Can't find peer %s\n", device);

			return -1;	/* Can't find peer */
		}
	}
	
	ast_string_field_set(dialog, tohost, domain);

	/* Get the outbound proxy information */
	dialog->outboundproxy = obproxy_get(dialog, NULL);

	/* If we have an outbound proxy, don't bother with DNS resolution at all */
	if (dialog->outboundproxy)
		return 0;

	/* See if we have a port. If we have a given port,
		disable SRV lookups */
	if (!ast_strlen_zero(domain)) {
		ast_copy_string(todomain, domain, sizeof(todomain));
		port = strchr(todomain, ':');
	}
	if (port) {
		*port++ = '\0';
		srvcheck = FALSE;
	}

	hostn = domain;
	portno = port ? atoi(port) : STANDARD_SIP_PORT;

	if (global.srvlookup && srvcheck) {
		char service[MAXHOSTNAMELEN];
		int tportno;
		int ret;

		snprintf(service, sizeof(service), "_sip._udp.%s", domain);
		ret = ast_get_srv(NULL, host, sizeof(host), &tportno, service);
		if (ret > 0) {
			hostn = host;
			portno = tportno;
			if (option_debug > 2)
				ast_log(LOG_DEBUG, "Resolved domain %s to host %s in SRV \n", domain, hostn);
		}
	} 
	hp = ast_gethostbyname(hostn, &ahp);
	if (!hp) {
		ast_log(LOG_WARNING, "No such host: %s\n", peername);
		return -2;
	}
	memcpy(&dialog->sa.sin_addr, hp->h_addr, sizeof(dialog->sa.sin_addr));
	dialog->sa.sin_port = htons(portno);
	dialog->recv = dialog->sa;
	return 0;
}

/*! \brief Scheduled congestion on a call */
static int auto_congest(void *nothing)
{
	struct sip_dialog *dialog = nothing;

	dialog_lock(dialog, TRUE);
	dialog->initid = -1;
	if (dialog->owner) {
		/* XXX fails on possible deadlock */
		if (!ast_channel_trylock(dialog->owner)) {
			ast_log(LOG_NOTICE, "Auto-congesting %s\n", dialog->owner->name);
			append_history(dialog, "Cong", "Auto-congesting (timer)");
			ast_queue_control(dialog->owner, AST_CONTROL_CONGESTION);
			ast_channel_unlock(dialog->owner);
		}
	}
	dialog_lock(dialog, FALSE);
	return 0;
}


/*! \brief Initiate SIP call from PBX 
 *      used from the dial() application      */
static int sip_call(struct ast_channel *ast, char *dest, int timeout)
{
	int res;
	struct sip_dialog *p;
	struct varshead *headp;
	struct ast_var_t *current;
	const char *referer = NULL;   /* SIP refererer */	

	p = ast->tech_pvt;
	if ((ast->_state != AST_STATE_DOWN) && (ast->_state != AST_STATE_RESERVED)) {
		ast_log(LOG_WARNING, "sip_call called on %s, neither down nor reserved\n", ast->name);
		return -1;
	}

	/* Check whether there is vxml_url, distinctive ring variables */
	headp=&ast->varshead;
	AST_LIST_TRAVERSE(headp,current,entries) {
		/* Check whether there is a VXML_URL variable */
		if (!p->inviteoptions->vxml_url && !strcasecmp(ast_var_name(current), "VXML_URL")) {
			p->inviteoptions->vxml_url = ast_var_value(current);
		} else if (!p->inviteoptions->uri_options && !strcasecmp(ast_var_name(current), "SIP_URI_OPTIONS")) {
			p->inviteoptions->uri_options = ast_var_value(current);
		} else if (!p->inviteoptions->addsipheaders && !strncasecmp(ast_var_name(current), "SIPADDHEADER", strlen("SIPADDHEADER"))) {
			/* Check whether there is a variable with a name starting with SIPADDHEADER */
			p->inviteoptions->addsipheaders = 1;
		} else if (!strcasecmp(ast_var_name(current), "SIPTRANSFER")) {
			/* This is a transfered call */
			p->inviteoptions->transfer = 1;
		} else if (!strcasecmp(ast_var_name(current), "SIPTRANSFER_REFERER")) {
			/* This is the referer */
			referer = ast_var_value(current);
		} else if (!strcasecmp(ast_var_name(current), "SIPTRANSFER_REPLACES")) {
			/* We're replacing a call. */
			p->inviteoptions->replaces = ast_var_value(current);
		} else if (!strcasecmp(ast_var_name(current), "T38CALL")) {
			p->t38.state = T38_LOCAL_DIRECT;
			if (option_debug)
				ast_log(LOG_DEBUG,"T38State change to %d on channel %s\n", p->t38.state, ast->name);
		}

	}
	
	res = 0;
	ast_set_flag(&p->flags[0], SIP_OUTGOING);

	if (p->inviteoptions->transfer) {
		char buf[BUFSIZ/2];

		if (referer) {
			if (sipdebug && option_debug > 2)
				ast_log(LOG_DEBUG, "Call for %s transfered by %s\n", p->peername, referer);
			snprintf(buf, sizeof(buf)-1, "-> %s (via %s)", p->cid_name, referer);
		} else 
			snprintf(buf, sizeof(buf)-1, "-> %s", p->cid_name);
		ast_string_field_set(p, cid_name, buf);
	} 
	if (option_debug)
		ast_log(LOG_DEBUG, "Outgoing Call for %s\n", p->peername);

	res = update_call_counter(p, INC_CALL_RINGING);
	if ( res != -1 ) {
		p->callingpres = ast->cid.cid_pres;
		p->jointcapability = ast_translate_available_formats(p->capability, p->prefcodec);
		p->jointnoncodeccapability = p->noncodeccapability;
		if (!(p->jointcapability & AST_FORMAT_AUDIO_MASK)) {	
			ast_log(LOG_WARNING, "No audio formats found to offer. Cancelling call to %s\n", p->username);
			res = -1;
		} else {
			p->t38.jointcapability = p->t38.capability;
			if (option_debug)
				ast_log(LOG_DEBUG,"Our T38 capability (%d), joint T38 capability (%d)\n", p->t38.capability, p->t38.jointcapability);
			transmit_invite(p, SIP_INVITE, TRUE, 2);
			/* SIP timer B - Invite transaction timeout time */
			p->initid = ast_sched_add(sched, global.siptimer_b, auto_congest, p);
		}
	}
	return res;
}

/*! \brief  update_call_counter: Handle call_limit for SIP users 
 * Setting a call-limit will cause calls above the limit not to be accepted.
 *
 * Remember that for a type=friend, there's one limit for the user and
 * another for the peer, not a combined call limit.
 * This will cause unexpected behaviour in subscriptions, since a "friend"
 * is *two* devices in Asterisk, not one.
 *
 * Thought: For realtime, we should propably update storage with inuse counter... 
 *
 * \return 0 if call is ok (no call limit, below treshold)
 *	-1 on rejection of call
 *		
 */
GNURK int update_call_counter(struct sip_dialog *fup, int event)
{
	char name[256];
	int outgoing = ast_test_flag(&fup->flags[0], SIP_OUTGOING);
	struct sip_device *device = NULL;

	if (option_debug > 2)
		ast_log(LOG_DEBUG, "Updating call counter for %s call\n", outgoing ? "outgoing" : "incoming");
	/* Test if we need to check call limits, in order to avoid 
	   realtime lookups if we do not need it */
	if (!ast_test_flag(&fup->flags[0], SIP_CALL_LIMIT))
		return 0;

	ast_copy_string(name, fup->peername, sizeof(name));

	/* Check the list of devices */
	device = find_device(fup->peername, NULL, 1);
	if (!device) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "%s is not a local device, no call limit\n", name);
		return 0;
	}

	switch(event) {
		/* incoming and outgoing affects the inUse counter */
		case DEC_CALL_LIMIT:
			if ( device->inUse > 0 ) {
				if (ast_test_flag(&fup->flags[0], SIP_INC_COUNT))
					device->inUse--;
			} else {
				device->inUse= 0;
			}
			if (ast_test_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING)) {
				if (device->inRinging > 0)
					(device->inRinging)--;
				else
					ast_log(LOG_WARNING, "Inringing for peer '%s' < 0?\n", fup->peername);
				ast_clear_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING);
			}
			if (option_debug > 1 || sipdebug) {
				ast_log(LOG_DEBUG, "Call %s %s '%s' removed from call limit %d\n", outgoing ? "to" : "from", device->type & SIP_USER ? "user":"peer", name, device->call_limit);
			}
			break;
		case INC_CALL_RINGING:
		case INC_CALL_LIMIT:
			if (device->call_limit > 0 ) {
				if (device->inUse >= device->call_limit) {
					ast_log(LOG_ERROR, "Call %s %s '%s' rejected due to usage limit of %d\n", outgoing ? "to" : "from", device->type & SIP_USER ? "user":"peer", name, device->call_limit);
					device_unref(device);
					return -1; 
				}
			}
			if (event == INC_CALL_RINGING) {
				if (!ast_test_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING)) {
					device->inRinging++;
					ast_set_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING);
				}
			}
			/* Continue */
			device->inUse++;
			ast_set_flag(&fup->flags[0], SIP_INC_COUNT);
			if (option_debug > 1 || sipdebug) {
				ast_log(LOG_DEBUG, "Call %s %s '%s' is %d out of %d\n", outgoing ? "to" : "from", device->type & SIP_USER ? "user" : "peer", name, device->inUse, device->call_limit);
			}
			break;
		case DEC_CALL_RINGING:
			if (ast_test_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING)) {
				if (device->inRinging > 0)
						device->inRinging--;
				else
					ast_log(LOG_WARNING, "Inringing for peer '%s' < 0?\n", device->name);
				ast_clear_flag(&fup->flags[1], SIP_PAGE2_INC_RINGING);
			}
			break;
		default:
			ast_log(LOG_ERROR, "update_call_counter(%s, %d) called with no event!\n", name, event);
	}
	ast_device_state_changed("SIP/%s", device->name);
	device_unref(device);
	return 0;
}

/*! \brief  sip_hangup: Hangup SIP call
 * Part of PBX interface, called from ast_hangup */
static int sip_hangup(struct ast_channel *ast)
{
	struct sip_dialog *p = ast->tech_pvt;
	int needcancel = FALSE;
	int needdestroy = 0;
	struct ast_channel *oldowner = ast;

	if (!p) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Asked to hangup channel that was not connected\n");
		return 0;
	}

	if (ast_test_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER)) {
		if (option_debug >3)
			ast_log(LOG_DEBUG, "SIP Transfer: Not hanging up right now... Rescheduling hangup for %s.\n", p->callid);
		if (p->autokillid > -1)
			sip_cancel_destroy(p);
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);	/* This does not issue BYE  - fix needed */
		ast_clear_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER);	/* Really hang up next time */
		ast_clear_flag(&p->flags[0], SIP_NEEDDESTROY);
		p->owner->tech_pvt = NULL;
		p->owner = NULL;  /* Owner will be gone after we return, so take it away */
		return 0;
	}
	if (option_debug > 1) {
		if (ast_test_flag(ast, AST_FLAG_ZOMBIE) && p->refer && option_debug)
         		ast_log(LOG_DEBUG, "SIP Transfer: Hanging up Zombie channel %s after transfer ... Call-ID: %s\n", ast->name, p->callid);
		else  
			ast_log(LOG_DEBUG, "Hangup call %s, SIP callid %s)\n", ast->name, p->callid);
	}
	if (option_debug > 1 && ast_test_flag(ast, AST_FLAG_ZOMBIE)) 
		ast_log(LOG_DEBUG, "Hanging up zombie call. Be scared.\n");

	dialog_lock(p, TRUE);
	if (option_debug && sipdebug)
		ast_log(LOG_DEBUG, "update_call_counter(%s) - decrement call limit counter on hangup\n", p->peername);
	update_call_counter(p, DEC_CALL_LIMIT);		/* Fix call limit counter */

	/* Determine how to disconnect */
	if (p->owner != ast) {
		ast_log(LOG_WARNING, "Huh?  We aren't the owner? Can't hangup call.\n");
		dialog_lock(p, FALSE);
		return 0;
	}
	/* If the call is not UP, we need to send CANCEL instead of BYE */
	/*! \note XXX This need to check invitestate to handle early media !!!*/
	/* The p-owner check is for re-invites. We have to separate transaction and
		dialog state! */
	if (p->state < INV_STATE_COMPLETED && p->owner->_state != AST_STATE_UP) {
		needcancel = TRUE;
		if (option_debug > 3) {
			ast_log(LOG_DEBUG, "Hanging up channel in AST state %s (not UP)\n", ast_state2str(ast->_state));
			ast_log(LOG_DEBUG, "Hanging up channel in SIP state %s\n", dialogstate2str(p->state));
		}
	}

	/* Disconnect */
	if (p->vad)
		ast_dsp_free(p->vad);

	/* Disconnect us from the owner */
	p->owner = NULL;
	ast->tech_pvt = NULL;

	ast_module_unref(ast_module_info->self);

	/* Do not destroy this pvt until we have timeout or
	   get an answer to the BYE or INVITE/CANCEL 
	   If we get no answer during retransmit period, drop the call anyway.
	   (Sorry, mother-in-law, you can't deny a hangup by sending
	   603 declined to BYE...)
	*/
	if (ast_test_flag(&p->flags[0], SIP_ALREADYGONE))
		needdestroy = 1;	/* Set destroy flag at end of this function */
	else	/* ONLY do this if we're in UP state */
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);

	/* Start the process if it's not already started */
	if (!ast_test_flag(&p->flags[0], SIP_ALREADYGONE) && !ast_strlen_zero(p->initreq->data)) {
		if (needcancel) {	/* Outgoing call, not up */
			if (ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
				/* stop retransmitting an INVITE that has not received a response */
				__sip_pretend_ack(p);

				/* if we can't send right now, mark it pending */
				if (p->state == DIALOG_STATE_TRYING) {
					ast_set_flag(&p->flags[0], SIP_PENDINGBYE);
					/* Do we need a timer here if we don't hear from them at all? */
				} else {
					/* Send a new request: CANCEL */
					transmit_request_with_auth(p, SIP_CANCEL, p->ocseq, XMIT_RELIABLE, FALSE);
					/* Actually don't destroy us yet, wait for the 487 on our original 
					   INVITE, but do set an autodestruct just in case we never get it. */
					needdestroy = 0;
					sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
					dialogstatechange(p, DIALOG_STATE_TERMINATED);
				}
				if ( p->initid != -1 ) {
					/* channel still up - reverse dec of inUse counter
					   only if the channel is not auto-congested */
					update_call_counter(p, INC_CALL_LIMIT);
				}
			} else {	/* Incoming call, not up */
				const char *res;
				if (ast->hangupcause && (res = hangup_cause2sip(ast->hangupcause)))
					transmit_response_reliable(p, res, p->initreq);
				else 
					transmit_response_reliable(p, "603 Declined", p->initreq);
				dialogstatechange(p, DIALOG_STATE_TERMINATED);
			}
		} else {	/* Call is in UP state, send BYE */
			if (!p->pendinginvite) {
				char *audioqos = "";
				char *videoqos = "";
				if (p->rtp)
					audioqos = ast_rtp_get_quality(p->rtp);
				if (p->vrtp)
					videoqos = ast_rtp_get_quality(p->vrtp);

				/* Get RTCP quality before end of call */
				if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY)) {
					if (p->rtp)
						append_history(p, "RTCPaudio", "Quality:%s", audioqos);
					if (p->vrtp)
						append_history(p, "RTCPvideo", "Quality:%s", videoqos);
				}
				if (p->rtp && oldowner)
					pbx_builtin_setvar_helper(oldowner, "RTPAUDIOQOS", audioqos);
				if (p->vrtp && oldowner)
					pbx_builtin_setvar_helper(oldowner, "RTPVIDEOQOS", videoqos);
				dialogstatechange(p, DIALOG_STATE_TERMINATED);

				/* Send a hangup */
				transmit_request_with_auth(p, SIP_BYE, 0, XMIT_RELIABLE, 1);
			} else {
				/* Note we will need a BYE when this all settles out
				   but we can't send one while we have "INVITE" outstanding. */
				ast_set_flag(&p->flags[0], SIP_PENDINGBYE);	
				ast_clear_flag(&p->flags[0], SIP_NEEDREINVITE);	
				sip_cancel_destroy(p);
			}
		}
	}
	if (needdestroy)
		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);

	if(!ast_test_flag(&p->flags[0], SIP_PENDINGBYE))
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);	/* If we don't get answer in 32 secs, destroy */
	dialog_lock(p, FALSE);
	return 0;
}

/*! \brief Try setting codec suggested by the SIP_CODEC channel variable */
GNURK void try_suggested_sip_codec(struct sip_dialog *p)
{
	int fmt;
	const char *codec;

	codec = pbx_builtin_getvar_helper(p->owner, "SIP_CODEC");
	if (!codec) 
		return;

	fmt = ast_getformatbyname(codec);
	if (fmt) {
		ast_log(LOG_NOTICE, "Changing codec to '%s' for this call because of ${SIP_CODEC} variable\n", codec);
		if (p->jointcapability & fmt) {
			p->jointcapability &= fmt;
			p->capability &= fmt;
		} else
			ast_log(LOG_NOTICE, "Ignoring ${SIP_CODEC} variable because it is not shared by both ends.\n");
	} else
		ast_log(LOG_NOTICE, "Ignoring ${SIP_CODEC} variable because of unrecognized/not configured codec (check allow/disallow in sip.conf): %s\n", codec);
	return;	
}

/*! \brief  sip_answer: Answer SIP call , send 200 OK on Invite 
 * Part of PBX interface */
static int sip_answer(struct ast_channel *ast)
{
	int res = 0;
	struct sip_dialog *dialog = ast->tech_pvt;

	dialog_lock(dialog, TRUE);
	if (ast->_state != AST_STATE_UP) {
		try_suggested_sip_codec(dialog);	

		ast_setstate(ast, AST_STATE_UP);
		if (option_debug)
			ast_log(LOG_DEBUG, "SIP answering channel: %s\n", ast->name);
		if (dialog->t38.state == T38_PEER_DIRECT) {
			dialog->t38.state = T38_ENABLED;
			if (option_debug > 1)
				ast_log(LOG_DEBUG,"T38State change to %d on channel %s\n", dialog->t38.state, ast->name);
			res = transmit_response_with_attachment(WITH_T38_SDP, dialog, "200 OK", dialog->initreq, XMIT_CRITICAL);
		} else 
			res = transmit_response_with_attachment(WITH_SDP, dialog, "200 OK", dialog->initreq, XMIT_CRITICAL);
		dialogstatechange(dialog, DIALOG_STATE_CONFIRMED);
	}
	dialog_lock(dialog, FALSE);
	return res;
}

/*! Write a media frame (audio, video, text) to the dialogs RTP stream.
 *   If needed, issue early media with 183
*/
static int write_media_frame(struct ast_channel *ast, struct sip_dialog *p, struct ast_frame *frame, struct ast_rtp *mediartp)
{
	int res = 0;
	if (!p)
		return AST_FAILURE;

	dialog_lock(p, TRUE);
	if (mediartp) {
		/* If channel is not up, activate early media session */
		if ((ast->_state != AST_STATE_UP) &&
		    !ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) &&
		    !ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
			transmit_response_with_attachment(WITH_SDP, p, "183 Session Progress", p->initreq, XMIT_UNRELIABLE);
			ast_set_flag(&p->flags[0], SIP_PROGRESS_SENT);	
		}
		p->lastrtptx = time(NULL);
		res = ast_rtp_write(mediartp, frame);
	}
	dialog_lock(p, FALSE);
	return res;
}

/*! \brief Send frame to media channel (rtp) :: PBX interface */
static int sip_write(struct ast_channel *ast, struct ast_frame *frame)
{
	struct sip_dialog *p = ast->tech_pvt;
	int res = 0;

	switch (frame->frametype) {
	case AST_FRAME_VOICE:
		if (!(frame->subclass & ast->nativeformats)) {
			char s1[512], s2[512], s3[512];
			ast_log(LOG_WARNING, "Asked to transmit frame type %d, while native formats is %s(%d) read/write = %s(%d)/%s(%d)\n",
				frame->subclass, 
				ast_getformatname_multiple(s1, sizeof(s1) - 1, ast->nativeformats & AST_FORMAT_AUDIO_MASK),
				ast->nativeformats & AST_FORMAT_AUDIO_MASK,
				ast_getformatname_multiple(s2, sizeof(s2) - 1, ast->readformat),
				ast->readformat,
				ast_getformatname_multiple(s3, sizeof(s3) - 1, ast->writeformat),
				ast->writeformat);
			return 0;
		}
		if (p && p->rtp)
			res = write_media_frame(ast, p, frame, p->rtp);
		break;
	case AST_FRAME_VIDEO:
		if (p && p->vrtp)
			res = write_media_frame(ast, p, frame, p->vrtp);
		break;
	case AST_FRAME_IMAGE:
		return 0;
		break;
	case AST_FRAME_MODEM:
		if (p) {
			dialog_lock(p, TRUE);
			if (p->udptl && ast->_state == AST_STATE_UP)
				res = ast_udptl_write(p->udptl, frame);
			dialog_lock(p, FALSE);
		}
		break;
	default: 
		ast_log(LOG_WARNING, "Can't send %d type frames with SIP write\n", frame->frametype);
		return 0;
	}

	return res;
}

/*! \brief  sip_fixup: Fix up a channel:  If a channel is consumed, this is called.
        Basically update any ->owner links :: PBX interface */
static int sip_fixup(struct ast_channel *oldchan, struct ast_channel *newchan)
{
	int ret = -1;
	struct sip_dialog *p;

	if (newchan && ast_test_flag(newchan, AST_FLAG_ZOMBIE) && option_debug)
		ast_log(LOG_DEBUG, "New channel is zombie\n");
	if (oldchan && ast_test_flag(oldchan, AST_FLAG_ZOMBIE) && option_debug)
		ast_log(LOG_DEBUG, "Old channel is zombie\n");

	if (!newchan || !newchan->tech_pvt) {
		if (!newchan)
			ast_log(LOG_WARNING, "No new channel! Fixup of %s failed.\n", oldchan->name);
		else
			ast_log(LOG_WARNING, "No SIP tech_pvt! Fixup of %s failed.\n", oldchan->name);
		return -1;
	}
	p = newchan->tech_pvt;

	dialog_lock(p, TRUE);
	append_history(p, "Masq", "Old channel: %s\n", oldchan->name);
	append_history(p, "Masq (cont)", "...new owner: %s\n", newchan->name);
	if (p->owner != oldchan)
		ast_log(LOG_WARNING, "old channel wasn't %p but was %p\n", oldchan, p->owner);
	else {
		p->owner = newchan;
		ret = 0;
	}
	if (option_debug > 2)
		ast_log(LOG_DEBUG, "SIP Fixup: New owner for dialogue %s: %s (Old parent: %s)\n", p->callid, p->owner->name, oldchan->name);

	dialog_lock(p, FALSE);
	return ret;
}

/*! \brief Start sending DTMF character on SIP channel
	within one call, we're able to transmit in many methods simultaneously */
static int sip_senddigit_begin(struct ast_channel *ast, char digit)
{
	struct sip_dialog *p = ast->tech_pvt;
	int res = 0;

	dialog_lock(p, TRUE);
	switch (ast_test_flag(&p->flags[0], SIP_DTMF)) {
	case SIP_DTMF_INBAND:
		res = -1; /* Tell Asterisk to generate inband indications */
		break;
	case SIP_DTMF_RFC2833:
		if (p->rtp)
			ast_rtp_senddigit_begin(p->rtp, digit);
		break;
	default:
		break;
	}
	dialog_lock(p, FALSE);

	return res;
}

/*! \brief Send DTMF character on SIP channel
	within one call, we're able to transmit in many methods simultaneously */
static int sip_senddigit_end(struct ast_channel *ast, char digit, unsigned int duration)
{
	struct sip_dialog *p = ast->tech_pvt;
	int res = 0;

	dialog_lock(p, TRUE);
	switch (ast_test_flag(&p->flags[0], SIP_DTMF)) {
	case SIP_DTMF_INFO:
		transmit_info_with_digit(p, digit, duration);
		break;
	case SIP_DTMF_RFC2833:
		if (p->rtp)
			ast_rtp_senddigit_end(p->rtp, digit);
		break;
	case SIP_DTMF_INBAND:
		res = -1; /* Tell Asterisk to stop inband indications */
		break;
	}
	dialog_lock(p, FALSE);

	return res;
}

/*! \brief Transfer SIP call :: PBX interface */
static int sip_transfer(struct ast_channel *ast, const char *dest)
{
	struct sip_dialog *p = ast->tech_pvt;
	int res;

	if (dest == NULL)
		dest = "";
	dialog_lock(p, TRUE);
	if (ast->_state == AST_STATE_RING)
		res = sip_sipredirect(p, dest);
	else
		res = transmit_refer(p, dest);
	dialog_lock(p, FALSE);
	return res;
}

/*! \brief Play indication to user :: PBX interface  
 * With SIP a lot of indications is sent as messages, letting the device play
   the indication - busy signal, congestion etc 
   \return -1 to force ast_indicate to send indication in audio, 0 if SIP can handle the indication by sending a message
*/
static int sip_indicate(struct ast_channel *ast, int condition, const void *data, size_t datalen)
{
	struct sip_dialog *p = ast->tech_pvt;
	int res = 0;

	dialog_lock(p, TRUE);
	switch(condition) {
	case AST_CONTROL_RINGING:
		if (ast->_state == AST_STATE_RING) {
			if (!ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) ||
			    (ast_test_flag(&p->flags[0], SIP_PROG_INBAND) == SIP_PROG_INBAND_NEVER)) {				
				/* Send 180 ringing if out-of-band seems reasonable */
				transmit_response(p, "180 Ringing", p->initreq);
				ast_set_flag(&p->flags[0], SIP_RINGING);
				dialogstatechange(p, DIALOG_STATE_PROCEEDING);
				if (ast_test_flag(&p->flags[0], SIP_PROG_INBAND) != SIP_PROG_INBAND_YES)
					break;
			} else {
				/* Well, if it's not reasonable, just send in-band */
			}
		}
		res = -1;
		break;
	case AST_CONTROL_BUSY:
		if (ast->_state != AST_STATE_UP) {
			transmit_final_response(p, "486 Busy Here", p->initreq, XMIT_RELIABLE);
			ast_softhangup_nolock(ast, AST_SOFTHANGUP_DEV);
			dialogstatechange(p, DIALOG_STATE_CONFIRMED);
			break;
		}
		res = -1;
		break;
	case AST_CONTROL_CONGESTION:
		if (ast->_state != AST_STATE_UP) {
			transmit_final_response(p, "503 Service Unavailable", p->initreq, XMIT_RELIABLE);
			ast_softhangup_nolock(ast, AST_SOFTHANGUP_DEV);
			dialogstatechange(p, DIALOG_STATE_CONFIRMED);
			break;
		}
		res = -1;
		break;
	case AST_CONTROL_PROCEEDING:
		if ((ast->_state != AST_STATE_UP) &&
		    !ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) &&
		    !ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
			transmit_response(p, "100 Trying", p->initreq);
			dialogstatechange(p, DIALOG_STATE_PROCEEDING);
			break;
		}
		res = -1;
		break;
	case AST_CONTROL_PROGRESS:
		if ((ast->_state != AST_STATE_UP) &&
		    !ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) &&
		    !ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
			transmit_response_with_attachment(WITH_SDP, p, "183 Session Progress", p->initreq, XMIT_UNRELIABLE);
			ast_set_flag(&p->flags[0], SIP_PROGRESS_SENT);	
			dialogstatechange(p, DIALOG_STATE_PROCEEDING);
			break;
		}
		res = -1;
		break;
	case AST_CONTROL_HOLD:
		ast_moh_start(ast, data, p->mohinterpret);
		break;
	case AST_CONTROL_UNHOLD:
		ast_moh_stop(ast);
		break;
	case AST_CONTROL_VIDUPDATE:	/* Request a video frame update */
		if (p->vrtp && !ast_test_flag(&p->flags[0], SIP_NOVIDEO)) {
			transmit_info_with_vidupdate(p);
			/* ast_rtcp_send_h261fur(p->vrtp); */
		} else
			res = -1;
		break;
	case -1:
		res = -1;
		break;
	default:
		ast_log(LOG_WARNING, "Don't know how to indicate condition %d\n", condition);
		res = -1;
		break;
	}
	dialog_lock(p, FALSE);
	return res;
}



/*! \brief Initiate a call in the SIP channel :: PBX interface

	called from sip_request_call (calls from the pbx ) for outbound channels
	and from handle_request_invite for inbound channels
	
*/
static struct ast_channel *sip_new(struct sip_dialog *dialog, int state, const char *title)
{
	struct ast_channel *tmp;
	struct ast_variable *v = NULL;
	int fmt;
	int what;
	int needvideo = 0;
	
	{
		const char *my_name;	/* pick a good name */
	
		if (title)
			my_name = title;
		else if ( (my_name = strchr(dialog->fromdomain,':')) )
			my_name++;	/* skip ':' */
		else
			my_name = dialog->fromdomain;

		dialog_lock(dialog, FALSE);
		/* Don't hold a sip pvt lock while we allocate a channel */

		tmp = ast_channel_alloc(1, state, dialog->cid_num, dialog->cid_name, "SIP/%s-%08x", my_name, (int)(long) dialog);

	}
	/* Lock the channel */
	dialog_lock(dialog, TRUE);
	if (!tmp) {
		ast_log(LOG_WARNING, "Unable to allocate AST channel structure for SIP channel\n");
		return NULL;
	}
	if (ast_test_flag(&dialog->flags[0], SIP_DTMF) == SIP_DTMF_INFO)
		tmp->tech = &sip_tech_info;
	else
		tmp->tech = &sip_tech;

	/* Select our native format based on codec preference until we receive
	   something from another device to the contrary. */
	if (dialog->jointcapability)	 	/* The joint capabilities of us and peer */
		what = dialog->jointcapability;
	else 
		what = dialog->capability ? dialog->capability : global.capability;

	/* Set the native formats for audio  and merge in video */
	tmp->nativeformats = ast_codec_choose(&dialog->prefs, what, 1) | (dialog->jointcapability & AST_FORMAT_VIDEO_MASK);
	if (option_debug > 2) {
		char buf[BUFSIZ];
		ast_log(LOG_DEBUG, "*** Our native formats are %s \n", ast_getformatname_multiple(buf, BUFSIZ, tmp->nativeformats));
		ast_log(LOG_DEBUG, "*** Joint capabilities are %s \n", ast_getformatname_multiple(buf, BUFSIZ, dialog->jointcapability));
		ast_log(LOG_DEBUG, "*** Our capabilities are %s \n", ast_getformatname_multiple(buf, BUFSIZ, dialog->capability));
		ast_log(LOG_DEBUG, "*** AST_CODEC_CHOOSE formats are %s \n", ast_getformatname_multiple(buf, BUFSIZ, ast_codec_choose(&dialog->prefs, what, 1)));
		if (dialog->prefcodec)
			ast_log(LOG_DEBUG, "*** Our preferred formats from the incoming channel are %s \n", ast_getformatname_multiple(buf, BUFSIZ, dialog->prefcodec));
	}

	/* XXX Why are we choosing a codec from the native formats?? */
	fmt = ast_best_codec(tmp->nativeformats);

	/* If we have a prefcodec setting, we have an inbound channel that set a 
	   preferred format for this call. Otherwise, we check the jointcapability
	   We also check for vrtp. If it's not there, we are not allowed do any video anyway.
	 */
	if (dialog->vrtp) {
		if (dialog->prefcodec)
			needvideo = dialog->prefcodec & AST_FORMAT_VIDEO_MASK;	/* Outbound call */
 		else
			needvideo = dialog->jointcapability & AST_FORMAT_VIDEO_MASK;	/* Inbound call */
	}

	if (option_debug > 2) {
		if (needvideo) 
			ast_log(LOG_DEBUG, "This channel can handle video! HOLLYWOOD next!\n");
		else
			ast_log(LOG_DEBUG, "This channel will not be able to handle video.\n");
	}

	/* Turn on dsp if we have inband DTMF (mixed in the audio stream) */
	if (ast_test_flag(&dialog->flags[0], SIP_DTMF) ==  SIP_DTMF_INBAND) {
		dialog->vad = ast_dsp_new();
		ast_dsp_set_features(dialog->vad, DSP_FEATURE_DTMF_DETECT);
		if (global.relaxdtmf)
			ast_dsp_digitmode(dialog->vad, DSP_DIGITMODE_DTMF | DSP_DIGITMODE_RELAXDTMF);
	}

	/* Set file descriptors for this channel */
	if (dialog->rtp) {
		tmp->fds[0] = ast_rtp_fd(dialog->rtp);
		tmp->fds[1] = ast_rtcp_fd(dialog->rtp);
	}
	if (needvideo && dialog->vrtp) {
		tmp->fds[2] = ast_rtp_fd(dialog->vrtp);
		tmp->fds[3] = ast_rtcp_fd(dialog->vrtp);
	}
	if (dialog->udptl)
		tmp->fds[5] = ast_udptl_fd(dialog->udptl);

	if (state == AST_STATE_RING)
		tmp->rings = 1;
	tmp->adsicpe = AST_ADSI_UNAVAILABLE;
	tmp->writeformat = fmt;
	tmp->rawwriteformat = fmt;
	tmp->readformat = fmt;
	tmp->rawreadformat = fmt;
	tmp->tech_pvt = dialog;

	tmp->callgroup = dialog->callgroup;
	tmp->pickupgroup = dialog->pickupgroup;
	tmp->cid.cid_pres = dialog->callingpres;
	if (!ast_strlen_zero(dialog->accountcode))
		ast_string_field_set(tmp, accountcode, dialog->accountcode);
	if (dialog->amaflags)
		tmp->amaflags = dialog->amaflags;
	if (!ast_strlen_zero(dialog->language))
		ast_string_field_set(tmp, language, dialog->language);
	dialog->owner = tmp;
	ast_module_ref(ast_module_info->self);
	ast_copy_string(tmp->context, dialog->context, sizeof(tmp->context));
	ast_copy_string(tmp->exten, dialog->exten, sizeof(tmp->exten));

	/* Don't use ast_set_callerid() here because it will
	 * generate a NewCallerID event before the NewChannel event */
	tmp->cid.cid_num = ast_strdup(dialog->cid_num);
	tmp->cid.cid_ani = ast_strdup(dialog->cid_num);
	tmp->cid.cid_name = ast_strdup(dialog->cid_name);
	if (!ast_strlen_zero(dialog->rdnis))
		tmp->cid.cid_rdnis = ast_strdup(dialog->rdnis);
	
	if (!ast_strlen_zero(dialog->exten) && strcmp(dialog->exten, "s"))
		tmp->cid.cid_dnid = ast_strdup(dialog->exten);

	tmp->priority = 1;
	if (!ast_strlen_zero(dialog->uri))
		pbx_builtin_setvar_helper(tmp, "SIPURI", dialog->uri);
	if (!ast_strlen_zero(dialog->domain))
		pbx_builtin_setvar_helper(tmp, "SIPDOMAIN", dialog->domain);
	if (!ast_strlen_zero(dialog->callid))
		pbx_builtin_setvar_helper(tmp, "SIPCALLID", dialog->callid);
	if (dialog->rtp)
		ast_jb_configure(tmp, &global.jbconf);
	if (state != AST_STATE_DOWN && ast_pbx_start(tmp)) {
		ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
		tmp->hangupcause = AST_CAUSE_SWITCH_CONGESTION;
		ast_hangup(tmp);
		tmp = NULL;
	}
	/* Set channel variables for this call from configuration */
	for (v = dialog->chanvars ; v ; v = v->next)
		pbx_builtin_setvar_helper(tmp,v->name,v->value);

	if (!ast_test_flag(&dialog->flags[0], SIP_NO_HISTORY))
		append_history(dialog, "NewChan", "Channel %s - from %s", tmp->name, dialog->callid);

	return tmp;
}

/*! \brief Get Max T.38 Transmission rate from T38 capabilities */
static int t38_get_rate(int t38cap)
{
	int maxrate = (t38cap & (T38FAX_RATE_14400 | T38FAX_RATE_12000 | T38FAX_RATE_9600 | T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400));
	
	if (maxrate & T38FAX_RATE_14400) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 14400 found\n");
		return 14400;
	} else if (maxrate & T38FAX_RATE_12000) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 12000 found\n");
		return 12000;
	} else if (maxrate & T38FAX_RATE_9600) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 9600 found\n");
		return 9600;
	} else if (maxrate & T38FAX_RATE_7200) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 7200 found\n");
		return 7200;
	} else if (maxrate & T38FAX_RATE_4800) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 4800 found\n");
		return 4800;
	} else if (maxrate & T38FAX_RATE_2400) {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "T38MaxFaxRate 2400 found\n");
		return 2400;
	} else {
		if (option_debug > 1)
			ast_log(LOG_DEBUG, "Strange, T38MaxFaxRate NOT found in peers T38 SDP.\n");
		return 0;
	}
}

/*! \brief Add T.38 Session Description Protocol message */
GNURK int add_t38_sdp(struct sip_request *resp, struct sip_dialog *p)
{
	int len = 0;
	int x = 0;
	struct sockaddr_in udptlsin;
	char v[256] = "";
	char s[256] = "";
	char o[256] = "";
	char c[256] = "";
	char t[256] = "";
	char m_modem[256];
	char a_modem[1024];
	char *m_modem_next = m_modem;
	size_t m_modem_left = sizeof(m_modem);
	char *a_modem_next = a_modem;
	size_t a_modem_left = sizeof(a_modem);
	struct sockaddr_in udptldest = { 0, };
	int debug;
	
	debug = sip_debug_test_pvt(p);
	len = 0;
	if (!p->udptl) {
		ast_log(LOG_WARNING, "No way to add SDP without an UDPTL structure\n");
		return -1;
	}
	
	if (!p->sessionid) {
		p->sessionid = getpid();
		p->sessionversion = p->sessionid;
	} else
		p->sessionversion++;
	
	/* Our T.38 end is */
	ast_udptl_get_us(p->udptl, &udptlsin);
	
	/* Determine T.38 UDPTL destination */
	if (p->udptlredirip.sin_addr.s_addr) {
		udptldest.sin_port = p->udptlredirip.sin_port;
		udptldest.sin_addr = p->udptlredirip.sin_addr;
	} else {
		udptldest.sin_addr = p->ourip;
		udptldest.sin_port = udptlsin.sin_port;
	}
	
	if (debug) 
		ast_log(LOG_DEBUG, "T.38 UDPTL is at %s port %d\n", ast_inet_ntoa(p->ourip), ntohs(udptlsin.sin_port));
	
	/* We break with the "recommendation" and send our IP, in order that our
	   peer doesn't have to ast_gethostbyname() us */
	
	if (debug) {
		ast_log(LOG_DEBUG, "Our T38 capability (%d), peer T38 capability (%d), joint capability (%d)\n",
			p->t38.capability,
			p->t38.peercapability,
			p->t38.jointcapability);
	}
	snprintf(v, sizeof(v), "v=0\r\n");
	snprintf(o, sizeof(o), "o=root %d %d IN IP4 %s\r\n", p->sessionid, p->sessionversion, ast_inet_ntoa(udptldest.sin_addr));
	snprintf(s, sizeof(s), "s=session\r\n");
	snprintf(c, sizeof(c), "c=IN IP4 %s\r\n", ast_inet_ntoa(udptldest.sin_addr));
	snprintf(t, sizeof(t), "t=0 0\r\n");
	ast_build_string(&m_modem_next, &m_modem_left, "m=image %d udptl t38\r\n", ntohs(udptldest.sin_port));
	
	if ((p->t38.jointcapability & T38FAX_VERSION) == T38FAX_VERSION_0)
		ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxVersion:0\r\n");
	if ((p->t38.jointcapability & T38FAX_VERSION) == T38FAX_VERSION_1)
		ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxVersion:1\r\n");
	if ((x = t38_get_rate(p->t38.jointcapability)))
		ast_build_string(&a_modem_next, &a_modem_left, "a=T38MaxBitRate:%d\r\n",x);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxFillBitRemoval:%d\r\n", (p->t38.jointcapability & T38FAX_FILL_BIT_REMOVAL) ? 1 : 0);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxTranscodingMMR:%d\r\n", (p->t38.jointcapability & T38FAX_TRANSCODING_MMR) ? 1 : 0);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxTranscodingJBIG:%d\r\n", (p->t38.jointcapability & T38FAX_TRANSCODING_JBIG) ? 1 : 0);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxRateManagement:%s\r\n", (p->t38.jointcapability & T38FAX_RATE_MANAGEMENT_LOCAL_TCF) ? "localTCF" : "transferredTCF");
	x = ast_udptl_get_local_max_datagram(p->udptl);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxMaxBuffer:%d\r\n",x);
	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxMaxDatagram:%d\r\n",x);
	if (p->t38.jointcapability != T38FAX_UDP_EC_NONE)
		ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxUdpEC:%s\r\n", (p->t38.jointcapability & T38FAX_UDP_EC_REDUNDANCY) ? "t38UDPRedundancy" : "t38UDPFEC");
	 len = strlen(v) + strlen(s) + strlen(o) + strlen(c) + strlen(t) + strlen(m_modem) + strlen(a_modem);
	add_header(resp, "Content-Type", "application/sdp");
	add_header_contentLength(resp, len);
	add_line(resp, v);
	add_line(resp, o);
	add_line(resp, s);
	add_line(resp, c);
	add_line(resp, t);
	add_line(resp, m_modem);
	add_line(resp, a_modem);
	
	/* Update lastrtprx when we send our SDP */
	p->lastrtprx = p->lastrtptx = time(NULL);
	
	return 0;
}

/*! \brief Save contact header for 200 OK on INVITE */
static int parse_ok_contact(struct sip_dialog *pvt, struct sip_request *req)
{
	char contact[250]; 
	char *c;

	/* Look for brackets */
	ast_copy_string(contact, get_header(req, "Contact"), sizeof(contact));
	c = get_in_brackets(contact);

	/* Save full contact to call pvt for later bye or re-invite */
	ast_string_field_set(pvt, fullcontact, c);

	/* Save URI for later ACKs, BYE or RE-invites */
	ast_string_field_set(pvt, okcontacturi, c);

	/*! \todo We should return false for URI:s we can't handle,
		like sips:, tel:, mailto:,ldap: etc */
	return TRUE;		
}

/*! \brief Change the other partys IP address based on given contact */
static int set_address_from_contact(struct sip_dialog *pvt)
{
	struct hostent *hp;
	struct ast_hostent ahp;
	int port;
	char *c, *host, *pt;
	char *contact;


	if (ast_test_flag(&pvt->flags[0], SIP_NAT_ROUTE)) {
		/* NAT: Don't trust the contact field.  Just use what they came to us
		   with. */
		pvt->sa = pvt->recv;
		return 0;
	}


	/* Work on a copy */
	contact = ast_strdupa(pvt->fullcontact);

	/* XXX this code is repeated all over */
	/* Make sure it's a SIP URL */
	if (strncasecmp(contact, "sip:", 4)) {
		ast_log(LOG_NOTICE, "'%s' is not a valid SIP contact (missing sip:) trying to use anyway\n", contact);
	} else
		contact += 4;

	/* Ditch arguments */
	/* XXX this code is replicated also shortly below */
	contact = strsep(&contact, ";");	/* trim ; and beyond */

	/* Grab host */
	host = strchr(contact, '@');
	if (!host) {	/* No username part */
		host = contact;
		c = NULL;
	} else {
		*host++ = '\0';
	}
	pt = strchr(host, ':');
	if (pt) {
		*pt++ = '\0';
		port = atoi(pt);
	} else
		port = STANDARD_SIP_PORT;

	/* XXX This could block for a long time XXX */
	/* We should only do this if it's a name, not an IP */
	hp = ast_gethostbyname(host, &ahp);
	if (!hp)  {
		ast_log(LOG_WARNING, "Invalid host name in Contact: (can't resolve in DNS) : '%s'\n", host);
		return -1;
	}
	pvt->sa.sin_family = AF_INET;
	memcpy(&pvt->sa.sin_addr, hp->h_addr, sizeof(pvt->sa.sin_addr));
	pvt->sa.sin_port = htons(port);

	return 0;
}


/*! \brief Parse contact header and save registration (peer registration) */
static enum parse_register_result parse_register_contact(struct sip_dialog *pvt, struct sip_device *peer, struct sip_request *req)
{
	char contact[BUFSIZ]; 
	char data[BUFSIZ];
	const char *expires = get_header(req, "Expires");
	int localexpiry = atoi(expires);
	char *curi, *n, *pt;
	int port;
	const char *useragent;
	struct hostent *hp;
	struct ast_hostent ahp;
	struct sockaddr_in oldsin;
	time_t expirytime;

	ast_copy_string(contact, get_header(req, "Contact"), sizeof(contact));

	if (ast_strlen_zero(expires)) {	/* No expires header */
		expires = strcasestr(contact, ";expires=");
		if (expires) {
			/* XXX bug here, we overwrite the string */
			expires = strsep((char **) &expires, ";"); /* trim ; and beyond */
			if (sscanf(expires + 9, "%d", &localexpiry) != 1)
				localexpiry = expiry.default_expiry;
		} else {
			/* Nothing has been specified */
			localexpiry = expiry.default_expiry;
		}
	}
	if (localexpiry < expiry.min_expiry && localexpiry > 0)
		return PARSE_REGISTER_FAILED_MINEXPIRY;

	/* Look for brackets */
	curi = contact;
	if (strchr(contact, '<') == NULL)	/* No <, check for ; and strip it */
		strsep(&curi, ";");	/* This is Header options, not URI options */
	curi = get_in_brackets(contact);

	/* if they did not specify Contact: or Expires:, they are querying
	   what we currently have stored as their contact address, so return
	   it
	*/
	if (ast_strlen_zero(curi) && ast_strlen_zero(expires)) {
		/* If we have an active registration, tell them when the registration is going to expire */
		if (peer->expire > -1 && !ast_strlen_zero(peer->fullcontact))
			pvt->expiry = ast_sched_when(sched, peer->expire);
		return PARSE_REGISTER_QUERY;
	} else if (!strcasecmp(curi, "*") || !localexpiry) {	/* Unregister this peer */
		/* This means remove all registrations and return OK */
		memset(&peer->addr, 0, sizeof(peer->addr));
		if (peer->expire > -1)
			ast_sched_del(sched, peer->expire);
		peer->expire = -1;

		destroy_association(peer);
		
		register_peer_exten(peer, 0);	/* Add extension from regexten= setting in sip.conf */
		ast_string_field_free(peer, fullcontact);
		ast_string_field_free(peer, useragent);
		peer->sipoptions = 0;
		peer->lastms = 0;

		if (option_verbose > 2)
			ast_verbose(VERBOSE_PREFIX_3 "Unregistered SIP '%s'\n", peer->name);
			manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Unregistered\r\n", peer->name);
		return PARSE_REGISTER_UPDATE;
	}

	/* Store whatever we got as a contact from the client */
	ast_string_field_set(peer, fullcontact, curi);

	/* For the 200 OK, we should use the received contact */
	ast_string_field_build(pvt, our_contact, "<%s>", curi);

	/* Make sure it's a SIP URL */
	if (strncasecmp(curi, "sip:", 4)) {
		ast_log(LOG_NOTICE, "'%s' is not a valid SIP contact (missing sip:) trying to use anyway\n", curi);
	} else
		curi += 4;
	/* Ditch q */
	curi = strsep(&curi, ";");
	/* Grab host */
	n = strchr(curi, '@');
	if (!n) {
		n = curi;
		curi = NULL;
	} else
		*n++ = '\0';
	pt = strchr(n, ':');
	if (pt) {
		*pt++ = '\0';
		port = atoi(pt);
	} else
		port = STANDARD_SIP_PORT;
	oldsin = peer->addr;
	if (!ast_test_flag(&peer->flags[0], SIP_NAT_ROUTE)) {
		/* XXX This could block for a long time XXX */
		hp = ast_gethostbyname(n, &ahp);
		if (!hp)  {
			ast_log(LOG_WARNING, "Invalid host '%s'\n", n);
			return PARSE_REGISTER_FAILED;
		}
		peer->addr.sin_family = AF_INET;
		memcpy(&peer->addr.sin_addr, hp->h_addr, sizeof(peer->addr.sin_addr));
		peer->addr.sin_port = htons(port);
	} else {
		/* Don't trust the contact field.  Just use what they came to us
		   with */
		peer->addr = pvt->recv;
	}

	/* Save SIP options profile */
	peer->sipoptions = pvt->sipoptions;

	if (curi) {	/* Overwrite the default username from config at registration */
		ast_string_field_set(peer, defaultuser, curi);
		//ast_copy_string(peer->defaultuser, curi, sizeof(peer->defaultuser));
	} else
		ast_string_field_set(peer, defaultuser, "");
		//peer->defaultuser[0] = '\0';

	if (peer->expire > -1)
		ast_sched_del(sched, peer->expire);
	if (localexpiry > expiry.max_expiry)
		localexpiry = expiry.max_expiry;
	//if (localexpiry < expiry.min_expiry)
		//localexpiry = expiry.min_expiry;
	peer->expire = ast_test_flag(&peer->flags[0], SIP_REALTIME) ? -1 :
		ast_sched_add(sched, (localexpiry + 10) * 1000, expire_register, peer);
	pvt->expiry = localexpiry;

	/* Store registration data in the registry */
	expirytime = time(NULL) + localexpiry + 10;
	snprintf(data, sizeof(data), "%d|%s|%d|%d|%s", (int) expirytime, ast_inet_ntoa(peer->addr.sin_addr), ntohs(peer->addr.sin_port), localexpiry, peer->fullcontact);
	if (!ast_test_flag(&peer->flags[1], SIP_PAGE2_RT_FROMCONTACT)) 
		ast_db_put("SIP3-Registry", peer->name, data);
	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Registered\r\n", peer->name);

	/* Is this a new IP address for us? */
	if (inaddrcmp(&peer->addr, &oldsin)) {
		sip_poke_peer(peer);
		if (option_verbose > 2)
			ast_verbose(VERBOSE_PREFIX_3 "Registered SIP '%s' at %s port %d expires %d\n", peer->name, ast_inet_ntoa(peer->addr.sin_addr), ntohs(peer->addr.sin_port), localexpiry);
		register_peer_exten(peer, 1);
	}
	
	/* Save User agent */
	useragent = get_header(req, "User-Agent");
	if (strcasecmp(useragent, peer->useragent)) {	/* XXX copy if they are different ? */
		ast_string_field_set(peer, useragent, useragent);
		if (option_verbose > 3)
			ast_verbose(VERBOSE_PREFIX_3 "Saved useragent \"%s\" for peer %s\n", peer->useragent, peer->name);  
	}
	return PARSE_REGISTER_UPDATE;
}

/*! \brief Remove route from route list */
void free_old_route(struct sip_route *route)
{
	struct sip_route *next;

	while (route) {
		next = route->next;
		free(route);
		route = next;
	}
}

/*! \brief List all routes - mostly for debugging */
static void list_route(struct sip_route *route)
{
	if (!route)
		ast_verbose("list_route: no route\n");
	else {
		for (;route; route = route->next)
			ast_verbose("list_route: hop: <%s>\n", route->hop);
	}
}

/*! \brief Build route list from Record-Route header */
static void build_route(struct sip_dialog *p, struct sip_request *req, int backwards)
{
	struct sip_route *thishop, *head, *tail;
	int start = 0;
	int len;
	const char *rr, *contact, *c;

	/* Once a persistant route is set, don't fool with it */
	if (p->route && p->route_persistant) {
		if (option_debug)
			ast_log(LOG_DEBUG, "build_route: Retaining previous route: <%s>\n", p->route->hop);
		return;
	}

	if (p->route) {
		free_old_route(p->route);
		p->route = NULL;
	}
	
	p->route_persistant = backwards;
	
	/* Build a tailq, then assign it to p->route when done.
	 * If backwards, we add entries from the head so they end up
	 * in reverse order. However, we do need to maintain a correct
	 * tail pointer because the contact is always at the end.
	 */
	head = NULL;
	tail = head;
	/* 1st we pass through all the hops in any Record-Route headers */
	for (;;) {
		/* Each Record-Route header */
		rr = __get_header(req, "Record-Route", &start);
		if (*rr == '\0')
			break;
		for (; (rr = strchr(rr, '<')) ; rr += len) { /* Each route entry */
			++rr;
			len = strcspn(rr, ">") + 1;
			/* Make a struct route */
			if ((thishop = ast_malloc(sizeof(*thishop) + len))) {
				/* ast_calloc is not needed because all fields are initialized in this block */
				ast_copy_string(thishop->hop, rr, len);
				if (option_debug > 1)
					ast_log(LOG_DEBUG, "build_route: Record-Route hop: <%s>\n", thishop->hop);
				/* Link in */
				if (backwards) {
					/* Link in at head so they end up in reverse order */
					thishop->next = head;
					head = thishop;
					/* If this was the first then it'll be the tail */
					if (!tail)
						tail = thishop;
				} else {
					thishop->next = NULL;
					/* Link in at the end */
					if (tail)
						tail->next = thishop;
					else
						head = thishop;
					tail = thishop;
				}
			}
		}
	}

	/* Only append the contact if we are dealing with a strict router */
	if (!head || (!ast_strlen_zero(head->hop) && strstr(head->hop,";lr") == NULL) ) {
		/* 2nd append the Contact: if there is one */
		/* Can be multiple Contact headers, comma separated values - we just take the first */
		contact = get_header(req, "Contact");
		if (!ast_strlen_zero(contact)) {
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "build_route: Contact hop: %s\n", contact);
			/* Look for <: delimited address */
			c = strchr(contact, '<');
			if (c) {
				/* Take to > */
				++c;
				len = strcspn(c, ">") + 1;
			} else {
				/* No <> - just take the lot */
				c = contact;
				len = strlen(contact) + 1;
			}
			if ((thishop = ast_malloc(sizeof(*thishop) + len))) {
				/* ast_calloc is not needed because all fields are initialized in this block */
				ast_copy_string(thishop->hop, c, len);
				thishop->next = NULL;
				/* Goes at the end */
				if (tail)
					tail->next = thishop;
				else
					head = thishop;
			}
		}
	}

	/* Store as new route */
	p->route = head;

	/* For debugging dump what we ended up with */
	if (sip_debug_test_pvt(p))
		list_route(p->route);
}

/*! \brief Change onhold state of a peer using a pvt structure */
GNURK void sip_peer_hold(struct sip_dialog *p, int hold)
{
	struct sip_device *peer = find_device(p->peername, NULL, 1);

	if (!peer)
		return;

	/* If they put someone on hold, increment the value... otherwise decrement it */
	if (hold)
		peer->onHold++;
	else if (hold > 0)
		peer->onHold--;

	/* Request device state update */
	ast_device_state_changed("SIP/%s", peer->name);

	return;
}

/*! \brief Callback for the devicestate notification (SUBSCRIBE) support subsystem
\note	If you add an "hint" priority to the extension in the dial plan,
	you will get notifications on device state changes */
static int cb_extensionstate(char *context, char* exten, int state, void *data)
{
	struct sip_dialog *p = data;

	switch(state) {
	case AST_EXTENSION_DEACTIVATED:	/* Retry after a while */
	case AST_EXTENSION_REMOVED:	/* Extension is gone */
		if (p->autokillid > -1)
			sip_cancel_destroy(p);	/* Remove subscription expiry for renewals */
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);	/* Delete subscription in 32 secs */
		ast_verbose(VERBOSE_PREFIX_2 "Extension state: Watcher for hint %s %s. Notify User %s\n", exten, state == AST_EXTENSION_DEACTIVATED ? "deactivated" : "removed", p->peername);
		p->stateid = -1;
		p->subscribed = NONE;
		append_history(p, "Subscribestatus", "%s", state == AST_EXTENSION_REMOVED ? "HintRemoved" : "Deactivated");
		break;
	default:	/* Tell user */
		p->laststate = state;
		break;
	}
	transmit_state_notify(p, state, 1, FALSE);

	if (option_verbose > 1)
		ast_verbose(VERBOSE_PREFIX_1 "Extension Changed %s new state %s for Notify User %s\n", exten, ast_extension_state2str(state), p->peername);
	return 0;
}

/*!
 * Terminate the uri at the first ';' or space.
 * Technically we should ignore escaped space per RFC3261 (19.1.1 etc)
 * but don't do it for the time being. Remember the uri format is:
 *
 *	sip:user:password@host:port;uri-parameters?headers
 *	sips:user:password@host:port;uri-parameters?headers
 *
 */
static char *terminate_uri(char *uri)
{
	char *t = uri;
	while (*t && *t > ' ' && *t != ';')
		t++;
	*t = '\0';
	return uri;
}

/*! \brief Verify registration of user 
	- Registration is done in several steps, first a REGISTER without auth
	  to get a challenge (nonce) then a second one with auth
	- Registration requests are only matched with peers that are marked as "dynamic"
 */
static enum check_auth_result register_verify(struct sip_dialog *p, struct sockaddr_in *sin,
					      struct sip_request *req, char *uri)
{
	enum check_auth_result res = AUTH_NOT_FOUND;
	struct sip_device *peer;
	char tmp[256];
	char *name, *c;
	char *domain;

	terminate_uri(uri);	/*! \bug XXX warning, overwrite the string */

	ast_copy_string(tmp, get_header(req, "To"), sizeof(tmp));
	ast_uri_decode(tmp);

	c = get_in_brackets(tmp);
	c = strsep(&c, ";");	/* Ditch ;user=phone */

	if (!strncmp(c, "sip:", 4)) {
		name = c + 4;
	} else {
		name = c;
		ast_log(LOG_NOTICE, "Invalid to address: '%s' from %s (missing sip:) trying to use anyway...\n", c, ast_inet_ntoa(sin->sin_addr));
	}

	/* Strip off the domain name */
	if ((c = strchr(name, '@'))) {
		*c++ = '\0';
		domain = c;
		if ((c = strchr(domain, ':')))	/* Remove :port */
			*c = '\0';
		if (domains_configured()) {
			if (!check_sip_domain(domain, NULL, 0)) {
				transmit_response(p, "404 Not found (unknown domain)", p->initreq);
				return AUTH_UNKNOWN_DOMAIN;
			}
		}
	}

	ast_string_field_set(p, exten, name);
	build_contact(p);
	peer = find_device(name, NULL, 1);
	if (!(peer && ast_apply_ha(peer->ha, sin))) {
		/* Peer fails ACL check */
		if (peer)
			device_unref(peer);
		peer = NULL;
	}
	if (peer) {
		/* Set Frame packetization */
		if (p->rtp) {
			ast_rtp_codec_setpref(p->rtp, &peer->prefs);
			p->autoframing = peer->autoframing;
		}
		if (!ast_test_flag(&peer->flags[1], SIP_PAGE2_DYNAMIC)) {
			ast_log(LOG_ERROR, "Peer '%s' is trying to register, but not configured as host=dynamic\n", peer->name);
		} else {
			ast_copy_flags(&p->flags[0], &peer->flags[0], SIP_NAT);
			transmit_response(p, "100 Trying", req);
			if (!(res = check_auth(p, req, peer->name, peer->secret, peer->md5secret, SIP_REGISTER, uri, XMIT_UNRELIABLE, ast_test_flag(req, SIP_PKT_IGNORE)))) {
				sip_cancel_destroy(p);

				/* We have a succesful registration attemp with proper authentication,
				   now, update the peer */
				switch (parse_register_contact(p, peer, req)) {
				case PARSE_REGISTER_FAILED_MINEXPIRY:
					transmit_response_with_attachment(WITH_MINEXPIRY, p, "423 Interval too small", req, XMIT_UNRELIABLE);
					peer->mailbox.lastmsgssent = -1;
					res = 0;
					break;
				case PARSE_REGISTER_FAILED:
					ast_log(LOG_WARNING, "Failed to parse contact info\n");
					transmit_response_with_attachment(WITH_DATE, p, "400 Bad Request", req, XMIT_UNRELIABLE);
					peer->mailbox.lastmsgssent = -1;
					res = 0;
					break;
				case PARSE_REGISTER_QUERY:
					transmit_response_with_attachment(WITH_DATE, p, "200 OK", req, XMIT_UNRELIABLE);
					peer->mailbox.lastmsgssent = -1;
					res = 0;
					break;
				case PARSE_REGISTER_UPDATE:
					update_peer(peer, p->expiry);
					/* Say OK and ask subsystem to retransmit msg counter */
					transmit_response_with_attachment(WITH_DATE, p, "200 OK", req, XMIT_UNRELIABLE);
					if (!ast_test_flag((&peer->flags[1]), SIP_PAGE2_SUBSCRIBEMWIONLY))
						peer->mailbox.lastmsgssent = -1;
					res = 0;
					break;
				}
			} 
		}
	}
	if (!peer && global.autocreatepeer) {
		/* Create peer if we have autocreate mode enabled */
		peer = temp_device(name);
		if (peer) {
			ASTOBJ_CONTAINER_LINK(&devicelist, peer);
			sip_cancel_destroy(p);
			switch (parse_register_contact(p, peer, req)) {
			case PARSE_REGISTER_FAILED_MINEXPIRY:
				transmit_response_with_attachment(WITH_MINEXPIRY, p, "423 Interval too small", req, XMIT_UNRELIABLE);
				peer->mailbox.lastmsgssent = -1;
				res = 0;
			case PARSE_REGISTER_FAILED:
				ast_log(LOG_WARNING, "Failed to parse contact info\n");
				transmit_response_with_attachment(WITH_DATE, p, "400 Bad Request", req, XMIT_UNRELIABLE);
				peer->mailbox.lastmsgssent = -1;
				res = 0;
				break;
			case PARSE_REGISTER_QUERY:
				transmit_response_with_attachment(WITH_DATE, p, "200 OK", req, XMIT_UNRELIABLE);
				peer->mailbox.lastmsgssent = -1;
				res = 0;
				break;
			case PARSE_REGISTER_UPDATE:
				/* Say OK and ask subsystem to retransmit msg counter */
				transmit_response_with_attachment(WITH_DATE, p, "200 OK", req, XMIT_UNRELIABLE);
				manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Registered\r\n", peer->name);
				peer->mailbox.lastmsgssent = -1;
				res = 0;
				break;
			}
		}
	}
	if (!res) {
		ast_device_state_changed("SIP/%s", peer->name);
	}
	if (res < 0) {
		switch (res) {
		case AUTH_SECRET_FAILED:
			/* Wrong password in authentication. Go away, don't try again until you fixed it */
			transmit_response(p, "403 Forbidden (Bad auth)", p->initreq);
			break;
		case AUTH_USERNAME_MISMATCH:
			/* Username and digest username does not match. 
			   Asterisk uses the From: username for authentication. We need the
			   users to use the same authentication user name until we support
			   proper authentication by digest auth name */
			transmit_response(p, "403 Authentication user name does not match account name", p->initreq);
			break;
		case AUTH_NOT_FOUND:
			if (global.alwaysauthreject) {
				transmit_fake_auth_response(p, p->initreq, 1);
			} else {
				/* URI not found */
				transmit_response(p, "404 Not found", p->initreq);
			}
			break;
		default:
			break;
		}
		if (option_debug > 1) {
			const char *reason = "";

			switch (res) {
			case AUTH_SECRET_FAILED:
				reason = "Bad password";
				break;
			case AUTH_USERNAME_MISMATCH:
				reason = "Bad digest user";
				break;
			case AUTH_NOT_FOUND:
				reason = "Peer not found";
				break;
			default:
				break;
			}
			ast_log(LOG_DEBUG, "SIP REGISTER attempt failed for %s : %s\n",
				peer->name, reason);
		}
	}
	device_unref(peer);

	return res;
}

/*! \brief Lock dialog list lock and find matching pvt lock  
	- Their tag is fromtag, our tag is to-tag
	- This means that in some transactions, totag needs to be their tag :-)
	  depending upon the direction
*/
GNURK struct sip_dialog *get_sip_dialog_byid_locked(const char *callid, const char *totag, const char *fromtag) 
{
	struct sip_dialog *sip_dialog_ptr;

	dialoglist_lock();

	if (option_debug > 3 && totag)
		ast_log(LOG_DEBUG, "Looking for callid %s (fromtag %s totag %s)\n", callid, fromtag ? fromtag : "<no fromtag>", totag ? totag : "<no totag>");

	/* Search interfaces and find the match */
	for (sip_dialog_ptr = dialoglist; sip_dialog_ptr; sip_dialog_ptr = sip_dialog_ptr->next) {
		if (!strcmp(sip_dialog_ptr->callid, callid)) {
			int match = 1;
			char *ourtag = sip_dialog_ptr->tag;

			/* Go ahead and lock it (and its owner) before returning */
			dialog_lock(sip_dialog_ptr, TRUE);

			/* Check if tags match. If not, this is not the call we want
			   (With a forking SIP proxy, several call legs share the
			   call id, but have different tags)
			*/
			if (strcmp(fromtag, sip_dialog_ptr->theirtag) || strcmp(totag, ourtag))
				match = 0;

			if (!match) {
				dialog_lock(sip_dialog_ptr, FALSE);
				continue;
			}

			if (option_debug > 3 && totag)				 
				ast_log(LOG_DEBUG, "Matched %s call - their tag is %s Our tag is %s\n",
					ast_test_flag(&sip_dialog_ptr->flags[0], SIP_OUTGOING) ? "OUTGOING": "INCOMING",
					sip_dialog_ptr->theirtag, sip_dialog_ptr->tag);

			/* deadlock avoidance... */
			while (sip_dialog_ptr->owner && ast_channel_trylock(sip_dialog_ptr->owner)) {
				dialog_lock(sip_dialog_ptr, FALSE);
				usleep(1);
				dialog_lock(sip_dialog_ptr, TRUE);
			}
			break;
		}
	}
	dialoglist_unlock();
	if (option_debug > 3 && !sip_dialog_ptr)
		ast_log(LOG_DEBUG, "Found no match for callid %s to-tag %s from-tag %s\n", callid, totag, fromtag);
	return sip_dialog_ptr;
}

/*! \brief Call transfer support (old way, deprecated by the IETF)--*/
static int get_also_info(struct sip_dialog *p, struct sip_request *oreq)
{
	char tmp[256] = "", *c, *a;
	struct sip_request *req = oreq ? oreq : p->initreq;
	struct sip_refer *referdata = p->refer;
	const char *transfer_context = NULL;
	
	ast_copy_string(tmp, get_header(req, "Also"), sizeof(tmp));
	c = get_in_brackets(tmp);

	ast_uri_decode(c);
	
	if (strncmp(c, "sip:", 4)) {
		ast_log(LOG_WARNING, "Huh?  Not a SIP header in Also: transfer (%s)?\n", c);
		return -1;
	}
	c += 4;

	if ((a = strchr(c, ';'))) 	/* Remove arguments */
		*a = '\0';

	if ((a = strchr(c, '@'))) {	/* Separate Domain */
		*a++ = '\0';
		ast_copy_string(referdata->refer_to_domain, a, sizeof(referdata->refer_to_domain));
	}
	
	
	if (sip_debug_test_pvt(p))
		ast_verbose("Looking for %s in %s\n", c, p->context);

	if (p->owner)	/* Mimic behaviour in res_features.c */
		transfer_context = pbx_builtin_getvar_helper(p->owner, "TRANSFER_CONTEXT");

	/* By default, use the context in the channel sending the REFER */
	if (ast_strlen_zero(transfer_context)) {
		transfer_context = S_OR(p->owner->macrocontext,
					S_OR(p->context, global.default_context));
	}
	if (ast_exists_extension(NULL, transfer_context, c, 1, NULL)) {
		/* This is a blind transfer */
		if (option_debug)
			ast_log(LOG_DEBUG,"SIP Bye-also transfer to Extension %s@%s \n", c, transfer_context);
		ast_copy_string(referdata->refer_to, c, sizeof(referdata->refer_to));
		ast_copy_string(referdata->referred_by, "", sizeof(referdata->referred_by));
		ast_copy_string(referdata->refer_contact, "", sizeof(referdata->refer_contact));
		referdata->refer_call = NULL;
		/* Set new context */
		ast_string_field_set(p, context, transfer_context);
		return 0;
	} else if (ast_canmatch_extension(NULL, p->context, c, 1, NULL)) {
		return 1;
	}

	return -1;
}
/*! \brief check Via: header for hostname, port and rport request/answer */
static void check_via(struct sip_dialog *p, struct sip_request *req)
{
	char via[256];
	char *c, *pt;
	struct hostent *hp;
	struct ast_hostent ahp;

	ast_copy_string(via, get_header(req, "Via"), sizeof(via));
	if (strlen(via) == 0)
		ast_log(LOG_DEBUG, "Empty VIA string found \n");

	/* Work on the leftmost value of the topmost Via header */
	c = strchr(via, ',');
	if (c)
		*c = '\0';

	/* Check for rport */
	c = strstr(via, ";rport");
	if (c && (c[6] != '='))	/* rport query, not answer */
		ast_set_flag(&p->flags[0], SIP_NAT_ROUTE);

	c = strchr(via, ';');
	if (c) 
		*c = '\0';

	c = strchr(via, ' ');
	if (c) {
		*c = '\0';
		c = ast_skip_blanks(c+1);
		if (strcasecmp(via, "SIP/2.0/UDP")) {
			ast_log(LOG_WARNING, "Don't know how to respond via '%s'\n", via);
			return;
		}
		pt = strchr(c, ':');
		if (pt)
			*pt++ = '\0';	/* remember port pointer */

		/* Set sender's address to the IP address in via for replies */
		memset(&p->sa, 0, sizeof(p->sa));
		p->sa.sin_family = AF_INET;

		if (!inet_aton(c, &p->sa.sin_addr)) {	/* Check if this is an IP address, not a host name */
			/* resolve host name */
			hp = ast_gethostbyname(c, &ahp);
			if (!hp) {
				ast_log(LOG_WARNING, "'%s' is not a valid DNS host name\n", c);
				return;
			}
			memcpy(&p->sa.sin_addr, hp->h_addr, sizeof(p->sa.sin_addr));
		}
		p->sa.sin_port = htons(pt ? atoi(pt) : STANDARD_SIP_PORT);

		if (sip_debug_test_pvt(p)) {
			const struct sockaddr_in *dst = sip_real_dst(p);
			
			ast_verbose("Sending to %s : %d (%s)\n", ast_inet_ntoa(dst->sin_addr), ntohs(dst->sin_port), sip_nat_mode(p));
			ast_verbose("Sender's address %s : %d (%s)\n", ast_inet_ntoa(p->sa.sin_addr), ntohs(p->sa.sin_port), sip_nat_mode(p));
		}
	}
}

/*! \brief  Check if matching user or peer is defined 
 	Match user on From: user name and peer on IP/port
	This is used on first invite (not re-invites) and subscribe requests 
    \return 0 on success, non-zero on failure
*/
static enum check_auth_result check_user_full(struct sip_dialog *p, struct sip_request *req,
					      int sipmethod, char *uri, enum xmittype reliable,
					      struct sockaddr_in *sin, struct sip_device **authpeer)
{
	struct sip_device *device = NULL;
	char from[256], *c;
	char *of;
	char rpid_num[50];
	const char *rpid;
	enum check_auth_result res = AUTH_SUCCESSFUL;
	char *t;
	char calleridname[50];
	int debug = sip_debug_test_addr(sin);
	struct ast_variable *tmpvar = NULL, *v = NULL;
	enum objecttype devicematch = SIP_UNKNOWN;
	char *uri2 = ast_strdupa(uri);

	/* Terminate URI */
	t = uri2;
	while (*t && *t > 32 && *t != ';')
		t++;
	*t = '\0';
	ast_copy_string(from, get_header(req, "From"), sizeof(from));	/* XXX bug in original code, overwrote string */
	ast_uri_decode(from);
	/* XXX here tries to map the username for invite things */
	memset(calleridname, 0, sizeof(calleridname));
	get_calleridname(from, calleridname, sizeof(calleridname));
	if (calleridname[0])
		ast_string_field_set(p, cid_name, calleridname);

	rpid = get_header(req, "Remote-Party-ID");
	memset(rpid_num, 0, sizeof(rpid_num));
	if (!ast_strlen_zero(rpid)) 
		p->callingpres = get_rpid_num(rpid, rpid_num, sizeof(rpid_num));

	of = get_in_brackets(from);
	if (ast_strlen_zero(p->exten)) {
		char *t = uri2;
		if (!strncmp(t, "sip:", 4))
			t+= 4;
		ast_string_field_set(p, exten, t);
		t = strchr(p->exten, '@');
		if (t)
			*t = '\0';
		if (ast_strlen_zero(p->our_contact))
			build_contact(p);
	}
	/* save the URI part of the From header */
	ast_string_field_set(p, from, of);
	if (strncmp(of, "sip:", 4))
		ast_log(LOG_NOTICE, "From address missing 'sip:', using it anyway\n");
	else
		of += 4;
	/* Get just the username part */
	if ((c = strchr(of, '@'))) {
		char *tmp;
		*c = '\0';
		if ((c = strchr(of, ':')))
			*c = '\0';
		tmp = ast_strdupa(of);
		if (ast_is_shrinkable_phonenumber(tmp))
			ast_shrink_phone_number(tmp);
		ast_string_field_set(p, cid_num, tmp);
	}
	if (ast_strlen_zero(of))
		return AUTH_SUCCESSFUL;

	if (p->registry && p->registry->peer)	/* We already know this device from registry */
		device = p->registry->peer;
	else
		/* Find device in device list */
		device = find_device(of, NULL, 1);
	if (device && !ast_apply_ha(device->ha, sin)) {
		device_unref(device);
		device = NULL;
	}
	/* Secondly match on IP/port (will in the future only be applied to trunks, not devices */
	if (!device) {
		/* Look for peer based on the IP address we received data from */
		/* If peer is registered from this IP address or have this as a default
		   IP address, this call is from the peer 
		*/
		device = find_device(NULL, &p->recv, 1);
	}
	if (device && !ast_apply_ha(device->ha, sin)) {
		device_unref(device);
		device = NULL;
	}
	if (device)
		devicematch = SIP_PEER;		/* We matched on a peer */
	/* No device found */
	if (!device) {
		if (debug)
			ast_verbose("Found no matching peer or user for '%s:%d'\n", ast_inet_ntoa(p->recv.sin_addr), ntohs(p->recv.sin_port));

		/* do we allow guests? */
		if (!global.allowguest)
			res = -1;  /* we don't want any guests, authentication will fail */
		return res;
	}

	/* Ok, we have a device, let's check authentication if needed */
	ast_copy_flags(&p->flags[0], &device->flags[0], SIP_FLAGS_TO_COPY);
	ast_copy_flags(&p->flags[1], &device->flags[1], SIP_PAGE2_FLAGS_TO_COPY);

	/* Copy SIP extensions profile to peer */
	if (p->sipoptions)
		device->sipoptions = p->sipoptions;

	/* copy channel vars */
	for (v = device->chanvars ; v ; v = v->next) {
		if ((tmpvar = ast_variable_new(v->name, v->value))) {
			tmpvar->next = p->chanvars; 
			p->chanvars = tmpvar;
		}
	}
	p->prefs = device->prefs;
	/* Set Frame packetization */
	if (p->rtp) {
		ast_rtp_codec_setpref(p->rtp, &p->prefs);
		p->autoframing = device->autoframing;
	}

	replace_cid(p, rpid_num, calleridname);
	
	do_setnat(p, ast_test_flag(&p->flags[0], SIP_NAT_ROUTE));

	if (device->maxms && device->lastms)
		p->timer_t1 = device->lastms;
	if (ast_test_flag(&device->flags[0], SIP_INSECURE_INVITE)) {
		/* Pretend there is no required authentication */
		ast_string_field_free(p, peersecret);
		ast_string_field_free(p, peermd5secret);
	}
	/* Now, check auth */
	if (!(res = check_auth(p, req, device->name, device->secret, device->md5secret, sipmethod, uri, reliable, ast_test_flag(req, SIP_PKT_IGNORE)))) {
		/* We have positive authentication, let's configure this SIP session */
		sip_cancel_destroy(p);
		ast_copy_flags(&p->flags[0], &device->flags[0], SIP_FLAGS_TO_COPY);
		ast_copy_flags(&p->flags[1], &device->flags[1], SIP_PAGE2_FLAGS_TO_COPY);
		/* Copy SIP extensions profile from INVITE */
		if (p->sipoptions)
			device->sipoptions = p->sipoptions;
		/* If we have a call limit, set flag */
		if (device->call_limit)
			ast_set_flag(&p->flags[0], SIP_CALL_LIMIT);
		if (!ast_strlen_zero(device->extra.context))
			ast_string_field_set(p, context, device->extra.context);
		if (!ast_strlen_zero(device->extra.cid_num) && !ast_strlen_zero(p->cid_num)) {
			char *tmp = ast_strdupa(device->extra.cid_num);
			if (tmp) {
				if (ast_is_shrinkable_phonenumber(tmp))
					ast_shrink_phone_number(tmp);
				ast_string_field_set(p, cid_num, tmp);
			} else {
				ast_string_field_set(p, cid_num, device->extra.cid_num);
			}
		}
		if (!ast_strlen_zero(device->extra.cid_name) && !ast_strlen_zero(p->cid_num))
			ast_string_field_set(p, cid_name, device->extra.cid_name);
		ast_string_field_set(p, peersecret, device->secret);
		ast_string_field_set(p, peermd5secret, device->md5secret);
		ast_string_field_set(p, fullcontact, device->fullcontact);
		ast_string_field_set(p, peername, device->name);
		ast_string_field_set(p, authname, device->name);
		if (!ast_strlen_zero(device->defaultuser)) {
			ast_string_field_set(p, peername, device->defaultuser);
			/* Use the default username for authentication on outbound calls */
			if(!ast_strlen_zero(device->authuser))
				ast_string_field_set(p, authname, device->authuser);
		}
		if (p->t38.peercapability)
			p->t38.jointcapability &= p->t38.peercapability;
		p->maxcallbitrate = device->maxcallbitrate;
		/* If we do not support video, remove video from call structure */
		if (!ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT) && p->vrtp) {
			ast_rtp_destroy(p->vrtp);
			p->vrtp = NULL;
		}
		ast_string_field_set(p, subscribecontext, device->extra.subscribecontext);
		ast_string_field_set(p, accountcode, device->extra.accountcode);
		ast_string_field_set(p, language, device->language);
		ast_string_field_set(p, mohsuggest, device->extra.mohsuggest);
		ast_string_field_set(p, mohinterpret, device->extra.mohinterpret);
		p->allowtransfer = device->allowtransfer;
		p->amaflags = device->extra.amaflags;
		p->callgroup = device->callgroup;
		p->pickupgroup = device->pickupgroup;
		p->callingpres = device->callingpres;
		p->capability = device->capability;
		p->jointcapability = device->capability;
		p->prefs = device->prefs;
		if (p->peercapability)
			p->jointcapability &= p->peercapability;
		p->maxcallbitrate = device->maxcallbitrate;
		if (!ast_test_flag((&p->flags[1]), SIP_PAGE2_VIDEOSUPPORT) && p->vrtp) {
			ast_rtp_destroy(p->vrtp);
			p->vrtp = NULL;
		}
		if ((ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_RFC2833) || (ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_AUTO))
			p->noncodeccapability |= AST_RTP_DTMF;
		else
			p->noncodeccapability &= ~AST_RTP_DTMF;

		/* copy channel vars */
		for (v = device->chanvars ; v ; v = v->next) {
			if ((tmpvar = ast_variable_new(v->name, v->value))) {
				tmpvar->next = p->chanvars; 
				p->chanvars = tmpvar;
			}
		}	
		do_setnat(p, ast_test_flag(&p->flags[0], SIP_NAT_ROUTE));
		ast_string_field_set(p, peersecret, device->secret);
		ast_string_field_set(p, peermd5secret, device->md5secret);
		ast_string_field_set(p, subscribecontext, device->extra.subscribecontext);
		ast_string_field_set(p, mohinterpret, device->extra.mohinterpret);
		ast_string_field_set(p, mohsuggest, device->extra.mohsuggest);
		if (device->callingpres)	/* Peer calling pres setting will override RPID */
			p->callingpres = device->callingpres;
	}
	if (device && debug)
		ast_verbose("Found %s '%s'\n", device->type & SIP_USER ? "user" : "peer", device->name);

	device_unref(device);

	return res;
}

/*! \brief  Find user 
	If we get a match, this will add a reference pointer to the user object in ASTOBJ, that needs to be unreferenced
*/
static int check_user(struct sip_dialog *p, struct sip_request *req, int sipmethod, char *uri, enum xmittype reliable, struct sockaddr_in *sin)
{
	return check_user_full(p, req, sipmethod, uri, reliable, sin, NULL);
}

/*! \brief  Get text out of a SIP MESSAGE packet */
static int get_msg_text(char *buf, int len, struct sip_request *req)
{
	int x;
	int y;

	buf[0] = '\0';
	y = len - strlen(buf) - 5;
	if (y < 0)
		y = 0;
	for (x=0;x<req->lines;x++) {
		strncat(buf, req->line[x], y); /* safe */
		y -= strlen(req->line[x]) + 1;
		if (y < 0)
			y = 0;
		if (y != 0)
			strcat(buf, "\n"); /* safe */
	}
	return 0;
}


/*! \brief  Receive SIP MESSAGE method messages
\note	We only handle messages within current calls currently 
	Reference: RFC 3428 */
static void receive_message(struct sip_dialog *p, struct sip_request *req)
{
	char buf[1024];
	struct ast_frame f;
	const char *content_type = get_header(req, "Content-Type");

	if (strcmp(content_type, "text/plain")) { /* No text/plain attachment */
		transmit_response(p, "415 Unsupported Media Type", req); /* Good enough, or? */
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		return;
	}

	if (get_msg_text(buf, sizeof(buf), req)) {
		ast_log(LOG_WARNING, "Unable to retrieve text from %s\n", p->callid);
		transmit_response(p, "202 Accepted", req);
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		return;
	}

	if (p->owner) {
		if (sip_debug_test_pvt(p))
			ast_verbose("Message received: '%s'\n", buf);
		memset(&f, 0, sizeof(f));
		f.frametype = AST_FRAME_TEXT;
		f.subclass = 0;
		f.offset = 0;
		f.data = buf;
		f.datalen = strlen(buf);
		ast_queue_frame(p->owner, &f);
		transmit_response(p, "202 Accepted", req); /* We respond 202 accepted, since we relay the message */
	} else { /* Message outside of a call, we do not support that */
		ast_log(LOG_WARNING,"Received message to %s from %s, dropped it...\n  Content-Type:%s\n  Message: %s\n", get_header(req,"To"), get_header(req,"From"), content_type, buf);
		transmit_response(p, "405 Method Not Allowed", req); /* Good enough, or? */
	}
	sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
	return;
}

/*! \brief Remove temporary realtime objects from memory (CLI) */
GNURK int sip_prune_realtime(int fd, int argc, char *argv[])
{
	struct sip_device *device;
	int prunepeer = FALSE;
	int multi = FALSE;
	char *name = NULL;
	regex_t regexbuf;

	switch (argc) {
	case 4:
		if (!strcasecmp(argv[3], "peer"))
			return RESULT_SHOWUSAGE;
		if (!strcasecmp(argv[3], "like"))
			return RESULT_SHOWUSAGE;
		if (!strcasecmp(argv[3], "all")) {
			multi = TRUE;
			prunepeer = TRUE;
		} else {
			prunepeer = TRUE;
			name = argv[3];
		}
		break;
	case 5:
		if (!strcasecmp(argv[4], "like"))
			return RESULT_SHOWUSAGE;
		if (!strcasecmp(argv[3], "all"))
			return RESULT_SHOWUSAGE;
		if (!strcasecmp(argv[3], "like")) {
			multi = TRUE;
			name = argv[4];
			prunepeer = TRUE;
		} else if (!strcasecmp(argv[3], "peer")) {
			prunepeer = TRUE;
			if (!strcasecmp(argv[4], "all"))
				multi = TRUE;
			else
				name = argv[4];
		} else
			return RESULT_SHOWUSAGE;
		break;
	case 6:
		if (strcasecmp(argv[4], "like"))
			return RESULT_SHOWUSAGE;
		if (!strcasecmp(argv[3], "peer")) {
			prunepeer = TRUE;
			name = argv[5];
		} else
			return RESULT_SHOWUSAGE;
		break;
	default:
		return RESULT_SHOWUSAGE;
	}

	if (multi && name) {
		if (regcomp(&regexbuf, name, REG_EXTENDED | REG_NOSUB))
			return RESULT_SHOWUSAGE;
	}

	if (multi) {
		if (prunepeer) {
			int pruned = 0;

			ASTOBJ_CONTAINER_WRLOCK(&devicelist);
			ASTOBJ_CONTAINER_TRAVERSE(&devicelist, 1, do {
				ASTOBJ_RDLOCK(iterator);
				if (name && regexec(&regexbuf, iterator->name, 0, NULL, 0)) {
					ASTOBJ_UNLOCK(iterator);
					continue;
				};
				if (ast_test_flag(&iterator->flags[1], SIP_PAGE2_RTCACHEFRIENDS)) {
					ASTOBJ_MARK(iterator);
					pruned++;
				}
				ASTOBJ_UNLOCK(iterator);
			} while (0) );
			if (pruned) {
				ASTOBJ_CONTAINER_PRUNE_MARKED(&devicelist, sip_destroy_device);
				ast_cli(fd, "%d peers pruned.\n", pruned);
			} else
				ast_cli(fd, "No peers found to prune.\n");
			ASTOBJ_CONTAINER_UNLOCK(&devicelist);
		}
	} else {
		if (prunepeer) {
			if ((device = ASTOBJ_CONTAINER_FIND_UNLINK(&devicelist, name))) {
				if (!ast_test_flag((&device->flags[1]), SIP_PAGE2_RTCACHEFRIENDS)) {
					ast_cli(fd, "Device '%s' is not a Realtime peer, cannot be pruned.\n", name);
					ASTOBJ_CONTAINER_LINK(&devicelist, device);
				} else
					ast_cli(fd, "Peer '%s' pruned.\n", name);
				device_unref(device);
			} else
				ast_cli(fd, "Device '%s' not found.\n", name);
		}
	}

	return RESULT_SUCCESS;
}

/*! \brief  Receive SIP INFO Message
\note    Doesn't read the duration of the DTMF signal */
static void handle_request_info(struct sip_dialog *p, struct sip_request *req)
{
	char buf[1024];
	unsigned int event;
	const char *c = get_header(req, "Content-Type");

	if (ast_test_flag(req, SIP_PKT_IGNORE))  {
		transmit_response(p, "200 OK", req);
		return;
	}

	/* All replies to INFO are final */
	dialogstatechange(p, DIALOG_STATE_TERMINATED);

	/* Need to check the media/type */
	if (!strcasecmp(c, "application/dtmf-relay") ||
	    !strcasecmp(c, "application/vnd.nortelnetworks.digits")) {
		unsigned int duration = 0;

		if (p->state == DIALOG_STATE_TRYING) {	/* INFO outside of a dialog */
			transmit_final_response(p, "481 Call leg/transaction does not exist", req, XMIT_UNRELIABLE); /* Should return error */
			return;
		}

		/* Try getting the "signal=" part */
		if (ast_strlen_zero(c = get_body(req, "Signal")) && ast_strlen_zero(c = get_body(req, "d"))) {
			ast_log(LOG_WARNING, "Unable to retrieve DTMF signal from INFO message from %s\n", p->callid);
			transmit_response(p, "200 OK", req); /* Should return error */
			return;
		} else
			ast_copy_string(buf, c, sizeof(buf));

		if (!ast_strlen_zero((c = get_body(req, "Duration"))))
			duration = atoi(c);
		if (!duration)
			duration = 100; /* 100 ms */

	

		if (ast_strlen_zero(buf)) {
			/* Nothing there folks, move on. */
			transmit_response(p, "200 OK", req);
			return;
		}
		/* We have a DTMF code in the attachment */

		if (buf[0] == '*')
			event = 10;
		else if (buf[0] == '#')
			event = 11;
		else if ((buf[0] >= 'A') && (buf[0] <= 'D'))
			event = 12 + buf[0] - 'A';
		else
			event = atoi(buf);
		if (event == 16) {
			/* send a FLASH event */
			struct ast_frame f = { AST_FRAME_CONTROL, AST_CONTROL_FLASH, };
			ast_queue_frame(p->owner, &f);
			if (sipdebug)
				ast_verbose("* DTMF-relay event received: FLASH\n");
		} else {
			/* send a DTMF event */
			struct ast_frame f = { AST_FRAME_DTMF, };
			if (event < 10) {
				f.subclass = '0' + event;
			} else if (event < 11) {
				f.subclass = '*';
			} else if (event < 12) {
				f.subclass = '#';
			} else if (event < 16) {
				f.subclass = 'A' + (event - 12);
			}
			f.len = duration;
			ast_queue_frame(p->owner, &f);
			if (sipdebug)
				ast_verbose("* DTMF-relay event received: %c\n", f.subclass);
		}
		transmit_response(p, "200 OK", req);
		return;
	} else if (!strcasecmp(c, "application/media_control+xml")) {
		/* Eh, we'll just assume it's a fast picture update for now */
		if (p->owner)
			ast_queue_control(p->owner, AST_CONTROL_VIDUPDATE);
		transmit_response(p, "200 OK", req);
		return;
	} else if (!ast_strlen_zero(c = get_header(req, "X-ClientCode"))) {
		/* Client code (from SNOM phone) */
		if (ast_test_flag(&p->flags[0], SIP_USECLIENTCODE)) {
			if (p->owner && p->owner->cdr)
				ast_cdr_setuserfield(p->owner, c);
			if (p->owner && ast_bridged_channel(p->owner) && ast_bridged_channel(p->owner)->cdr)
				ast_cdr_setuserfield(ast_bridged_channel(p->owner), c);
			transmit_response(p, "200 OK", req);
		} else {
			transmit_response(p, "415 Unsupported media type", req);
		}
		return;
	}
	/* Other type of INFO message, not really understood by Asterisk */
	/* if (get_msg_text(buf, sizeof(buf), req)) { */

	ast_log(LOG_WARNING, "Unable to parse INFO message from %s. Content %s\n", p->callid, buf);
	transmit_response(p, "415 Unsupported media type", req);
	return;
}

/*! \brief Cli command to send SIP notify to peer */
GNURK int sip_notify(int fd, int argc, char *argv[])
{
	struct ast_variable *varlist;
	int i;

	if (argc < 4)
		return RESULT_SHOWUSAGE;

	if (!notify_types) {
		ast_cli(fd, "No %s file found, or no types listed there\n", notify_config);
		return RESULT_FAILURE;
	}

	varlist = ast_variable_browse(notify_types, argv[2]);

	if (!varlist) {
		ast_cli(fd, "Unable to find notify type '%s'\n", argv[2]);
		return RESULT_FAILURE;
	}

	for (i = 3; i < argc; i++) {
		struct sip_dialog *dialog;
		struct sip_request *req;
		struct ast_variable *var;
		struct sip_device *peer;

		if (!(dialog = sip_alloc(NULL, NULL, FALSE, SIP_NOTIFY))) {
			ast_log(LOG_WARNING, "Unable to build sip pvt data for notify (memory/socket error)\n");
			return RESULT_FAILURE;
		}

		peer = find_device(argv[i], NULL, 1);

		if (peer && create_addr_from_peer(dialog, peer)) {
			/* Maybe they're not registered, etc. */
			sip_destroy(dialog);
			ast_cli(fd, "Could not create address for '%s'\n", argv[i]);
			continue;
		}
		if (peer)
			device_unref(peer);
		req = siprequest_alloc(SIP_MAX_PACKET, &sipnet);
		if (!req) {
			ast_log(LOG_WARNING, "Unable to build sip request data for notify (memory/socket error)\n");
			return RESULT_FAILURE;
		}

		initreqprep(req, dialog, SIP_NOTIFY);

		for (var = varlist; var; var = var->next)
			add_header(req, var->name, var->value);

		/* Recalculate our side, and recalculate Call ID */
		if (sip_ouraddrfor(&dialog->sa.sin_addr, &dialog->ourip))
			dialog->ourip = sipnet.__ourip;
		build_via(dialog, FALSE);
		build_callid_pvt(dialog);
		ast_cli(fd, "Sending NOTIFY of type '%s' to '%s'\n", argv[2], argv[i]);
		transmit_sip_request(dialog, req);
		siprequest_free(req);
		sip_scheddestroy(dialog, -1);
	}

	return RESULT_SUCCESS;
}

/*! \brief Read SIP header (dialplan function) */
static int func_header_read(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len) 
{
	struct sip_dialog *p;
	const char *content = NULL;
	AST_DECLARE_APP_ARGS(args,
		AST_APP_ARG(header);
		AST_APP_ARG(number);
	);
	int i, number, start = 0;

 	if (ast_strlen_zero(data)) {
		ast_log(LOG_WARNING, "This function requires a header name.\n");
		return -1;
	}

	ast_channel_lock(chan);
	if (chan->tech != &sip_tech && chan->tech != &sip_tech_info) {
		ast_log(LOG_WARNING, "This function can only be used on SIP channels.\n");
		ast_channel_unlock(chan);
		return -1;
	}

	AST_STANDARD_APP_ARGS(args, data);
	if (!args.number) {
		number = 1;
	} else {
		sscanf(args.number, "%d", &number);
		if (number < 1)
			number = 1;
	}

	p = chan->tech_pvt;

	/* If there is no private structure, this channel is no longer alive */
	if (!p) {
		ast_channel_unlock(chan);
		return -1;
	}

	for (i = 0; i < number; i++)
		content = __get_header(p->initreq, args.header, &start);

	if (ast_strlen_zero(content)) {
		ast_channel_unlock(chan);
		return -1;
	}

	ast_copy_string(buf, content, len);
	ast_channel_unlock(chan);

	return 0;
}

static struct ast_custom_function sip_header_function = {
	.name = "SIP_HEADER",
	.synopsis = "Gets the specified SIP header from the INVITE",
	.syntax = "SIP_HEADER(<name>[,<number>])",
	.desc = "Since there are several headers (such as Via) which can occur multiple\n"
		"times, SIP_HEADER takes an optional second argument to specify which header with\n"
		"that name to retrieve. Headers start at offset 1.\n",
	.read = func_header_read,
};

/*! \brief  ${SIPPEER()} Dialplan function - reads peer data */
static int function_sippeer(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)
{
	struct sip_device *peer;
	char *colname;

	if ((colname = strchr(data, '|')))
		*colname++ = '\0';
	else
		colname = "ip";

	if (!(peer = find_device(data, NULL, 1)))
		return -1;

	if (!strcasecmp(colname, "ip")) {
		ast_copy_string(buf, peer->addr.sin_addr.s_addr ? ast_inet_ntoa(peer->addr.sin_addr) : "", len);
	} else  if (!strcasecmp(colname, "status")) {
		device_status(peer, buf, len);
	} else  if (!strcasecmp(colname, "language")) {
		ast_copy_string(buf, peer->language, len);
	} else  if (!strcasecmp(colname, "regexten")) {
		ast_copy_string(buf, peer->extra.regexten, len);
	} else  if (!strcasecmp(colname, "limit")) {
		snprintf(buf, len, "%d", peer->call_limit);
	} else  if (!strcasecmp(colname, "curcalls")) {
		snprintf(buf, len, "%d", peer->inUse);
	} else  if (!strcasecmp(colname, "accountcode")) {
		ast_copy_string(buf, peer->extra.accountcode, len);
	} else  if (!strcasecmp(colname, "useragent")) {
		ast_copy_string(buf, peer->useragent, len);
	} else  if (!strcasecmp(colname, "mailbox")) {
		ast_copy_string(buf, peer->mailbox.mailbox, len);
	} else  if (!strcasecmp(colname, "context")) {
		ast_copy_string(buf, peer->extra.context, len);
	} else  if (!strcasecmp(colname, "expire")) {
		snprintf(buf, len, "%d", peer->expire);
	} else  if (!strcasecmp(colname, "dynamic")) {
		ast_copy_string(buf, (ast_test_flag(&peer->flags[1], SIP_PAGE2_DYNAMIC) ? "yes" : "no"), len);
	} else  if (!strcasecmp(colname, "callerid_name")) {
		ast_copy_string(buf, peer->extra.cid_name, len);
	} else  if (!strcasecmp(colname, "callerid_num")) {
		ast_copy_string(buf, peer->extra.cid_num, len);
	} else  if (!strcasecmp(colname, "codecs")) {
		ast_getformatname_multiple(buf, len -1, peer->capability);
	} else  if (!strncasecmp(colname, "codec[", 6)) {
		char *codecnum;
		int index = 0, codec = 0;
		
		codecnum = colname + 6;	/* move past the '[' */
		codecnum = strsep(&codecnum, "]"); /* trim trailing ']' if any */
		index = atoi(codecnum);
		if((codec = ast_codec_pref_index(&peer->prefs, index))) {
			ast_copy_string(buf, ast_getformatname(codec), len);
		}
	}

	device_unref(peer);

	return 0;
}

/*! \brief Structure to declare a dialplan function: SIPPEER */
struct ast_custom_function sippeer_function = {
	.name = "SIPPEER",
	.synopsis = "Gets SIP peer information",
	.syntax = "SIPPEER(<peername>[|item])",
	.read = function_sippeer,
	.desc = "Valid items are:\n"
	"- ip (default)          The IP address.\n"
	"- mailbox               The configured mailbox.\n"
	"- context               The configured context.\n"
	"- expire                The epoch time of the next expire.\n"
	"- dynamic               Is it dynamic? (yes/no).\n"
	"- callerid_name         The configured Caller ID name.\n"
	"- callerid_num          The configured Caller ID number.\n"
	"- codecs                The configured codecs.\n"
	"- status                Status (if qualify=yes).\n"
	"- regexten              Registration extension\n"
	"- limit                 Call limit (call-limit)\n"
	"- curcalls              Current amount of calls \n"
	"                        Only available if call-limit is set\n"
	"- language              Default language for peer\n"
	"- accountcode           Account code for this peer\n"
	"- useragent             Current user agent id for peer\n"
	"- codec[x]              Preferred codec index number 'x' (beginning with zero).\n"
	"\n"
};

/*! \brief ${SIPCHANINFO()} Dialplan function - reads sip channel data */
static int function_sipchaninfo_read(struct ast_channel *chan, const char *cmd, char *data, char *buf, size_t len)
{
	struct sip_dialog *p;

	*buf = 0;
	
 	if (!data) {
		ast_log(LOG_WARNING, "This function requires a parameter name.\n");
		return -1;
	}

	ast_channel_lock(chan);
	if (chan->tech != &sip_tech && chan->tech != &sip_tech_info) {
		ast_log(LOG_WARNING, "This function can only be used on SIP channels.\n");
		ast_channel_unlock(chan);
		return -1;
	}

	p = chan->tech_pvt;

	/* If there is no private structure, this channel is no longer alive */
	if (!p) {
		ast_channel_unlock(chan);
		return -1;
	}

	if (!strcasecmp(data, "peerip")) {
		ast_copy_string(buf, p->sa.sin_addr.s_addr ? ast_inet_ntoa(p->sa.sin_addr) : "", len);
	} else  if (!strcasecmp(data, "recvip")) {
		ast_copy_string(buf, p->recv.sin_addr.s_addr ? ast_inet_ntoa(p->recv.sin_addr) : "", len);
	} else  if (!strcasecmp(data, "from")) {
		ast_copy_string(buf, p->from, len);
	} else  if (!strcasecmp(data, "uri")) {
		ast_copy_string(buf, p->uri, len);
	} else  if (!strcasecmp(data, "useragent")) {
		ast_copy_string(buf, p->useragent, len);
	} else  if (!strcasecmp(data, "peername")) {
		ast_copy_string(buf, p->peername, len);
	} else if (!strcasecmp(data, "t38passthrough")) {
		if (p->t38.state == T38_DISABLED)
			ast_copy_string(buf, "0", sizeof("0"));
		else    /* T38 is offered or enabled in this call */
			ast_copy_string(buf, "1", sizeof("1"));
	} else {
		ast_channel_unlock(chan);
		return -1;
	}
	ast_channel_unlock(chan);

	return 0;
}

/*! \brief Structure to declare a dialplan function: SIPCHANINFO */
static struct ast_custom_function sipchaninfo_function = {
	.name = "SIPCHANINFO",
	.synopsis = "Gets the specified SIP parameter from the current channel",
	.syntax = "SIPCHANINFO(item)",
	.read = function_sipchaninfo_read,
	.desc = "Valid items are:\n"
	"- peerip                The IP address of the peer.\n"
	"- recvip                The source IP address of the peer.\n"
	"- from                  The URI from the From: header.\n"
	"- uri                   The URI from the Contact: header.\n"
	"- useragent             The useragent.\n"
	"- peername              The name of the peer.\n"
	"- t38passthrough        1 if T38 is offered or enabled in this channel, otherwise 0\n"
};

/*! \brief Check pending actions on SIP call */
static void check_pendings(struct sip_dialog *p)
{
	if (ast_test_flag(&p->flags[0], SIP_PENDINGBYE)) {
		/* if we can't BYE, then this is really a pending CANCEL */
		if (!ast_test_flag(&p->flags[0], SIP_CAN_BYE))
			transmit_request_with_auth(p, SIP_CANCEL, p->ocseq, 1, 0);
			/* Actually don't destroy us yet, wait for the 487 on our original 
			   INVITE, but do set an autodestruct just in case we never get it. */
		else 
			transmit_request_with_auth(p, SIP_BYE, 0, 1, 1);
		ast_clear_flag(&p->flags[0], SIP_PENDINGBYE);	
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
	} else if (ast_test_flag(&p->flags[0], SIP_NEEDREINVITE)) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Sending pending reinvite on '%s'\n", p->callid);
		/* Didn't get to reinvite yet, so do it now */
		transmit_reinvite_with_sdp(p, FALSE);
		ast_clear_flag(&p->flags[0], SIP_NEEDREINVITE);	
	}
}

/*! \brief Handle a positive response to an INVITE - 200 OK */
static void handle_response_answer(struct sip_dialog *dialog, struct sip_request *req, int outgoing, int reinvite)
{
	int res; 	/*! \note XXX Not used now, but somehow we need to handle response from process_sdp */
	struct ast_channel *bridgepeer = NULL;

	/* If we have SDP in the 200 OK, then process it */
	if (find_sdp(req)) {
		if ((res = process_sdp(dialog, req)) && !ast_test_flag(req, SIP_PKT_IGNORE))
			if (!reinvite)
				/* This 200 OK's SDP is not acceptable, so we need to ack, then hangup */
				/* For re-invites, we try to recover */
				ast_set_flag(&dialog->flags[0], SIP_PENDINGBYE);	
	} else 
		ast_log(LOG_NOTICE, "200 OK on INVITE without SDP??? Call-ID: %s\n", dialog->callid);

	/* Parse contact header for continued conversation */
	/* When we get 200 OK, we know which device (and IP) to contact for this call */
	/* This is important when we have a SIP proxy between us and the phone */
	if (outgoing) {
		update_call_counter(dialog, DEC_CALL_RINGING);
		parse_ok_contact(dialog, req);
		if(set_address_from_contact(dialog)) {
			/* Bad contact - we don't know how to reach this device */
			/* We need to ACK, but then send a bye */
			/* OEJ: Possible issue that may need a check:
				If we have a proxy route between us and the device,
				should we care about resolving the contact
				or should we just send it?
			*/
			if (!ast_test_flag(req, SIP_PKT_IGNORE))
				ast_set_flag(&dialog->flags[0], SIP_PENDINGBYE);	
		} 

		/* Save Record-Route for any later requests we make on this dialogue */
		build_route(dialog, req, 1);
	}
		
	if (dialog->owner && (dialog->owner->_state == AST_STATE_UP) && (bridgepeer = ast_bridged_channel(dialog->owner))) { /* if this is a re-invite */
		struct sip_dialog *bridge_dialog = NULL;

		if (!bridgepeer->tech) {
			ast_log(LOG_WARNING, "Ooooh.. no tech!  That's REALLY bad\n");
			return;		/*! \todo Fix this - this looks really bad */
		}
		if (bridgepeer->tech == &sip_tech || bridgepeer->tech == &sip_tech_info) {
			bridge_dialog = (struct sip_dialog *)(bridgepeer->tech_pvt);
			if (bridge_dialog->udptl) {
				if (dialog->t38.state == T38_PEER_REINVITE) {
					sip_handle_t38_reinvite(bridgepeer, dialog, 0);
					ast_rtp_set_rtptimers_onhold(dialog->rtp);
					if (dialog->vrtp)
						ast_rtp_set_rtptimers_onhold(dialog->vrtp);	/* Turn off RTP timers while we send fax */
				} else if (dialog->t38.state == T38_DISABLED && bridgepeer && (bridge_dialog->t38.state == T38_ENABLED)) {
					ast_log(LOG_WARNING, "RTP re-invite after T38 session not handled yet !\n");
					/* Insted of this we should somehow re-invite the other side of the bridge to RTP */
					if (!ast_test_flag(req, SIP_PKT_IGNORE))
						ast_set_flag(&dialog->flags[0], SIP_PENDINGBYE);	
				}
			} else {
				if (option_debug > 1)
					ast_log(LOG_DEBUG, "Strange... The other side of the bridge does not have a udptl struct\n");
				dialog_lock(bridge_dialog, TRUE);
				bridge_dialog->t38.state = T38_DISABLED;
				dialog_lock(bridge_dialog, FALSE);
				if (option_debug)
					ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", bridge_dialog->t38.state, bridgepeer->tech->type);
				dialog->t38.state = T38_DISABLED;
				if (option_debug > 1)
					ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", dialog->t38.state, dialog->owner ? dialog->owner->name : "<none>");
			}
		} else {
			/* Other side is not a SIP channel */
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "Strange... The other side of the bridge is not a SIP channel\n");
			dialog->t38.state = T38_DISABLED;
			if (option_debug > 1)
				ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", dialog->t38.state, dialog->owner ? dialog->owner->name : "<none>");
		}
	}
	if ((dialog->t38.state == T38_LOCAL_REINVITE) || (dialog->t38.state == T38_LOCAL_DIRECT)) {
		/* If there was T38 reinvite and we are supposed to answer with 200 OK than this should set us to T38 negotiated mode */
		dialog->t38.state = T38_ENABLED;
		if (option_debug)
			ast_log(LOG_DEBUG, "T38 changed state to %d on channel %s\n", dialog->t38.state, dialog->owner ? dialog->owner->name : "<none>");
	}

	/* Ok, let's go */
	if (!ast_test_flag(req, SIP_PKT_IGNORE) && dialog->owner) {
		if (!reinvite) 
			ast_queue_control(dialog->owner, AST_CONTROL_ANSWER);
		else 	/* RE-invite */
			ast_queue_frame(dialog->owner, &ast_null_frame);
	} else {
		 /* It's possible we're getting an 200 OK after we've tried to disconnect
			  by sending CANCEL */
		/* First send ACK, then send bye */
		if (!ast_test_flag(req, SIP_PKT_IGNORE))
			ast_set_flag(&dialog->flags[0], SIP_PENDINGBYE);	
	}
}

/*! \brief Handle SIP response to INVITE dialogue */
static void handle_response_invite(struct sip_dialog *p, int resp, char *rest, struct sip_request *req)
{
	int outgoing = ast_test_flag(&p->flags[0], SIP_OUTGOING);
	int res = 0;
	int reinvite = (p->owner && p->owner->_state == AST_STATE_UP);
	
	if (option_debug > 3) {
		if (reinvite)
			ast_log(LOG_DEBUG, "SIP response %d to RE-invite on %s call %s\n", resp, outgoing ? "outgoing" : "incoming", p->callid);
		else
			ast_log(LOG_DEBUG, "SIP response %d to standard invite\n", resp);
	}

	//sif (ast_test_flag(&p->flags[0], SIP_ALREADYGONE)) { /* This call is already gone */
	if (p->state == DIALOG_STATE_TERMINATED) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Got response on call that is already terminated: %s (ignoring)\n", p->callid);
		return;
	}

	/* Acknowledge sequence number - This only happens on INVITE from SIP-call */
	if (p->initid > -1) {
		/* Don't auto congest anymore since we've gotten something useful back */
		ast_sched_del(sched, p->initid);
		p->initid = -1;
	}

	/* RFC3261 says we must treat every 1xx response (but not 100)
	   that we don't recognize as if it was 183.
	*/
	if ((resp > 100) &&
	    (resp < 200) &&
	    (resp != 180) &&
	    (resp != 183))
		resp = 183;


	if (p->state == DIALOG_STATE_TRYING)
		dialogstatechange(p, DIALOG_STATE_PROCEEDING);	/* We do have any type of response */
	/* If we got 1xx reply WITH tag, it has to be DIALOG_STATE_EARLY */

	switch (resp) {
	case 100:	/* Trying */
		if (!ast_test_flag(req, SIP_PKT_IGNORE))
			sip_cancel_destroy(p);
		check_pendings(p);
		break;
	case 180:	/* 180 Ringing */
		if (!ast_test_flag(req, SIP_PKT_IGNORE))
			sip_cancel_destroy(p);
		if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner) {
			ast_queue_control(p->owner, AST_CONTROL_RINGING);
			if (p->owner->_state != AST_STATE_UP) {
				ast_setstate(p->owner, AST_STATE_RINGING);
			}
		}
		if (find_sdp(req)) {
			res = process_sdp(p, req);
			if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner) {
				/* Queue a progress frame only if we have SDP in 180 */
				ast_queue_control(p->owner, AST_CONTROL_PROGRESS);
			}
		}
		ast_set_flag(&p->flags[0], SIP_CAN_BYE);
		check_pendings(p);
		break;
	case 183:	/* Session progress */
		if (!ast_test_flag(req, SIP_PKT_IGNORE))
			sip_cancel_destroy(p);
		/* Ignore 183 Session progress without SDP */
		if (find_sdp(req)) {
			res = process_sdp(p, req);
			if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner) {
				/* Queue a progress frame */
				ast_queue_control(p->owner, AST_CONTROL_PROGRESS);
			}
		}
		dialogstatechange(p, DIALOG_STATE_EARLY);	/* We do have any type of response */
		ast_set_flag(&p->flags[0], SIP_CAN_BYE);
		check_pendings(p);
		break;
	case 200:	/* 200 OK on invite - someone's answering our call */
		if (!ast_test_flag(req, SIP_PKT_IGNORE))
			sip_cancel_destroy(p);
		dialogstatechange(p, DIALOG_STATE_CONFIRMED);	/* We do have any type of response */
		p->authtries = 0;
		/* Ok, we got an answer - let's talk */
		handle_response_answer(p, req, outgoing, reinvite);

		/* If I understand this right, the branch is different for a non-200 ACK only */
		transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, TRUE);
		ast_set_flag(&p->flags[0], SIP_CAN_BYE);
		check_pendings(p);
		break;
	case 300: /* Multiple Choices */
	case 301: /* Moved permenantly */
	case 302: /* Moved temporarily */
	case 305: /* Use Proxy */
		ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
		stop_media_flows(p);	/* Stop RTP, VRTP and UDPTL */
		parse_moved_contact(p, req);
		if (p->owner)
			ast_queue_control(p->owner, AST_CONTROL_BUSY);
		break;
	case 407: /* Proxy authentication */
	case 401: /* Www auth */
		if (p->inviteoptions)
			p->inviteoptions->auth_type = resp;

		/* Then we AUTH */
		ast_string_field_free(p, theirtag);	/* forget their old tag, so we don't match tags when getting response */
		//??? dialogstatechange(p, DIALOG_STATE_TERMINATED_AUTH);	
		if (!ast_test_flag(req, SIP_PKT_IGNORE)) {
			if (p->authtries < MAX_AUTHTRIES)
				dialogstatechange(p, DIALOG_STATE_TRYING);
			if (p->authtries == MAX_AUTHTRIES || do_proxy_auth(p, req, resp, SIP_INVITE, 1)) {
				ast_log(LOG_NOTICE, "Failed to authenticate on INVITE to '%s'\n", get_header(p->initreq, "From"));
				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
				ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
				if (p->owner)
					ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
				dialogstatechange(p, DIALOG_STATE_TERMINATED);	
			}
		}
		break;
	case 403: /* Forbidden */
		ast_log(LOG_WARNING, "Received response: \"Forbidden\" from '%s'\n", get_header(p->initreq, "From"));
		if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner)
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
		ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
		break;
	case 404: /* Not found */
	case 410: /* Gone */
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		if (p->owner && !ast_test_flag(req, SIP_PKT_IGNORE))
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
		break;
	case 481: /* Call leg does not exist */
		/* Could be REFER caused INVITE with replaces header that refers to non-existing call  */
		ast_log(LOG_WARNING, "Re-invite to non-existing call leg on other UA. SIP dialog '%s'. Giving up.\n", p->callid);
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		if (p->owner)
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		break;
	case 482: 
		 /* So we treat this as a call forward and hope we end up at the right place... */
		if (option_debug)
			ast_log(LOG_DEBUG, "Hairpin detected, setting up call forward for what it's worth\n");
		if (p->owner) {
			ast_string_field_build(p->owner, call_forward, "Local/%s@%s", p->peername, p->context);
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		}
		break;
	case 487:	/* Response on INVITE that has been CANCELled */
		/* channel now destroyed - dec the inUse counter */
		if (p->owner)
			ast_queue_hangup(p->owner);
		update_call_counter(p, DEC_CALL_LIMIT);
		break;
	case 491: /* Pending */
		/* we have to wait a while, then retransmit */
		/* Transmission is rescheduled, so everything should be taken care of.
			We should support the retry-after at some point */
		/*! \todo fix 491 pending support */
		break;
	case 488: /* Not acceptable here - codec error */
	case 501: /* Not implemented */
	case 400: /* Bad Request */
	case 500: /* Server error */
	case 504: /* server timeout */
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		if (p->owner)
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
		break;
	case 486: /* Busy here */
	case 600: /* Busy everywhere */
	case 603: /* Decline */
	case 480: /* Temporarily Unavailable */
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
		stop_media_flows(p);	/* Stop RTP, VRTP and UDPTL */
		if (p->owner)
			ast_queue_control(p->owner, AST_CONTROL_BUSY);
		break;
	}
	/* Transmit ACK here and now for all failure messages */
	if (resp >= 300)
		transmit_request(p, SIP_ACK, req->seqno, XMIT_UNRELIABLE, FALSE);
}

/* \brief Handle SIP response in REFER transaction
	We've sent a REFER, now handle responses to it 
  */
static void handle_response_refer(struct sip_dialog *p, int resp, char *rest, struct sip_request *req)
{
	switch (resp) {
	case 202:   /* Transfer accepted */
		/* We need  to do something here */
		/* The transferee is now sending INVITE to target */
		p->refer->status = REFER_ACCEPTED;
		/* Now wait for next message */
		if (option_debug > 2)
			ast_log(LOG_DEBUG, "Got 202 accepted on transfer\n");
		/* We should hang along, waiting for NOTIFY's here */
		break;

	case 401:   /* Not www-authorized on SIP method */
	case 407:   /* Proxy auth */
		if (ast_strlen_zero(p->authname)) {
			ast_log(LOG_WARNING, "Asked to authenticate REFER to %s:%d but we have no matching peer or realm auth!\n",
				ast_inet_ntoa(p->recv.sin_addr), ntohs(p->recv.sin_port));
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
		}
		if (p->authtries > 1 || do_proxy_auth(p, req, resp, SIP_REFER, 0)) {
			ast_log(LOG_NOTICE, "Failed to authenticate on REFER to '%s'\n", get_header(p->initreq, "From"));
			p->refer->status = REFER_NOAUTH;
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
		}
		break;
	case 481: /* Call leg does not exist */
		/* A transfer with Replaces did not work */
		/* OEJ: We should Set flag, cancel the REFER, go back to original call - but right now we can't */
		ast_log(LOG_WARNING, "Remote host can't match REFER request to call '%s'. Giving up.\n", p->callid);
		if (p->owner) {
			ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
		}
		break;

	case 500:   /* Server error */
	case 501:   /* Method not implemented */
		/* Return to the current call onhold */
		/* Status flag needed to be reset */
		ast_log(LOG_NOTICE, "SIP transfer to %s failed, call miserably fails. \n", p->refer->refer_to);
		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
		p->refer->status = REFER_FAILED;
		break;
	case 603:   /* Transfer declined */
		ast_log(LOG_NOTICE, "SIP transfer to %s declined, call miserably fails. \n", p->refer->refer_to);
		p->refer->status = REFER_FAILED;
		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
		break;
	}
}

/* \brief Handle SIP response in NOTIFY transaction */
static void handle_response_notify(struct sip_dialog *dialog, int resp, char *rest, struct sip_request *req)
{
	switch(resp) {
	case 200:	/* 200 OK */
		/* They got the notify, this is the end */
		if (dialog->owner) {
			if (!dialog->refer) {
				ast_log(LOG_WARNING, "Notify answer on an owned channel? - %s\n", dialog->owner->name);
				ast_queue_hangup(dialog->owner);
			} else if (option_debug > 3) 
				ast_log(LOG_DEBUG, "Got OK on REFER Notify message\n");
		} else if (dialog->subscribed == NONE) 
			ast_set_flag(&dialog->flags[0], SIP_NEEDDESTROY); 
		dialogstatechange(dialog, DIALOG_STATE_TERMINATED);
		break;
	default: 
		if (option_debug)
			ast_log(LOG_DEBUG, "Got unexpected answer on NOTIFY: %d - Call ID %s\n", resp, dialog->callid);
		break;
	}
}

/* \brief Handle SIP response in MESSAGE transaction */
static void handle_response_message(struct sip_dialog *dialog, int resp, char *rest, struct sip_request *req)
{
	switch(resp) {
	case 200:	/* 200 OK */
		dialog->authtries = 0;	/* Reset authentication counter */
		/* We successfully transmitted a message */
		ast_set_flag(&dialog->flags[0], SIP_NEEDDESTROY);	
		break;
	default: 
		if (option_debug)
			ast_log(LOG_DEBUG, "Got unexpected answer on MESSAGE: %d - Call ID %s\n", resp, dialog->callid);
		break;
	}
}

/* \brief Handle SIP response in BYE transaction */
static void handle_response_bye(struct sip_dialog *dialog, int resp, char *rest, struct sip_request *req)
{
	if (resp == 401 || resp == 407) {
		if (ast_strlen_zero(dialog->authname))
			ast_log(LOG_WARNING, "Asked to authenticate BYE, to %s:%d but we have no matching peer!\n",
					ast_inet_ntoa(dialog->recv.sin_addr), ntohs(dialog->recv.sin_port));
		if (dialog->authtries == MAX_AUTHTRIES || do_proxy_auth(dialog, req, resp, SIP_BYE, 0)) {
			ast_log(LOG_NOTICE, "Failed to authenticate on BYE to '%s'\n", get_header(dialog->initreq, "From"));
			ast_set_flag(&dialog->flags[0], SIP_NEEDDESTROY);	
		}
	} else {
		if (resp == 481) { /* Can't match call leg */
			/* The other side has no transaction to bye, just assume it's all right then */
			ast_log(LOG_WARNING, "Remote host can't match BYE request to call '%s'. Giving up.\n", dialog->callid);
		}
		/* Regardless of response, just destroy the call now */
		ast_set_flag(&dialog->flags[0], SIP_NEEDDESTROY); 
	}
}


/*! \brief Handle SIP response in dialogue */
/* XXX only called by handle_request */
static void handle_response(struct sip_dialog *p, int resp, char *rest, struct sip_request *req)
{
	struct ast_channel *owner;
	int sipmethod;
	const char *c = req->cseqheader;
	const char *msg = strchr(c, ' ');

	/* Find the method of the request this response is an reply to */
	if (!msg)
		msg = "";
	else
		msg++;
	
	sipmethod = find_sip_method(msg);

	owner = p->owner;
	if (owner && resp > 199) 
		owner->hangupcause = hangup_sip2cause(resp);

	/* Acknowledge whatever it is destined for */
	if ((resp >= 100) && (resp <= 199))	/* Provisional responses */
		__sip_semi_ack(p, req->seqno, 0, sipmethod);
	else	/* Final response */
		__sip_ack(p, req->seqno, 0, sipmethod, resp == 491 ? TRUE : FALSE);

	/* Get their tag if we haven't already */
	if (ast_strlen_zero(p->theirtag) || (resp >= 200)) {
		char tag[128];

		gettag(req->to, tag, sizeof(tag));
		ast_string_field_set(p, theirtag, tag);
	}

	switch (sipmethod) {
	case SIP_OPTIONS:
		/* We don't really care what the response is, just that it replied back. 
		   Well, as long as it's not a 100 response...  since we might
		   need to hang around for something more "definitive" */
		handle_response_peerpoke(p, resp, req);
		break;
	case SIP_MESSAGE:
		handle_response_message(p, resp, rest, req);
		break;
	case SIP_NOTIFY:
		handle_response_notify(p, resp, rest, req);
		break;
	case SIP_INVITE:
		handle_response_invite(p, resp, rest, req);
		break;
	case SIP_REGISTER:
		handle_response_register(p, resp, rest, req, req->seqno);
		break;
	case SIP_REFER:
		handle_response_refer(p, resp, rest, req);
		break;
	case SIP_BYE:
		handle_response_bye(p, resp, rest, req);
		break;
	case SIP_CANCEL:
		switch(resp) {
		case 200:	/* 200 OK */
			if (option_debug)
				ast_log(LOG_DEBUG, "Got 200 OK on CANCEL\n");

			/* Wait for 487, then destroy */
			break;
		case 481:
			ast_log(LOG_WARNING, "Remote host can't match request %s to call '%s'. Giving up.\n", sip_method2txt(sipmethod), p->callid);
			break;
		}
		break;
	default:
		/* All other cases - which is ??? */

		switch(resp) {
		case 100:	/* 100 Trying */
		case 183:	/* 183 Session Progress */
		case 180:	/* 180 Ringing */
		case 200:	/* 200 OK */
		case 202:   /* Transfer accepted */
			break;
		case 401: /* Not www-authorized on SIP method */
		case 407: /* Proxy auth required */
			ast_log(LOG_WARNING, "Got authentication request (401) on unknown %s to '%s'\n", sip_method2txt(sipmethod), get_header(req, "To"));
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
			break;
		case 403: /* Forbidden - we failed authentication */
			ast_log(LOG_WARNING, "Forbidden - maybe wrong password on authentication for %s\n", msg);
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
			break;
		case 404: /* Not found */
			if (owner)
				ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
			break;
		case 423: /* Interval too brief */
			ast_log(LOG_WARNING, "Got 423 Interval to brief in response. Don't know how to handle that. Call-ID %s\n", p->callid);
			break;
		case 481: /* Call leg does not exist */
			ast_log(LOG_WARNING, "Remote host can't match request %s to call '%s'. Giving up.\n", sip_method2txt(sipmethod), p->callid);
				/* Guessing that this is not an important request */
			break;
		case 491: /* Pending */
			if (option_debug)
				ast_log(LOG_DEBUG, "Got 491 on %s, unspported. Call ID %s\n", sip_method2txt(sipmethod), p->callid);
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
			break;
		case 501: /* Not Implemented */
			ast_log(LOG_WARNING, "Host '%s' does not implement '%s'\n", ast_inet_ntoa(p->sa.sin_addr), msg);
			break;
		case 603:	/* Declined */
			/* Fallthrough */
		default:
			if ((resp >= 300) && (resp < 700)) {
				int congest = FALSE;

				/* Fatal response */
				if ((option_verbose > 2) && (resp != 487))
					ast_verbose(VERBOSE_PREFIX_3 "Got SIP response %d \"%s\" back from %s\n", resp, rest, ast_inet_ntoa(p->sa.sin_addr));
				/* XXX Locking issues?? XXX */
				switch(resp) {
				case 300: /* Multiple Choices */
				case 301: /* Moved permenantly */
				case 302: /* Moved temporarily */
				case 305: /* Use Proxy */
				case 486: /* Busy here */
				case 600: /* Busy everywhere */
				case 487: /* Response on INVITE that has been CANCELled */
				case 488: /* Not acceptable here - codec error */
				case 482: /* Loop detected */
					break;
				case 480: /* Temporarily Unavailable */
				case 404: /* Not Found */
				case 410: /* Gone */
				case 400: /* Bad Request */
				case 500: /* Server error */
				case 503: /* Service Unavailable */
				case 504: /* server timeout */
					if (owner) {
						ast_queue_control(p->owner, AST_CONTROL_CONGESTION);
						congest = TRUE;
					}
					break;
				default:
					/* Send hangup */	
					break;
				}
				/* Ok, we got an error response, so let's kill this,
					whatever it is */
				if (p->owner && !congest)
					ast_queue_hangup(p->owner);
				stop_media_flows(p);	/* Stop RTP, VRTP and UDPTL */
				ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
				if (!p->owner)
					ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
			} else
				ast_log(LOG_NOTICE, "Dont know how to handle a %d %s response from %s\n", resp, rest, p->owner ? p->owner->name : ast_inet_ntoa(p->sa.sin_addr));
		}
	}

}


/*! \brief Turn off generator data 
	XXX Does this function belong in the SIP channel?
*/
GNURK void ast_quiet_chan(struct ast_channel *chan) 
{
	if (chan && chan->_state == AST_STATE_UP) {
		if (chan->generatordata)
			ast_deactivate_generator(chan);
	}
}

/*! \brief Handle incoming notifications 
 * \note Out of dialog NOTIFY messages are killed in match_or_create_dialog()
 	If implementing VMI support, that needs to change 
 */
static int handle_request_notify(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e)
{
	/* This is mostly a skeleton for future improvements */
	/* Mostly created to return proper answers on notifications on outbound REFER's */
	int res = 0;
	const char *event = get_header(req, "Event");
	char *eventid = NULL;
	char *sep;

	if( (sep = strchr(event, ';')) ) {	/* XXX bug here - overwriting string ? */
		*sep++ = '\0';
		eventid = sep;
	}
	
	if (option_debug > 1 && sipdebug)
		ast_log(LOG_DEBUG, "Got NOTIFY Event: %s\n", event);

	if (strcmp(event, "refer")) {
		/* We don't understand this event. */
		/* Here's room to implement incoming voicemail notifications :-) */
		transmit_response(p, "489 Bad event", req);
		if (!p->lastinvite) 
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		return -1;
	} else {
		/* Save nesting depth for now, since there might be other events we will
			support in the future */

		/* Handle REFER notifications */

		char buf[1024];
		char *cmd, *code;
		int respcode;
		int success = TRUE;

		/* EventID for each transfer... EventID is basically the REFER cseq 

		 We are getting notifications on a call that we transfered
		 We should hangup when we are getting a 200 OK in a sipfrag
		 Check if we have an owner of this event */
		
		/* Check the content type */
		if (strncasecmp(get_header(req, "Content-Type"), "message/sipfrag", strlen("message/sipfrag"))) {
			/* We need a sipfrag */
			transmit_response(p, "400 Bad request", req);
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			return -1;
		}

		/* Get the text of the attachment */
		if (get_msg_text(buf, sizeof(buf), req)) {
			ast_log(LOG_WARNING, "Unable to retrieve attachment from NOTIFY %s\n", p->callid);
			transmit_response(p, "400 Bad request", req);
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			return -1;
		}

		/*
		From the RFC...
		A minimal, but complete, implementation can respond with a single
   		NOTIFY containing either the body:
      			SIP/2.0 100 Trying
		
   		if the subscription is pending, the body:
      			SIP/2.0 200 OK
   		if the reference was successful, the body:
      			SIP/2.0 503 Service Unavailable
   		if the reference failed, or the body:
      			SIP/2.0 603 Declined

   		if the REFER request was accepted before approval to follow the
   		reference could be obtained and that approval was subsequently denied
   		(see Section 2.4.7).
		
		If there are several REFERs in the same dialog, we need to
		match the ID of the event header...
		*/
		if (option_debug > 2)
			ast_log(LOG_DEBUG, "* SIP Transfer NOTIFY Attachment: \n---%s\n---\n", buf);
		cmd = ast_skip_blanks(buf);
		code = cmd;
		/* We are at SIP/2.0 */
		while(*code && (*code > 32)) {	/* Search white space */
			code++;
		}
		*code++ = '\0';
		code = ast_skip_blanks(code);
		sep = code;
		sep++;
		while(*sep && (*sep > 32)) {	/* Search white space */
			sep++;
		}
		*sep++ = '\0';			/* Response string */
		respcode = atoi(code);
		switch (respcode) {
		case 100:	/* Trying: */
			/* Don't do anything yet */
			break;
		case 183:	/* Ringing: */
			/* Don't do anything yet */
			break;
		case 200:	/* OK: The new call is up, hangup this call */
			/* Hangup the call that we are replacing */
			break;
		case 301: /* Moved permenantly */
		case 302: /* Moved temporarily */
			/* Do we get the header in the packet in this case? */
			success = FALSE;
			break;
		case 503:	/* Service Unavailable: The new call failed */
				/* Cancel transfer, continue the call */
			success = FALSE;
			break;
		case 603:	/* Declined: Not accepted */
				/* Cancel transfer, continue the current call */
			success = FALSE;
			break;
		}
		if (!success) {
			ast_log(LOG_NOTICE, "Transfer failed. Sorry. Nothing further to do with this call\n");
		}
		
		/* Confirm that we received this packet */
		transmit_response(p, "200 OK", req);
		return res;
	};
}

/*! \brief Handle incoming OPTIONS request */
static int handle_request_options(struct sip_dialog *p, struct sip_request *req)
{
	int res;

	res = get_destination(p, req);
	build_contact(p);
	/* XXX Should we authenticate OPTIONS? XXX */
	if (ast_strlen_zero(p->context))
		ast_string_field_set(p, context, global.default_context);
	if (res < 0)
		transmit_response_with_attachment(WITH_ALLOW, p, "404 Not Found", req, XMIT_UNRELIABLE);
	else 
		transmit_response_with_attachment(WITH_ALLOW, p, "200 OK", req, XMIT_UNRELIABLE);
	/* Destroy if this OPTIONS was the opening request, but not if
	   it's in the middle of a normal call flow. */
	if (!p->lastinvite)
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);

	return res;
}

/*! \brief Handle the transfer part of INVITE with a replaces: header, 
    meaning a target pickup or an attended transfer */
static int handle_invite_replaces(struct sip_dialog *p, struct sip_request *req, int debug, struct sockaddr_in *sin)
{
	struct ast_frame *f;
	int earlyreplace = 0;
	int oneleggedreplace = 0;		/* Call with no bridge, propably IVR or voice message */
	struct ast_channel *c = p->owner;	/* Our incoming call */
	struct ast_channel *replacecall = p->refer->refer_call->owner;	/* The channel we're about to take over */
	struct ast_channel *targetcall;		/* The bridge to the take-over target */

	/* Check if we're in ring state */
	if (replacecall->_state == AST_STATE_RING)
		earlyreplace = 1;

	/* Check if we have a bridge */
	if (!(targetcall = ast_bridged_channel(replacecall))) {
		/* We have no bridge */
		if (!earlyreplace) {
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "	Attended transfer attempted to replace call with no bridge (maybe ringing). Channel %s!\n", replacecall->name);
			oneleggedreplace = 1;
		}
	} 
	if (option_debug > 3 && targetcall && targetcall->_state == AST_STATE_RINGING)
			ast_log(LOG_DEBUG, "SIP transfer: Target channel is in ringing state\n");

	if (option_debug > 3) {
		if (targetcall) 
			ast_log(LOG_DEBUG, "SIP transfer: Invite Replace incoming channel should bridge to channel %s while hanging up channel %s\n", targetcall->name, replacecall->name); 
		else
			ast_log(LOG_DEBUG, "SIP transfer: Invite Replace incoming channel should replace and hang up channel %s (one call leg)\n", replacecall->name); 
	}

	if (ast_test_flag(req, SIP_PKT_IGNORE)) {
		ast_log(LOG_NOTICE, "Ignoring this INVITE with replaces in a stupid way.\n");
		/* We should answer something here. If we are here, the
			call we are replacing exists, so an accepted 
			can't harm */
		transmit_response_with_attachment(WITH_SDP, p, "200 OK", req, XMIT_RELIABLE);
		/* Do something more clever here */
		ast_channel_unlock(c);
		dialog_lock(p->refer->refer_call, FALSE);
		return 1;
	} 
	if (!c) {
		/* What to do if no channel ??? */
		ast_log(LOG_ERROR, "Unable to create new channel.  Invite/replace failed.\n");
		transmit_response_reliable(p, "503 Service Unavailable", req);
		append_history(p, "Xfer", "INVITE/Replace Failed. No new channel.");
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		dialog_lock(p->refer->refer_call, FALSE);
		return 1;
	}
	append_history(p, "Xfer", "INVITE/Replace received");
	/* We have three channels to play with
		channel c: New incoming call
		targetcall: Call from PBX to target
		p->refer->refer_call: SIP pvt dialog from transferer to pbx.
		replacecall: The owner of the previous
		We need to masq C into refer_call to connect to 
		targetcall;
		If we are talking to internal audio stream, target call is null.
	*/

	/* Fake call progress */
	transmit_response(p, "100 Trying", req);
	ast_setstate(c, AST_STATE_RING);

	/* Masquerade the new call into the referred call to connect to target call 
	   Targetcall is not touched by the masq */

	/* Answer the incoming call and set channel to UP state */
	transmit_response_with_attachment(WITH_SDP, p, "200 OK", req, XMIT_RELIABLE);
	ast_setstate(c, AST_STATE_UP);
	
	/* Stop music on hold and other generators */
	ast_quiet_chan(replacecall);
	ast_quiet_chan(targetcall);
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "Invite/Replaces: preparing to masquerade %s into %s\n", c->name, replacecall->name);
	/* Unlock clone, but not original (replacecall) */
	ast_channel_unlock(c);

	/* Unlock dialog */
	dialog_lock(p->refer->refer_call, FALSE);

	/* Make sure that the masq does not free our PVT for the old call */
	ast_set_flag(&p->refer->refer_call->flags[0], SIP_DEFER_BYE_ON_TRANSFER);	/* Delay hangup */
		
	/* Prepare the masquerade - if this does not happen, we will be gone */
	if(ast_channel_masquerade(replacecall, c))
		ast_log(LOG_ERROR, "Failed to masquerade C into Replacecall\n");
	else if (option_debug > 3)
		ast_log(LOG_DEBUG, "Invite/Replaces: Going to masquerade %s into %s\n", c->name, replacecall->name);

	/* The masquerade will happen as soon as someone reads a frame from the channel */

	/* C should now be in place of replacecall */
	/* ast_read needs to lock channel */
	ast_channel_unlock(c);
	
	if (earlyreplace || oneleggedreplace ) {
		/* Force the masq to happen */
		if ((f = ast_read(replacecall))) {	/* Force the masq to happen */
			ast_frfree(f);
			f = NULL;
			if (option_debug > 3)
				ast_log(LOG_DEBUG, "Invite/Replace:  Could successfully read frame from RING channel!\n");
		} else {
			ast_log(LOG_WARNING, "Invite/Replace:  Could not read frame from RING channel \n");
		}
		c->hangupcause = AST_CAUSE_SWITCH_CONGESTION;
		ast_channel_unlock(replacecall);
	} else {	/* Bridged call, UP channel */
		if ((f = ast_read(replacecall))) {	/* Force the masq to happen */
			/* Masq ok */
			ast_frfree(f);
			f = NULL;
			if (option_debug > 2)
				ast_log(LOG_DEBUG, "Invite/Replace:  Could successfully read frame from channel! Masq done.\n");
		} else {
			ast_log(LOG_WARNING, "Invite/Replace:  Could not read frame from channel. Transfer failed\n");
		}
		ast_channel_unlock(replacecall);
	}
	dialog_lock(p->refer->refer_call, FALSE);

	ast_setstate(c, AST_STATE_DOWN);
	if (option_debug > 3) {
		struct ast_channel *test;
		ast_log(LOG_DEBUG, "After transfer:----------------------------\n");
		ast_log(LOG_DEBUG, " -- C:        %s State %s\n", c->name, ast_state2str(c->_state));
		if (replacecall)
			ast_log(LOG_DEBUG, " -- replacecall:        %s State %s\n", replacecall->name, ast_state2str(replacecall->_state));
		if (p->owner) {
			ast_log(LOG_DEBUG, " -- P->owner: %s State %s\n", p->owner->name, ast_state2str(p->owner->_state));
			test = ast_bridged_channel(p->owner);
			if (test)
				ast_log(LOG_DEBUG, " -- Call bridged to P->owner: %s State %s\n", test->name, ast_state2str(test->_state));
			else
				ast_log(LOG_DEBUG, " -- No call bridged to C->owner \n");
		} else 
			ast_log(LOG_DEBUG, " -- No channel yet \n");
		ast_log(LOG_DEBUG, "End After transfer:----------------------------\n");
	}

	ast_channel_unlock(p->owner);	/* Unlock new owner */
	dialog_lock(p, FALSE);

	/* The call should be down with no ast_channel, so hang it up */
	c->tech_pvt = NULL;
	ast_hangup(c);
	return 0;
}


/*! \brief Handle incoming INVITE request
\note 	If the INVITE has a Replaces header, it is part of an
 *	attended transfer. If so, we do not go through the dial
 *	plan but tries to find the active call and masquerade
 *	into it 
 */
static int handle_request_invite(struct sip_dialog *p, struct sip_request *req, int debug, struct sockaddr_in *sin, int *recount, char *e)
{
	int res = 1;
	int gotdest;
	const char *p_replaces;
	char *replace_id = NULL;
	const char *required;
	unsigned int required_profile = 0;
	struct ast_channel *c = NULL;		/* New channel */
	int error = 0;

	/* Find out what they support */
	if (!p->sipoptions) {
		const char *supported = get_header(req, "Supported");
		if (!ast_strlen_zero(supported))
			parse_sip_options(p, supported);
	}

	/* Find out what they require */
	required = get_header(req, "Require");
	if (!ast_strlen_zero(required)) {
		required_profile = parse_sip_options(NULL, required);
		if (required_profile && required_profile != SIP_OPT_REPLACES) {
			/* At this point we only support REPLACES */
			transmit_response_with_unsupported(p, "420 Bad extension (unsupported)", req, required);
			ast_log(LOG_WARNING,"Received SIP INVITE with unsupported required extension: %s\n", required);
			error = 1;
		}
	}

	/* Check if this is a loop */
	if (!error && ast_test_flag(&p->flags[0], SIP_OUTGOING) && p->owner && (p->owner->_state != AST_STATE_UP)) {
		/* This is a call to ourself.  Send ourselves an error code and stop
	   	processing immediately, as SIP really has no good mechanism for
	   	being able to call yourself */
		/* we need to check the tags and the branch. If they're different, this is
	   	  in fact a forked call through a SIP proxy somewhere. */
		transmit_final_response(p, "482 Loop Detected", req, XMIT_RELIABLE);
		error = 1;
	}
	
	/* Check if we already have a pending invite. If so, then deny this one */
	if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->pendinginvite) {
		/* We already have a pending invite. Sorry. You are on hold. */
		transmit_response(p, "491 Request Pending", req);
		
		if (option_debug)
			ast_log(LOG_DEBUG, "Got INVITE on call where we already have pending INVITE, deferring that - %s\n", p->callid);
		/* No destruction here, we have a current dialog */
		return 0;
	}
	if (error) {
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		if (!p->lastinvite)
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		return 0;
	}

	p_replaces = get_header(req, "Replaces");

	if (!ast_strlen_zero(p_replaces)) {
		/* We have a replaces header */
		char *ptr;
		char *fromtag = NULL;
		char *totag = NULL;
		char *start, *to;

		if (p->owner) {
			if (option_debug > 2)
				ast_log(LOG_DEBUG, "INVITE w Replaces on existing call? Refusing action. [%s]\n", p->callid);
			transmit_response(p, "400 Bad request", req);	/* The best way to not not accept the transfer */
			/* Do not destroy existing call */
			return -1;
		}

		if (sipdebug && option_debug > 2)
			ast_log(LOG_DEBUG, "INVITE part of call transfer. Replaces [%s]\n", p_replaces);
		/* Create a buffer we can manipulate */
		replace_id = ast_strdupa(p_replaces);
		ast_uri_decode(replace_id);

		if (!p->refer && !sip_refer_allocate(p)) {
			append_history(p, "Xfer", "INVITE/Replace Failed. Out of memory.");
			transmit_final_response(p, "500 Server Internal Error", req, XMIT_RELIABLE);
			return -1;
		}

		/*  Todo: (When we find phones that support this)
			if the replaces header contains ";early-only"
			we can only replace the call in early
			stage, not after it's up.

			If it's not in early mode, 486 Busy.
		*/
		
		/* Skip leading whitespace */
		replace_id = ast_skip_blanks(replace_id);

		start = replace_id;
		while ( (ptr = strsep(&start, ";")) ) {
			ptr = ast_skip_blanks(ptr); /* XXX maybe unnecessary ? */
			if ( (to = strcasestr(ptr, "to-tag=") ) )
				totag = to + 7;	/* skip the keyword */
			else if ( (to = strcasestr(ptr, "from-tag=") ) ) {
				fromtag = to + 9;	/* skip the keyword */
				fromtag = strsep(&fromtag, "&"); /* trim what ? */
			}
		}

		if (sipdebug && option_debug > 3) 
			ast_log(LOG_DEBUG,"Invite/replaces: Will use Replace-Call-ID : %s Fromtag: %s Totag: %s\n", replace_id, fromtag ? fromtag : "<no from tag>", totag ? totag : "<no to tag>");


		/* Try to find call that we are replacing 
			If we have a Replaces  header, we need to cancel that call if we succeed with this call 
		*/
		if ((p->refer->refer_call = get_sip_dialog_byid_locked(replace_id, totag, fromtag)) == NULL) {
			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-existent call id (%s)!\n", replace_id);
			transmit_final_response(p, "481 Call leg Does not exit (Replaces)", req, XMIT_RELIABLE);
			error = 1;
		}

		/* At this point, bot the pvt and the owner of the call to be replaced is locked */

		/* The matched call is the call from the transferer to Asterisk .
			We want to bridge the bridged part of the call to the 
			incoming invite, thus taking over the refered call */

		if (p->refer->refer_call == p) {
			ast_log(LOG_NOTICE, "INVITE with replaces into it's own call id (%s == %s)!\n", replace_id, p->callid);
			p->refer->refer_call = NULL;
			transmit_final_response(p, "400 Bad request", req, XMIT_RELIABLE);
			error = 1;
		}

		if (!error && !p->refer->refer_call->owner) {
			/* Oops, someting wrong anyway, no owner, no call */
			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-existing call id (%s)!\n", replace_id);
			/* Check for better return code */
			transmit_final_response(p, "481 Call leg Does not exit (Replaces)", req, XMIT_RELIABLE);
			error = 1;
		}

		if (!error && p->refer->refer_call->owner->_state != AST_STATE_RING && p->refer->refer_call->owner->_state != AST_STATE_UP ) {
			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-ringing or active call id (%s)!\n", replace_id);
			transmit_final_response(p, "603 Declined (Replaces)", req, XMIT_RELIABLE);
			error = 1;
		}

		if (error) {	/* Give up this dialog */
			append_history(p, "Xfer", "INVITE/Replace Failed.");
			dialog_lock(p, FALSE);
			if (p->refer->refer_call) {
				dialog_lock(p->refer->refer_call, FALSE);
				ast_channel_unlock(p->refer->refer_call->owner);
			}
			return -1;
		}
	}


	/* Check if this is an INVITE that sets up a new dialog or
	   a re-invite in an existing dialog */

	if (!ast_test_flag(req, SIP_PKT_IGNORE)) {
		sip_cancel_destroy(p);
		/* This also counts as a pending invite */
		p->pendinginvite = req->seqno;
		check_via(p, req);

		if (!p->owner) {	/* Not a re-invite */
			/* Use this as the basis */
			set_initreq(p, req);
			if (debug)
				ast_verbose("Using INVITE request as basis request - %s\n", p->callid);
			append_history(p, "Invite", "New call: %s", p->callid);
			parse_ok_contact(p, req);
		} else {	/* Re-invite on existing call */
			/* Handle SDP here if we already have an owner */
			if (find_sdp(req)) {
				if (process_sdp(p, req)) {
					transmit_response(p, "488 Not acceptable here", req);
					if (!p->lastinvite)
						sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
					return -1;
				}
			} else {
				p->jointcapability = p->capability;
				if (option_debug)
					ast_log(LOG_DEBUG, "Hm....  No sdp for the moment\n");
			}
			if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY)) /* This is a response, note what it was for */
				append_history(p, "ReInv", "Re-invite received");
		}
	} else if (debug)
		ast_verbose("Ignoring this INVITE request\n");

	
	if (!p->lastinvite && !ast_test_flag(req, SIP_PKT_IGNORE) && !p->owner) {
		/* This is a new invite */
		/* Handle authentication if this is our first invite */
		res = check_user(p, req, SIP_INVITE, e, XMIT_RELIABLE, sin);
		if (res == AUTH_CHALLENGE_SENT)
			return 0; 
		if (res < 0) { /* Something failed in authentication */
			if (res == AUTH_FAKE_AUTH) {
				ast_log(LOG_NOTICE, "Sending fake auth rejection for user %s\n", get_header(req, "From"));
				transmit_fake_auth_response(p, req, 1);
			} else {
  				ast_log(LOG_NOTICE, "Failed to authenticate user %s\n", get_header(req, "From"));
				transmit_response_reliable(p, "403 Forbidden", req);
  			}
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			ast_string_field_free(p, theirtag);
			return 0;
		}

		/* We have a succesful authentication, process the SDP portion if there is one */
		if (find_sdp(req)) {
			if (process_sdp(p, req)) {
				/* Unacceptable codecs */
				transmit_final_response(p, "488 Not acceptable here", req, XMIT_RELIABLE);
				if (option_debug)
					ast_log(LOG_DEBUG, "No compatible codecs for this SIP call.\n");
				return -1;
			}
		} else {	/* No SDP in invite, call control session */
			p->jointcapability = p->capability;
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "No SDP in Invite, third party call control\n");
		}

		/* Initialize the context if it hasn't been already */
		if (ast_strlen_zero(p->context))
			ast_string_field_set(p, context, global.default_context);


		/* Check number of concurrent calls -vs- incoming limit HERE */
		if (option_debug)
			ast_log(LOG_DEBUG, "Checking SIP call limits for device %s\n", p->peername);
		if ((res = update_call_counter(p, INC_CALL_LIMIT))) {
			if (res < 0) {
				ast_log(LOG_NOTICE, "Failed to place call for user %s, too many calls\n", p->peername);
				transmit_final_response(p, "480 Temporarily Unavailable", req, XMIT_RELIABLE);
			}
			return 0;
		}
		gotdest = get_destination(p, NULL);	/* Get destination right away */
		get_rdnis(p, NULL);			/* Get redirect information */
		extract_uri(p, req);			/* Get the Contact URI */
		build_contact(p);			/* Build our contact header */
		if (p->rtp) {
			ast_rtp_setdtmf(p->rtp, ast_test_flag(&p->flags[0], SIP_DTMF) != SIP_DTMF_INFO);
			ast_rtp_setdtmfcompensate(p->rtp, ast_test_flag(&p->flags[1], SIP_PAGE2_RFC2833_COMPENSATE));
		}

		if (!replace_id && gotdest) {	/* No matching extension found */
			char *response;
			if (gotdest == 1 && ast_test_flag(&p->flags[1], SIP_PAGE2_ALLOWOVERLAP))
				response = "484 Address Incomplete";
			else
				response = "404 Not Found";
			transmit_final_response(p, response, req, XMIT_RELIABLE);
			update_call_counter(p, DEC_CALL_LIMIT);
			return 0;
		} else {
			/* If no extension was specified, use the s one */
			/* Basically for calling to IP/Host name only */
			if (ast_strlen_zero(p->exten))
				ast_string_field_set(p, exten, "s");
			/* Initialize our tag */	

			make_our_tag(p->tag, sizeof(p->tag));

			/* First invitation - create the channel */
			c = sip_new(p, AST_STATE_DOWN, S_OR(p->peername, NULL));
			*recount = 1;

			/* Save Record-Route for any later requests we make on this dialogue */
			build_route(p, req, 0);

			if (c) /* Pre-lock the call */
				ast_channel_lock(c);
		}
	} else {
		if (option_debug > 1 && sipdebug) {
			if (!ast_test_flag(req, SIP_PKT_IGNORE))
				ast_log(LOG_DEBUG, "Got a SIP re-invite for call %s\n", p->callid);
			else
				ast_log(LOG_DEBUG, "Got a SIP re-transmit of INVITE for call %s\n", p->callid);
		}
		c = p->owner;
	}

	if (!ast_test_flag(req, SIP_PKT_IGNORE) && p)
		p->lastinvite = req->seqno;

	if (replace_id) { 	/* Attended transfer or call pickup - we're the target */
		/* Go and take over the target call */
		if (sipdebug && option_debug > 3)
			ast_log(LOG_DEBUG, "Sending this call to the invite/replcaes handler %s\n", p->callid);
		return handle_invite_replaces(p, req, debug, sin);
	}


	if (c) {	/* We have a call  -either a new call or an old one (RE-INVITE) */
		switch(c->_state) {
		case AST_STATE_DOWN:
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "%s: New call is still down.... Trying... \n", c->name);
			transmit_response(p, "100 Trying", req);
			ast_setstate(c, AST_STATE_RING);
			if (strcmp(p->exten, ast_pickup_ext())) {	/* Call to extension -start pbx on this call */
				enum ast_pbx_result res;
				const char *response = NULL;

				res = ast_pbx_start(c);

				switch(res) {
				case AST_PBX_FAILED:
					ast_log(LOG_WARNING, "Failed to start PBX :(\n");
					response = "503 Unavailable";
					break;
				case AST_PBX_CALL_LIMIT:
					ast_log(LOG_WARNING, "Failed to start PBX (call limit reached) \n");
					response = "480 Temporarily Unavailable";
					break;
				case AST_PBX_SUCCESS:
					/* nothing to do */
					break;
				}
				if (response)
					transmit_final_response(p, response, req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);

				if (res) {
					/* Unlock locks so ast_hangup can do its magic */
					ast_channel_unlock(c);
					dialog_lock(p, FALSE);
					ast_hangup(c);
					dialog_lock(p, TRUE);
					c = NULL;
				}
			} else {	/* Pickup call in call group */
				ast_channel_unlock(c);
				if (ast_pickup_call(c)) {
					ast_log(LOG_NOTICE, "Nothing to pick up for %s\n", p->callid);
					transmit_final_response(p, "503 Unavailable", req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);
					ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
					/* Unlock locks so ast_hangup can do its magic */
					dialog_lock(p, FALSE);
					c->hangupcause = AST_CAUSE_CALL_REJECTED;
				} else {
					dialog_lock(p, FALSE);
					ast_setstate(c, AST_STATE_DOWN);
					c->hangupcause = AST_CAUSE_NORMAL_CLEARING;
				}
				ast_hangup(c);
				dialog_lock(p, TRUE);
				c = NULL;
			}
			break;
		case AST_STATE_RING:
			transmit_response(p, "100 Trying", req);
			if (!p->owner)
				dialogstatechange(p, DIALOG_STATE_PROCEEDING);
			break;
		case AST_STATE_RINGING:
			transmit_response(p, "180 Ringing", req);
			if (!p->owner)
				dialogstatechange(p, DIALOG_STATE_EARLY);
			break;
		case AST_STATE_UP:
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "%s: This call is UP.... \n", c->name);

			if (p->t38.state == T38_PEER_REINVITE) {
				struct ast_channel *bridgepeer = NULL;
				struct sip_dialog *bridge_dialog = NULL;
				
				if ((bridgepeer = ast_bridged_channel(p->owner))) {
					/* We have a bridge, and this is re-invite to switchover to T38 so we send re-invite with T38 SDP, to other side of bridge*/
					/*! XXX: we should also check here does the other side supports t38 at all !!! XXX */
					if (!strcasecmp(bridgepeer->tech->type, "SIP")) { /* If we are bridged to SIP channel */
						bridge_dialog = (struct sip_dialog*)bridgepeer->tech_pvt;
						if (bridge_dialog->t38.state == T38_DISABLED) {
							if (bridge_dialog->udptl) { /* If everything is OK with other side's udptl struct */
								/* Send re-invite to the bridged channel */
								sip_handle_t38_reinvite(bridgepeer, p, 1);
							} else { /* Something is wrong with peers udptl struct */
								ast_log(LOG_WARNING, "Strange... The other side of the bridge don't have udptl struct\n");
								dialog_lock(bridge_dialog, TRUE);
								bridge_dialog->t38.state = T38_DISABLED;
								dialog_lock(bridge_dialog, FALSE);
								if (option_debug > 1)
									ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", bridge_dialog->t38.state, bridgepeer->name);
								transmit_final_response(p, "488 Not Acceptable here", req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);
							}
						} else {
							/* The other side is already setup for T.38 most likely so we need to acknowledge this too */
							transmit_response_with_attachment(WITH_T38_SDP, p, "200 OK", req, XMIT_CRITICAL);
							dialogstatechange(p, DIALOG_STATE_CONFIRMED);
							p->t38.state = T38_ENABLED;
							if (option_debug)
								ast_log(LOG_DEBUG, "T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
						}
					} else {
						/* Other side is not a SIP channel */
						transmit_final_response(p, "488 Not Acceptable here", req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);
						p->t38.state = T38_DISABLED;
						if (option_debug > 1)
							ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
					}
				} else {
					/* we are not bridged in a call */
					transmit_response_with_attachment(WITH_T38_SDP, p, "200 OK", req, XMIT_CRITICAL);
					dialogstatechange(p, DIALOG_STATE_CONFIRMED);
					p->t38.state = T38_ENABLED;
					if (option_debug)
						ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
				}
			} else if (p->t38.state == T38_DISABLED) { /* Channel doesn't have T38 offered or enabled */
				int sendok = TRUE;

				/* If we are bridged to a channel that has T38 enabled than this is a case of RTP re-invite after T38 session */
				/* so handle it here (re-invite other party to RTP) */
				struct ast_channel *bridgepeer = NULL;
				struct sip_dialog *bridge_dialog = NULL;
				if ((bridgepeer = ast_bridged_channel(p->owner))) {
					if (bridgepeer->tech == &sip_tech || bridgepeer->tech == &sip_tech_info) {
						bridge_dialog = (struct sip_dialog*)bridgepeer->tech_pvt;
						/* Does the bridged peer have T38 ? */
						if (bridge_dialog->t38.state == T38_ENABLED) {
							ast_log(LOG_WARNING, "RTP re-invite after T38 session not handled yet !\n");
							/* Insted of this we should somehow re-invite the other side of the bridge to RTP */
							transmit_final_response(p, "488 Not Acceptable here (unsupported)", req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);
							sendok = FALSE;
						} 
						/* No bridged peer with T38 enabled*/
					}
				} 

				/* This is a normal call and we can accept it - let's rock and roll! */
				if (sendok)
					transmit_response_with_attachment(WITH_SDP, p, "200 OK", req, XMIT_CRITICAL);
				dialogstatechange(p, DIALOG_STATE_CONFIRMED);

			}
			break;
		default:
			ast_log(LOG_WARNING, "Don't know how to handle INVITE in state %d\n", c->_state);
			transmit_response(p, "100 Trying", req);
			break;
		}
	} else {
		if (p && (p->autokillid == -1)) {
			const char *msg;

			if (!p->jointcapability)
				msg = "488 Not Acceptable Here (codec error)";
			else {
				ast_log(LOG_NOTICE, "Unable to create/find SIP channel for this INVITE\n");
				msg = "503 Unavailable";
			}
			transmit_final_response(p, msg, req, ast_test_flag(req, SIP_PKT_IGNORE) ? XMIT_UNRELIABLE : XMIT_RELIABLE);
		}
	}
	return res;
}

/*! \brief Handle incoming CANCEL request */
static int handle_request_cancel(struct sip_dialog *p, struct sip_request *req)
{
		
	check_via(p, req);
	ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
	
	if (p->owner && p->owner->_state == AST_STATE_UP) {
		/* This call is up, cancel is ignored, we need a bye */
		transmit_response(p, "200 OK", req);
		if (option_debug)
			ast_log(LOG_DEBUG, "Got CANCEL on an answered call. Ignoring... \n");
		return 0;
	}
	stop_media_flows(p);
	if (p->owner)
		ast_queue_hangup(p->owner);
	else
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
	if (p->initreq) {
		transmit_response_reliable(p, "487 Request Terminated", p->initreq);
		transmit_response(p, "200 OK", req);
		return 1;
	} else {
		transmit_response(p, "481 Call Leg Does Not Exist", req);
		return 0;
	}
}

/*! \brief Handle incoming BYE request */
static int handle_request_bye(struct sip_dialog *p, struct sip_request *req)
{
	struct ast_channel *c=NULL;
	int res;
	struct ast_channel *bridged_to;
	char *audioqos = NULL, *videoqos = NULL;
	
	if (p->pendinginvite && !ast_test_flag(&p->flags[0], SIP_OUTGOING) && !ast_test_flag(req, SIP_PKT_IGNORE))
		transmit_response_reliable(p, "487 Request Terminated", p->initreq);

	set_initreq(p, req);
	check_via(p, req);
	ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	

	if (p->rtp) {
		audioqos = ast_rtp_get_quality(p->rtp);
		if (p->owner)
			pbx_builtin_setvar_helper(p->owner, "RTPAUDIOQOS", audioqos);
	}
	if (p->vrtp) {
		videoqos = ast_rtp_get_quality(p->vrtp);
		if (p->owner)
			pbx_builtin_setvar_helper(p->owner, "RTPVIDEOQOS", videoqos);
	}

	/* Get RTCP quality before end of call */
	if (!ast_test_flag(&p->flags[0], SIP_NO_HISTORY) || p->owner) {
		if (p->rtp)
			append_history(p, "RTCPaudio", "Quality:%s", audioqos);
		if (p->vrtp)
			append_history(p, "RTCPvideo", "Quality:%s", videoqos);
	}

	stop_media_flows(p);
	if (!ast_strlen_zero(get_header(req, "Also"))) {
		ast_log(LOG_NOTICE, "Client '%s' using deprecated BYE/Also transfer method.  Ask vendor to support REFER instead\n",
			ast_inet_ntoa(p->recv.sin_addr));
		if (ast_strlen_zero(p->context))
			ast_string_field_set(p, context, global.default_context);
		res = get_also_info(p, req);
		if (!res) {
			c = p->owner;
			if (c) {
				bridged_to = ast_bridged_channel(c);
				if (bridged_to) {
					/* Don't actually hangup here... */
					ast_queue_control(c, AST_CONTROL_UNHOLD);
					ast_async_goto(bridged_to, p->context, p->refer->refer_to,1);
				} else
					ast_queue_hangup(p->owner);
			}
		} else {
			ast_log(LOG_WARNING, "Invalid transfer information from '%s'\n", ast_inet_ntoa(p->recv.sin_addr));
			if (p->owner)
				ast_queue_hangup(p->owner);
		}
	} else if (p->owner) {
		ast_queue_hangup(p->owner);
		if (option_debug > 2)
			ast_log(LOG_DEBUG, "Received bye, issuing owner hangup\n");
	} else {
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		if (option_debug > 2)
			ast_log(LOG_DEBUG, "Received bye, no owner, selfdestruct soon.\n");
	}
	transmit_response(p, "200 OK", req);

	return 1;
}

/*! \brief Handle incoming MESSAGE request */
static int handle_request_message(struct sip_dialog *p, struct sip_request *req)
{
	if (!ast_test_flag(req, SIP_PKT_IGNORE)) {
		if (ast_test_flag(req, SIP_PKT_DEBUG))
			ast_verbose("Receiving message!\n");
		receive_message(p, req);
	} else
		transmit_final_response(p, "202 Accepted", req, XMIT_UNRELIABLE);
	return 1;
}

/*! \brief  Handle incoming SUBSCRIBE request */
static int handle_request_subscribe(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e)
{
	int gotdest;
	int res = 0;
	int firststate = AST_EXTENSION_REMOVED;
	struct sip_device *authpeer = NULL;
	const char *event = get_header(req, "Event");	/* Get Event package name */
	const char *accept = get_header(req, "Accept");
	int resubscribe = (p->subscribed != NONE);
	static int subscribe_counter = 0;

	if (p->initreq) {	
		/* We already have a dialog */
		if (p->initreq->method != SIP_SUBSCRIBE) {
			/* This is a SUBSCRIBE within another SIP dialog, which we do not support */
			/* For transfers, this could happen, but since we haven't seen it happening, let us just refuse this */
 			transmit_response(p, "403 Forbidden (within dialog)", req);
			/* Do not destroy session, since we will break the call if we do */
			if (option_debug)
				ast_log(LOG_DEBUG, "Got a subscription within the context of another call, can't handle that - %s (Method %s)\n", p->callid, sip_method2txt(p->initreq->method));
			return 0;
		} else if (ast_test_flag(req, SIP_PKT_DEBUG)) {
			if (option_debug) {
				if (resubscribe)
					ast_log(LOG_DEBUG, "Got a re-subscribe on existing subscription %s\n", p->callid);
				else
					ast_log(LOG_DEBUG, "Got a new subscription %s (possibly with auth)\n", p->callid);
			}
		}
	}

	/* Check if we have a global disallow setting on subscriptions. 
		if so, we don't have to check peer/user settings after auth, which saves a lot of processing
	*/
	if (!global.allowsubscribe) {
		transmit_final_response(p, "403 Forbidden (policy)", req, XMIT_UNRELIABLE);
		return 0;
	}
	subscribe_counter ++;
	if (option_debug > 2)
		ast_log(LOG_DEBUG, "-SUBSCRIPTIONS- Concurrent counter: %d\n", subscribe_counter);


	if (!ast_test_flag(req, SIP_PKT_IGNORE) && !p->initreq) {	/* Set up dialog, new subscription */
		/* Use this as the basis */
		if (ast_test_flag(req, SIP_PKT_DEBUG))
			ast_verbose("Creating new subscription\n");

		/* This call is no longer outgoing if it ever was */
		ast_clear_flag(&p->flags[0], SIP_OUTGOING);
		set_initreq(p, req);
		check_via(p, req);
	} else if (ast_test_flag(req, SIP_PKT_DEBUG) && ast_test_flag(req, SIP_PKT_IGNORE))
		ast_verbose("Ignoring this SUBSCRIBE request\n");

	/* Find parameters to Event: header value and remove them for now */
	event = strsep((char **)&event, ";");	/* XXX bug here, overwrite string */

	/* Handle authentication if this is our first subscribe */
	res = check_user_full(p, req, SIP_SUBSCRIBE, e, 0, sin, &authpeer);
	/* if an authentication response was sent, we are done here */
	if (res == AUTH_CHALLENGE_SENT) {
		device_unref(authpeer);
		subscribe_counter--;
		return 0;
	}
	if (res < 0) {
		if (res == AUTH_FAKE_AUTH) {
			ast_log(LOG_NOTICE, "Sending fake auth rejection for user %s\n", get_header(req, "From"));
			transmit_fake_auth_response(p, req, 1);
		} else {
			ast_log(LOG_NOTICE, "Failed to authenticate user %s for SUBSCRIBE\n", get_header(req, "From"));
			transmit_final_response(p, "403 Forbidden", req, XMIT_UNRELIABLE);
		}
		device_unref(authpeer);
		subscribe_counter--;
		return 0;
	}

	/* Check if this user/peer is allowed to subscribe at all */
	if (!ast_test_flag(&p->flags[1], SIP_PAGE2_ALLOWSUBSCRIBE)) {
		transmit_final_response(p, "403 Forbidden (policy)", req, XMIT_UNRELIABLE);
		device_unref(authpeer);
		subscribe_counter--;
		return 0;
	}

	/* Get destination right away */
	gotdest = get_destination(p, NULL);

	/* Initialize the context if it hasn't been already;
	   note this is done _after_ handling any domain lookups,
	   because the context specified there is for calls, not
	   subscriptions
	*/
	if (!ast_strlen_zero(p->subscribecontext))
		ast_string_field_set(p, context, p->subscribecontext);
	else if (ast_strlen_zero(p->context))
		ast_string_field_set(p, context, global.default_context);

	build_contact(p);
	if (gotdest) {
		transmit_final_response(p, "404 Not Found", req, XMIT_UNRELIABLE);
		device_unref(authpeer);
		subscribe_counter--;
		return 0;
	} else {
		/* XXX reduce nesting here */
		/* Initialize tag for new subscriptions */	
		if (ast_strlen_zero(p->tag))
			make_our_tag(p->tag, sizeof(p->tag));

		if (!strcmp(event, "presence") || !strcmp(event, "dialog")) { /* Presence, RFC 3842 */
			device_unref(authpeer);

			/* Header from Xten Eye-beam Accept: multipart/related, application/rlmi+xml, application/pidf+xml, application/xpidf+xml */
			/* Polycom phones only handle xpidf+xml, even if they say they can
			   handle pidf+xml as well
			*/
			if (strstr(p->useragent, "Polycom")) {
				p->subscribed = XPIDF_XML;
			} else if (strstr(accept, "application/pidf+xml")) {
 				p->subscribed = PIDF_XML;         /* RFC 3863 format */
 			} else if (strstr(accept, "application/dialog-info+xml")) {
 				p->subscribed = DIALOG_INFO_XML;
 				/* IETF draft: draft-ietf-sipping-dialog-package-05.txt */
 			} else if (strstr(accept, "application/cpim-pidf+xml")) {
 				p->subscribed = CPIM_PIDF_XML;    /* RFC 3863 format */
 			} else if (strstr(accept, "application/xpidf+xml")) {
 				p->subscribed = XPIDF_XML;        /* Early pre-RFC 3863 format with MSN additions (Microsoft Messenger) */
			} else {
 				/* Can't find a format for events that we know about */
				transmit_final_response(p, "489 Bad Event", req, XMIT_UNRELIABLE);
				subscribe_counter--;
 				return 0;
 			}
 		} else if (!strcmp(event, "message-summary")) { 
			char *resp = NULL;
			int error = FALSE;
			if (!ast_strlen_zero(accept) && strcmp(accept, "application/simple-message-summary")) {
				/* Format requested that we do not support */
				resp = "406 Not acceptable";
				if (option_debug > 1)
					ast_log(LOG_DEBUG, "Received SIP mailbox subscription for unknown format: %s\n", accept);
			}
			/* Looks like they actually want a mailbox status 
			  This version of Asterisk supports mailbox subscriptions
			  The subscribed URI needs to exist in the dial plan
			  In most devices, this is configurable to the voicemailmain extension you use
			*/
			if (!authpeer || ast_strlen_zero(authpeer->mailbox.mailbox)) {
				resp = "404 Not found (no mailbox)";
				ast_log(LOG_NOTICE, "Received SIP subscribe for peer without mailbox: %s\n", authpeer ? authpeer->name : "<no peername>");
				return 0;
			}
			if (error) {
				transmit_final_response(p, resp, req, XMIT_UNRELIABLE);
				device_unref(authpeer);
				subscribe_counter--;
				return 0;
			}

 			p->subscribed = MWI_NOTIFICATION;
			if (authpeer->mailbox.mwipvt && authpeer->mailbox.mwipvt != p)	/* Destroy old PVT if this is a new one */
				/* We only allow one subscription per peer */
				sip_destroy(authpeer->mailbox.mwipvt);
			authpeer->mailbox.mwipvt = p;		/* Link from peer to pvt */
			p->relatedpeer = authpeer;	/* Link from pvt to peer */
		} else { /* At this point, Asterisk does not understand the specified event */
			transmit_final_response(p, "489 Bad Event", req, XMIT_UNRELIABLE);
			if (option_debug > 1)
				ast_log(LOG_DEBUG, "Received SIP subscribe for unknown event package: %s\n", event);
			device_unref(authpeer);
			subscribe_counter--;
			return 0;
		}
		/* Now, subscribe to status events from the PBX core */
		if (p->subscribed != MWI_NOTIFICATION && !resubscribe)
			p->stateid = ast_extension_state_add(p->context, p->exten, cb_extensionstate, p);
	}

	if (!ast_test_flag(req, SIP_PKT_IGNORE) && p)
		p->lastinvite = req->seqno;

	p->expiry = atoi(get_header(req, "Expires"));
	ast_log(LOG_DEBUG, "=== Requested expiry %d\n", p->expiry);
	if (p->expiry < expiry.min_expiry && p->expiry > 0) {
		transmit_response_with_attachment(WITH_MINEXPIRY, p, "423 Interval too small", req, XMIT_UNRELIABLE);
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		subscribe_counter--;
		return 0;
	}
	

	/* SKREP check dialog state instead of NEEDDESTROY */
	if (p && p->state < DIALOG_STATE_TERMINATED) {
	// if (p && !ast_test_flag(&p->flags[0], SIP_NEEDDESTROY)) {

		/* check if the requested expiry-time is within the approved limits from sip.conf */
		if (p->expiry > expiry.max_expiry)
			p->expiry = expiry.max_expiry;

		if (sipdebug || option_debug > 1) {
			if (p->subscribed == MWI_NOTIFICATION && p->relatedpeer)
				ast_log(LOG_DEBUG, "Adding subscription for mailbox notification - peer %s Mailbox %s\n", p->relatedpeer->name, p->relatedpeer->mailbox.mailbox);
			else
				ast_log(LOG_DEBUG, "Adding subscription for extension %s context %s for peer %s\n", p->exten, p->context, p->peername);
		}
		if (p->autokillid > -1)
			sip_cancel_destroy(p);	/* Remove subscription expiry for renewals */
		if (p->expiry > 0)
			sip_scheddestroy(p, (p->expiry + 10) * 1000);	/* Set timer for destruction of call at expiration */

		if (p->subscribed == MWI_NOTIFICATION) {
			transmit_response(p, "200 OK", req);
			if (p->relatedpeer) {	/* Send first notification */
				ASTOBJ_WRLOCK(p->relatedpeer);
				sip_send_mwi_to_peer(p->relatedpeer);
				ASTOBJ_UNLOCK(p->relatedpeer);
			}
		} else {
			if ((firststate = ast_extension_state(NULL, p->context, p->exten)) < 0) {

				ast_log(LOG_ERROR, "Got SUBSCRIBE for extension %s@%s from %s, but there is no hint for that extension\n", p->exten, p->context, ast_inet_ntoa(p->sa.sin_addr));
				transmit_final_response(p, "404 Not Found", req, XMIT_UNRELIABLE);
				subscribe_counter--;
				return 0;
			} 
			struct sip_dialog *p_old;

			transmit_response(p, "200 OK", req);
			dialogstatechange(p, DIALOG_STATE_CONFIRMED);
			transmit_state_notify(p, firststate, 1, FALSE);	/* Send first notification */
			append_history(p, "Subscribestatus", "%s", ast_extension_state2str(firststate));
			/* hide the 'complete' exten/context in the refer_to field for later display */
			ast_string_field_build(p, subscribeuri, "%s@%s", p->exten, p->context);

			/* remove any old subscription from this peer for the same exten/context,
		   	as the peer has obviously forgotten about it and it's wasteful to wait
		   	for it to expire and send NOTIFY messages to the peer only to have them
		   	ignored (or generate errors)
			*/
			dialoglist_lock();
			for (p_old = dialoglist; p_old; p_old = p_old->next) {
				if (p_old == p)
					continue;
				if (p_old->initreq && p_old->initreq->method != SIP_SUBSCRIBE)
					continue;
				if (p_old->subscribed == NONE)
					continue;
				dialog_lock(p_old, TRUE);
				if (!strcmp(p_old->peername, p->peername)) {
					if (!strcmp(p_old->exten, p->exten) &&
					    !strcmp(p_old->context, p->context)) {
						ast_set_flag(&p_old->flags[0], SIP_NEEDDESTROY);
						dialog_lock(p_old, FALSE);
						break;
					}
				}
				dialog_lock(p_old, FALSE);
			}
			dialoglist_unlock();
		}
		if (!p->expiry)
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
	}
	subscribe_counter--;
	return 1;
}

/*! \brief Handle incoming REGISTER request */
static int handle_request_register(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, char *e)
{
	enum check_auth_result res;

	static int register_counter = 0;

	register_counter++;
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "-REGISTRATIONS- register counter %d\n", register_counter);

	/* Use this as the basis */
	if (ast_test_flag(req, SIP_PKT_DEBUG))
		ast_verbose("Using latest REGISTER request as basis request\n");
	set_initreq(p, req);
	check_via(p, req);
	if ((res = register_verify(p, sin, req, e)) < 0) {
		const char *reason = "";

		switch (res) {
		case AUTH_SECRET_FAILED:
			reason = "Wrong password";
			break;
		case AUTH_USERNAME_MISMATCH:
			reason = "Username/auth name mismatch";
			break;
		case AUTH_NOT_FOUND:
			reason = "No matching peer found";
			break;
		case AUTH_UNKNOWN_DOMAIN:
			reason = "Not a local domain";
			break;
		default:
			break;
		}
		ast_log(LOG_NOTICE, "Registration from '%s' failed for '%s' - %s\n",
			get_header(req, "To"), ast_inet_ntoa(sin->sin_addr),
			reason);
	}
	if (res < 1) {
		/* Destroy the session, but keep us around for just a bit in case they don't
		   get our 200 OK */
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
	}
	append_history(p, "RegRequest", "%s : Account %s", res ? "Failed": "Succeeded", get_header(req, "To"));
	register_counter--;
	return res;
}

/*! \brief Handle incoming SIP requests (methods) 
\note	This is where all incoming requests go first   */
/* called with p and p->owner locked */
GNURK int handle_request(struct sip_dialog *p, struct sip_request *req, struct sockaddr_in *sin, int *recount, int *nounlock)
{
	/* Called with p->lock held, as well as p->owner->lock if appropriate, keeping things
	   relatively static */
	//struct sip_request resp;
	const char *cmd;
	const char *cseq;
	const char *useragent;
	int len;
	int respid;
	int res = 0;
	int debug = sip_debug_test_pvt(p);
	char *e;
	int error = 0;

	/* Clear out potential response */
	//memset(&resp, 0, sizeof(resp));

	/* Get Method and Cseq */
	cseq = req->cseqheader;
	cmd = req->header[0];

	/* Must have Cseq */
	if (ast_strlen_zero(cmd) || ast_strlen_zero(cseq)) {
		ast_log(LOG_ERROR, "Missing Cseq. Dropping this SIP message, it's incomplete.\n");
		error = 1;
	} else {
		int seqno;
		/* Can we do this earlier in parse_request? */
		if (!error && sscanf(cseq, "%d%n", &seqno, &len) != 1) {
			ast_log(LOG_ERROR, "No seqno in '%s'. Dropping incomplete message.\n", cmd);
			error = 1;
		}
		req->seqno = seqno;
	}

	if (error) {
		if (!p->initreq)	/* New call */
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	/* Make sure we destroy this dialog */
		return -1;
	}

	/* Get the command XXX */

	cmd = req->rlPart1;
	e = req->rlPart2;

	/* Save useragent of the client */
	useragent = get_header(req, "User-Agent");
	if (!ast_strlen_zero(useragent))
		ast_string_field_set(p, useragent, useragent);

	/* Find out SIP method for incoming request */
	if (req->method == SIP_RESPONSE) {	/* Response to our request */
		/* Response to our request -- Do some sanity checks */	
		if (!p->initreq) {
			if (option_debug)
				ast_log(LOG_DEBUG, "That's odd...  Got a response on a call we dont know about. Cseq %d Cmd %s\n", req->seqno, cmd);
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
			return 0;
		} else if (p->ocseq < req->seqno) {
			if (option_debug)
				ast_log(LOG_DEBUG, "Ignoring out of order response %d (expecting %d)\n", req->seqno, p->ocseq);
			return -1;
		} else if (p->ocseq != req->seqno) {
			/* ignore means "don't do anything with it" but still have to 
			   respond appropriately  
				In fact, it really means that we have to resend the response
				but in this version of chan_sip we haven't got it in memory...
			*/
			ast_set_flag(req, SIP_PKT_IGNORE);
			ast_set_flag(req, SIP_PKT_IGNORE_RESP);
			append_history(p, "Ignore", "Ignoring this retransmit\n");
		}
	
		e = ast_skip_blanks(e);
		if (sscanf(e, "%d %n", &respid, &len) != 1) {
			ast_log(LOG_WARNING, "Invalid response: '%s'\n", e);
		} else {
			/* More SIP ridiculousness, we have to ignore bogus contacts in 100 etc responses */
			if ((respid == 200) || ((respid >= 300) && (respid <= 399)))
				extract_uri(p, req);
			handle_response(p, respid, e + len, req);
		}
		return 0;
	}

	/* New SIP request coming in 
	   (could be new request in existing SIP dialog as well...) 
	 */			
	
	p->method = req->method;	/* Find out which SIP method they are using */
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "**** Received %s - Command in SIP %s\n", sip_method2txt(p->method), cmd); 

	if (p->icseq && (p->icseq > req->seqno)) {
		if (option_debug)
			ast_log(LOG_DEBUG, "Ignoring too old SIP packet packet %d (expecting >= %d)\n", req->seqno, p->icseq);
		if (req->method != SIP_ACK)
			transmit_response(p, "503 Server error", req);	/* We must respond according to RFC 3261 sec 12.2 */
		return -1;
	} else if (p->icseq &&
		   p->icseq == req->seqno &&
		   req->method != SIP_ACK &&
		   (p->method != SIP_CANCEL || ast_test_flag(&p->flags[0], SIP_ALREADYGONE))) {
		/* ignore means "don't do anything with it" but still have to 
		   respond appropriately.  We do this if we receive a repeat of
		   the last sequence number  */
		ast_set_flag(req, SIP_PKT_IGNORE);
		ast_set_flag(req, SIP_PKT_IGNORE_REQ);
		if (option_debug > 2)
			ast_log(LOG_DEBUG, "Ignoring SIP message because of retransmit (%s Seqno %d, ours %d)\n", sip_method2txt(p->method), p->icseq, req->seqno);
	}
		
	if (req->seqno >= p->icseq)
		/* Next should follow monotonically (but not necessarily 
		   incrementally -- thanks again to the genius authors of SIP --
		   increasing */
		p->icseq = req->seqno;

	/* Find their tag if we haven't got it */
	if (ast_strlen_zero(p->theirtag)) {
		char tag[128];

		gettag(req->from, tag, sizeof(tag));
		ast_string_field_set(p, theirtag, tag);
	}
	snprintf(p->lastmsg, sizeof(p->lastmsg), "Rx: %s", cmd);

	/* If this is a request packet without a from tag, it's not
		correct according to RFC 3261  */
	/* Check if this a new request in a new dialog with a totag already attached to it,
		RFC 3261 - section 12.2 - and we don't want to mess with recovery  */

	if ((!p->initreq) && ast_test_flag(req, SIP_PKT_WITH_TOTAG)) {
		/* If this is a first request and it got a to-tag, it is not for us */
		if (!ast_test_flag(req, SIP_PKT_IGNORE) && req->method == SIP_INVITE)
			transmit_response_reliable(p, "481 Call/Transaction Does Not Exist", req);
		else if (req->method != SIP_ACK)
			transmit_response(p, "481 Call/Transaction Does Not Exist", req);
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
		dialogstatechange(p, DIALOG_STATE_TERMINATED);
		return res;
	}

	/* Handle various incoming SIP methods in requests */
	switch (p->method) {
	case SIP_OPTIONS:
		res = handle_request_options(p, req);
		break;
	case SIP_INVITE:
		res = handle_request_invite(p, req, debug, sin, recount, e);
		break;
	case SIP_REFER:
		res = handle_request_refer(p, req, debug, req->seqno, nounlock);
		break;
	case SIP_CANCEL:
		res = handle_request_cancel(p, req);
		break;
	case SIP_BYE:
		res = handle_request_bye(p, req);
		break;
	case SIP_MESSAGE:
		res = handle_request_message(p, req);
		break;
	case SIP_SUBSCRIBE:
		res = handle_request_subscribe(p, req, sin, e);
		break;
	case SIP_REGISTER:
		res = handle_request_register(p, req, sin, e);
		break;
	case SIP_INFO:
		handle_request_info(p, req);
		break;
	case SIP_NOTIFY:
		res = handle_request_notify(p, req, sin, e);
		break;
	case SIP_ACK:
		/* Make sure we don't ignore this */
		/* ACK on 200 OK */
		if (req->seqno == p->pendinginvite) {
			if (option_debug)
				ast_log(LOG_DEBUG, "Got ACK on 200 OK, this call setup is complete - %s Cseq %d\n", p->callid, req->seqno);
			p->pendinginvite = 0;
			__sip_ack(p, req->seqno, SIP_PKT_RESPONSE, 0, FALSE);
			if (find_sdp(req)) {
				if (process_sdp(p, req))
					return -1;
			} 
			check_pendings(p);
		} else if (option_debug)
			ast_log(LOG_DEBUG, "Got ACK that does not match dialog cseq, this is unexpected - %s Cseq %d Pending cseq %d\n", p->callid, req->seqno, p->pendinginvite);
		/* Got an ACK that we did not match with active dialog. 
		   We have given a final response */
		if (!p->lastinvite && ast_strlen_zero(p->randdata))
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
		break;
	default:
		transmit_response_with_attachment(WITH_ALLOW, p, "501 Method Not Implemented", req, XMIT_UNRELIABLE);
		ast_log(LOG_NOTICE, "Unknown SIP command '%s' from '%s'\n", 
			cmd, ast_inet_ntoa(p->sa.sin_addr));
		/* If this is some new method, and we don't have a call, destroy it now */
		if (!p->initreq)
			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
		break;
	}
	return res;
}

/*! \brief Send message waiting indication to alert peer that they've got voicemail */
GNURK int sip_send_mwi_to_peer(struct sip_device *peer)
{
	/* Called with devicelist lock, but releases it */
	struct sip_dialog *p;
	int newmsgs, oldmsgs;

	/* Check for messages */
	ast_app_inboxcount(peer->mailbox.mailbox, &newmsgs, &oldmsgs);
	
	peer->mailbox.lastmsgcheck = time(NULL);
	
	/* Return now if it's the same thing we told them last time */
	if (((newmsgs << 8) | (oldmsgs)) == peer->mailbox.lastmsgssent) {
		return 0;
	}
	
	
	peer->mailbox.lastmsgssent = ((newmsgs << 8) | (oldmsgs));

	if (peer->mailbox.mwipvt) {
		/* Base message on subscription */
		p = peer->mailbox.mwipvt;
	} else {
		/* Build temporary dialog for this message */
		if (!(p = sip_alloc(NULL, NULL, FALSE, SIP_NOTIFY))) 
			return -1;
		if (create_addr_from_peer(p, peer)) {
			/* Maybe they're not registered, etc. */
			sip_destroy(p);
			return 0;
		}
		/* Recalculate our side, and recalculate Call ID */
		if (sip_ouraddrfor(&p->sa.sin_addr, &p->ourip))
			p->ourip = sipnet.__ourip;
		build_via(p, FALSE);
		build_callid_pvt(p);
		/* Destroy this session after 32 secs */
		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
	}
	/* Send MWI */
	ast_set_flag(&p->flags[0], SIP_OUTGOING);
	transmit_notify_with_mwi(p, newmsgs, oldmsgs, (char *) peer->mailbox.vmexten);
	return 0;
}

/*! \brief Part of PBX channel interface
\note
\par	Return values:---

	If we have qualify on and the device is not reachable, regardless of registration
	state we return AST_DEVICE_UNAVAILABLE

	For peers with call limit:
		- not registered			AST_DEVICE_UNAVAILABLE
		- registered, no call			AST_DEVICE_NOT_INUSE
		- registered, active calls		AST_DEVICE_INUSE
		- registered, call limit reached	AST_DEVICE_BUSY
	For peers without call limit:
		- not registered			AST_DEVICE_UNAVAILABLE
		- registered				AST_DEVICE_NOT_INUSE
		- fixed IP (!dynamic)			AST_DEVICE_NOT_INUSE

	If we return AST_DEVICE_UNKNOWN, the device state engine will try to find
	out a state by walking the channel list.
*/
static int sip_devicestate(void *data)
{
	char *host;
	char *tmp;

	struct hostent *hp;
	struct ast_hostent ahp;
	struct sip_device *p;

	int res = AST_DEVICE_INVALID;

	/* make sure data is not null. Maybe unnecessary, but better be safe */
	host = ast_strdupa(data ? data : "");
	if ((tmp = strchr(host, '@')))
		host = tmp + 1;

	if (option_debug > 2) 
		ast_log(LOG_DEBUG, "Checking device state for peer %s\n", host);

	if ((p = find_device(host, NULL, 1))) {
		if (p->addr.sin_addr.s_addr || p->defaddr.sin_addr.s_addr) {
			/* we have an address for the peer */
			/* if qualify is turned on, check the status */
			if (p->maxms && (p->lastms > p->maxms)) {
				res = AST_DEVICE_UNAVAILABLE;
			} else {
				/* qualify is not on, or the peer is responding properly */
				/* check call limit */
				if (p->call_limit && (p->inUse == p->call_limit))
					res = AST_DEVICE_BUSY;
				else if (p->call_limit && p->inUse)
					res = AST_DEVICE_INUSE;
				else
					res = AST_DEVICE_NOT_INUSE;
				if (p->onHold)
					res = AST_DEVICE_ONHOLD;
				else if (p->inRinging) {
					if (p->inRinging == p->inUse)
						res = AST_DEVICE_RINGING;
					else
						res = AST_DEVICE_RINGINUSE;
				}
			}
		} else {
			/* there is no address, it's unavailable */
			res = AST_DEVICE_UNAVAILABLE;
		}
		device_unref(p);
	} else {
		hp = ast_gethostbyname(host, &ahp);
		if (hp)
			res = AST_DEVICE_UNKNOWN;
	}

	return res;
}

/*! \brief PBX interface function -build SIP pvt structure 
	\note SIP calls initiated by the PBX arrive here 
*/
static struct ast_channel *sip_request_call(const char *type, int format, void *data, int *cause)
{
	int oldformat;
	struct sip_dialog *dialog;
	struct ast_channel *tmpc = NULL;
	char *username, *domain, *device;
	char tmp[256];
	char *dialstring = data;
	char *dnid;
	int res = 0;

	oldformat = format;

	if (!(format &= ((AST_FORMAT_MAX_AUDIO << 1) - 1))) {
		ast_log(LOG_NOTICE, "Asked to get a channel of unsupported format %s while capability is %s\n", ast_getformatname(oldformat), ast_getformatname(global.capability));
		*cause = AST_CAUSE_BEARERCAPABILITY_NOTAVAIL;	/* Can't find codec to connect to host */
		return NULL;
	}
	if (option_debug)
		ast_log(LOG_DEBUG, "Asked to create a SIP channel with formats: %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), oldformat));

	/* Allocate SIP dialog structure */
	if (!(dialog = sip_alloc(NULL, NULL, FALSE, SIP_INVITE))) {
		ast_log(LOG_ERROR, "Unable to build sip pvt data for '%s' (Out of memory or socket error)\n", (char *)data);
		*cause = AST_CAUSE_SWITCH_CONGESTION;
		return NULL;
	}

	if (!(dialog->inviteoptions = ast_calloc(1, sizeof(*dialog->inviteoptions)))) {
		sip_destroy(dialog);
		ast_log(LOG_ERROR, "Unable to build option SIP data structure - Out of memory\n");
		*cause = AST_CAUSE_SWITCH_CONGESTION;
		return NULL;
	}

	/*! \page chan_sip3_dialstring chan_sip3 :: The SIP dial string

	The SIP dial string is what is used in the dial plan, extensions.conf.

		Currently:
		- DIAL(SIP/user@domain)
		- DIAL(SIP/user@peer)
		- DIAL(SIP/domain/exten)
		
		In SIP3:
		- DIAL(SIP/sip:username@domain!destination)
			- Any SIP uri

		- DIAL(SIP/object/extension!<destination>)
			- object can be a phone or a trunk
			- extension can be any sip uri
			- if domain is not used, the domain/host of the object is
			  used as the request URI
			- Like DIAL(sip/trunk5/oej@edvina.net)
				- We assume a sip: uri unless a scheme is set
			
		This means that old dial plans will not be compatible with
		the new channel.

		The dialstring can be divided into parts

		- object name
		- uri

		\par The To: header and the request URI
		
		It's not easy to determine the contents of the
		to: header. Will it be the same as the extension
		dialled into the PBX? 

		The \b To: header will contain the extension dialed.
		The DNID given in the \i destination option
		will be used in the To: header, with local domain
		or domain included in DNID

			dial(SIP/object!user@example.com)

		will dial the object and use 
			To: user@example.com
		in the To:-header

			dial(SIP/object!user)

		Will have To: user@asteriskdomain

			dial(/SIP/sip:user@domain!12345@domain)

		Will use "user@domain" as the Request URI and
		set 12345@domain as the destination of the call
		in the To: header

	*/
	ast_copy_string(tmp, dialstring, sizeof(tmp));

	/* First separate out the DNID */
	dnid = strchr(tmp, '!');
	if (dnid) {
		*dnid++ = '\0';
		ast_string_field_set(dialog, todnid, dnid);
	}

	/* Check to see if we have a domain. If there's a domain
	   don't match with peer list!
	 */
	domain = strchr(tmp, '@');
	if (domain) {
		*domain++ = '\0';	/* May include port number :5068 */
		username = tmp;
	} else {
		username = strchr(tmp, '/');
		if (username) 
			*username++ = '\0';
		device = tmp;
	}

	/* At this point, we either have
		- username + domain	dial(sip/username@domain)
		- device + username	dial(sip/device/username)
		- device		dial(sip/device)
	
	and the dialog->todnid optionally showing the To: destiation
	*/

	/* Try to match caller with a defined object */
	if ((res = create_addr(dialog, username, domain, device))) {
		if (res == -1) {
			*cause = AST_CAUSE_UNREGISTERED;
			if (option_debug > 2)
				ast_log(LOG_DEBUG, "Cant create SIP call - target device not registred: %s\n", device);
		} else if (res == -2) {
			*cause = AST_CAUSE_NO_ROUTE_DESTINATION;
			if (option_debug > 2)
				ast_log(LOG_DEBUG, "Cant create SIP call - domain or host name does not resolve: %s\n", domain);
		}
		sip_destroy(dialog);
		return NULL;
	}

	/* Recalculate our side, and recalculate Call ID */
	if (sip_ouraddrfor(&dialog->sa.sin_addr, &dialog->ourip))
		dialog->ourip = sipnet.__ourip;

	build_via(dialog, FALSE);
	build_callid_pvt(dialog);
	
	/* We have an extension to call, don't use the full contact here */
	/* This to enable dialing registered peers with extension dialling,
	   like SIP/device/extension 	
	   SIP/device will still use the full contact */

	if (username) {
		if (ast_strlen_zero(dialog->peername))
			ast_string_field_set(dialog, peername, username);
		ast_string_field_free(dialog, fullcontact);
	}
	if (sipdebug)
		ast_verbose("Setting up to call extension '%s' at '%s'\n", username ? username : "<none>", device ? device : domain);

	/*! \todo We should really set the request URI here and now!!!
	*/
	dialog->prefcodec = oldformat;				/* Format for this call */
	dialog_lock(dialog, TRUE);
	tmpc = sip_new(dialog, AST_STATE_DOWN, domain ? domain : device);	/* Place the call */ 
	dialog_lock(dialog, FALSE);
	if (!tmpc)
		sip_destroy(dialog);
	ast_update_use_count();
	restart_monitor();	/* Make sure we have monitor up and running */
	return tmpc;
}

static int sip_handle_t38_reinvite(struct ast_channel *chan, struct sip_dialog *pvt, int reinvite)
{
	struct sip_dialog *p;
	int flag = 0;
	
	p = chan->tech_pvt;
	if (!p || !pvt->udptl)
		return -1;
	
	/* Setup everything on the other side like offered/responded from first side */
	dialog_lock(p, TRUE);
	p->t38.jointcapability = p->t38.peercapability = pvt->t38.jointcapability;
	ast_udptl_set_far_max_datagram(p->udptl, ast_udptl_get_local_max_datagram(pvt->udptl));
	ast_udptl_set_local_max_datagram(p->udptl, ast_udptl_get_local_max_datagram(pvt->udptl));
	ast_udptl_set_error_correction_scheme(p->udptl, ast_udptl_get_error_correction_scheme(pvt->udptl));
	
	if (reinvite) {		/* If we are handling sending re-invite to the other side of the bridge */
		if (ast_test_flag(&p->flags[0], SIP_CAN_REINVITE) && ast_test_flag(&pvt->flags[0], SIP_CAN_REINVITE)) {
			ast_udptl_get_peer(pvt->udptl, &p->udptlredirip);
			flag =1;
		} else {
			memset(&p->udptlredirip, 0, sizeof(p->udptlredirip));
		}
		if (!ast_test_flag(&p->flags[0], SIP_GOTREFER)) {
			if (!p->pendinginvite) {
				if (option_debug > 2) {
					if (flag)
						ast_log(LOG_DEBUG, "Sending reinvite on SIP '%s' - It's UDPTL soon redirected to IP %s:%d\n", p->callid, ast_inet_ntoa(p->udptlredirip.sin_addr), ntohs(p->udptlredirip.sin_port));
					else
						ast_log(LOG_DEBUG, "Sending reinvite on SIP '%s' - It's UDPTL soon redirected to us (IP %s)\n", p->callid, ast_inet_ntoa(p->ourip));
				}
				transmit_reinvite_with_sdp(p, TRUE);
			} else if (!ast_test_flag(&p->flags[0], SIP_PENDINGBYE)) {
				if (option_debug > 2) {
					if (flag)
						ast_log(LOG_DEBUG, "Deferring reinvite on SIP '%s' - It's UDPTL will be redirected to IP %s:%d\n", p->callid, ast_inet_ntoa(p->udptlredirip.sin_addr), ntohs(p->udptlredirip.sin_port));
					else
						ast_log(LOG_DEBUG, "Deferring reinvite on SIP '%s' - It's UDPTL will be redirected to us (IP %s)\n", p->callid, ast_inet_ntoa(p->ourip));
				}
				ast_set_flag(&p->flags[0], SIP_NEEDREINVITE);
			}
		}
		/* Reset lastrtprx timer */
		p->lastrtprx = p->lastrtptx = time(NULL);
		dialog_lock(p, FALSE);
		return 0;
	} else {	/* If we are handling sending 200 OK to the other side of the bridge */
		if (ast_test_flag(&p->flags[0], SIP_CAN_REINVITE) && ast_test_flag(&pvt->flags[0], SIP_CAN_REINVITE)) {
			ast_udptl_get_peer(pvt->udptl, &p->udptlredirip);
			flag = 1;
		} else {
			memset(&p->udptlredirip, 0, sizeof(p->udptlredirip));
		}
		if (option_debug > 2) {
			if (flag)
				ast_log(LOG_DEBUG, "Responding 200 OK on SIP '%s' - It's UDPTL soon redirected to IP %s:%d\n", p->callid, ast_inet_ntoa(p->udptlredirip.sin_addr), ntohs(p->udptlredirip.sin_port));
			else
				ast_log(LOG_DEBUG, "Responding 200 OK on SIP '%s' - It's UDPTL soon redirected to us (IP %s)\n", p->callid, ast_inet_ntoa(p->ourip));
		}
		pvt->t38.state = T38_ENABLED;
		p->t38.state = T38_ENABLED;
		if (option_debug > 1) {
			ast_log(LOG_DEBUG, "T38 changed state to %d on channel %s\n", pvt->t38.state, pvt->owner ? pvt->owner->name : "<none>");
			ast_log(LOG_DEBUG, "T38 changed state to %d on channel %s\n", p->t38.state, chan ? chan->name : "<none>");
		}
		transmit_response_with_attachment(WITH_T38_SDP, p, "200 OK", p->initreq, XMIT_CRITICAL);
		p->lastrtprx = p->lastrtptx = time(NULL);
		dialog_lock(p, FALSE);
		return 0;
	}
}


static char *synopsis_dtmfmode = "Change the dtmfmode for a SIP call";
static char *descrip_dtmfmode = "SIPDtmfMode(inband|info|rfc2833): Changes the dtmfmode for a SIP call\n";
static char *app_dtmfmode = "SIPDtmfMode";

static char *app_sipaddheader = "SIPAddHeader";
static char *synopsis_sipaddheader = "Add a SIP header to the outbound call";

static char *descrip_sipaddheader = ""
"  SIPAddHeader(Header: Content)\n"
"Adds a header to the INVITE of a SIP call placed with DIAL.\n"
"Remember to user the X-header if you are adding non-standard SIP\n"
"headers, like \"X-Asterisk-Accountcode:\". Use this with care.\n"
"Adding the wrong headers may jeopardize the SIP dialog.\n"
"Always returns 0\n";


/*! \brief Set the DTMFmode for an outbound SIP call (application) */
static int sip_dtmfmode(struct ast_channel *chan, void *data)
{
	struct sip_dialog *p;
	char *mode;
	if (data)
		mode = (char *)data;
	else {
		ast_log(LOG_WARNING, "This application requires the argument: info, inband, rfc2833\n");
		return 0;
	}
	ast_channel_lock(chan);
	if (chan->tech != &sip_tech && chan->tech != &sip_tech_info) {
		ast_log(LOG_WARNING, "Call this application only on SIP incoming calls\n");
		ast_channel_unlock(chan);
		return 0;
	}
	p = chan->tech_pvt;
	if (!p) {
		ast_channel_unlock(chan);
		return 0;
	}
	dialog_lock(p, TRUE);
	if (!strcasecmp(mode, "info")) {
		ast_clear_flag(&p->flags[0], SIP_DTMF);
		ast_set_flag(&p->flags[0], SIP_DTMF_INFO);
	} else if (!strcasecmp(mode, "rfc2833")) {
		ast_clear_flag(&p->flags[0], SIP_DTMF);
		ast_set_flag(&p->flags[0], SIP_DTMF_RFC2833);
	} else if (!strcasecmp(mode, "inband")) { 
		ast_clear_flag(&p->flags[0], SIP_DTMF);
		ast_set_flag(&p->flags[0], SIP_DTMF_INBAND);
	} else
		ast_log(LOG_WARNING, "I don't know about this DTMF mode: %s\n",mode);
	if (ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_INBAND) {
		if (!p->vad) {
			p->vad = ast_dsp_new();
			ast_dsp_set_features(p->vad, DSP_FEATURE_DTMF_DETECT);
		}
	} else {
		if (p->vad) {
			ast_dsp_free(p->vad);
			p->vad = NULL;
		}
	}
	dialog_lock(p, FALSE);
	ast_channel_unlock(chan);
	return 0;
}

/*! \brief Add a SIP header to an outbound INVITE */
static int sip_addheader(struct ast_channel *chan, void *data)
{
	int no = 0;
	int ok = FALSE;
	char varbuf[30];
	char *inbuf = (char *) data;
	
	if (ast_strlen_zero(inbuf)) {
		ast_log(LOG_WARNING, "This application requires the argument: Header\n");
		return 0;
	}
	ast_channel_lock(chan);

	/* Check for headers */
	while (!ok && no <= 50) {
		no++;
		snprintf(varbuf, sizeof(varbuf), "_SIPADDHEADER%.2d", no);

		/* Compare without the leading underscore */
		if( (pbx_builtin_getvar_helper(chan, (const char *) varbuf + 1) == (const char *) NULL) )
			ok = TRUE;
	}
	if (ok) {
		pbx_builtin_setvar_helper (chan, varbuf, inbuf);
		if (sipdebug)
			ast_log(LOG_DEBUG,"SIP Header added \"%s\" as %s\n", inbuf, varbuf);
	} else {
		ast_log(LOG_WARNING, "Too many SIP headers added, max 50\n");
	}
	ast_channel_unlock(chan);
	return 0;
}

/*! \brief Transfer call before connect with a 302 redirect
\note	Called by the transfer() dialplan application through the sip_transfer()
	pbx interface function if the call is in ringing state 
\todo	Fix this function so that we wait for reply to the REFER and
	react to errors, denials or other issues the other end might have.
 */
static int sip_sipredirect(struct sip_dialog *p, const char *dest)
{
	char *cdest;
	char *extension, *host, *port;
	char tmp[80];

	cdest = ast_strdupa(dest);
	
	extension = strsep(&cdest, "@");
	host = strsep(&cdest, ":");
	port = strsep(&cdest, ":");
	if (ast_strlen_zero(extension)) {
		ast_log(LOG_ERROR, "Missing mandatory argument: extension\n");
		return 0;
	}

	/* we'll issue the redirect message here */
	if (!host) {
		char *localtmp;

		ast_copy_string(tmp, get_header(p->initreq, "To"), sizeof(tmp));
		if (ast_strlen_zero(tmp)) {
			ast_log(LOG_ERROR, "Cannot retrieve the 'To' header from the original SIP request!\n");
			return 0;
		}
		if ((localtmp = strstr(tmp, "sip:")) && (localtmp = strchr(localtmp, '@'))) {
			char lhost[80], lport[80];

			memset(lhost, 0, sizeof(lhost));
			memset(lport, 0, sizeof(lport));
			localtmp++;
			/* This is okey because lhost and lport are as big as tmp */
			sscanf(localtmp, "%[^<>:; ]:%[^<>:; ]", lhost, lport);
			if (ast_strlen_zero(lhost)) {
				ast_log(LOG_ERROR, "Can't find the host address\n");
				return 0;
			}
			host = ast_strdupa(lhost);
			if (!ast_strlen_zero(lport)) {
				port = ast_strdupa(lport);
			}
		}
	}

	ast_string_field_build(p, our_contact, "Transfer <sip:%s@%s%s%s>", extension, host, port ? ":" : "", port ? port : "");
	transmit_response_reliable(p, "302 Moved Temporarily", p->initreq);

	sip_scheddestroy(p, 32000);	/* Make sure we stop send this reply. */

	/* hangup here */
	return -1;
}

/*! \brief Reload module */
GNURK int sip_do_reload()
{
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "--------------- SIP reload started\n");

	clear_realm_authentication(authl);
	clear_sip_domains();
	authl = NULL;

	/* First, destroy all outstanding registry calls */
	/* This is needed, since otherwise active registry entries will not be destroyed */
	ASTOBJ_CONTAINER_TRAVERSE(&regl, 1, do {
		ASTOBJ_RDLOCK(iterator);
		if (iterator->call) {
			if (option_debug > 2)
				ast_log(LOG_DEBUG, "Destroying active SIP dialog for registry %s@%s\n", iterator->username, iterator->hostname);
			/* This will also remove references to the registry */
			sip_destroy(iterator->call);
		}
		ASTOBJ_UNLOCK(iterator);
	} while(0));

	/* Then, actually destroy users and registry */
	ASTOBJ_CONTAINER_DESTROYALL(&regl, sip_registry_destroy);
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "--------------- Done destroying registry list\n");
	ASTOBJ_CONTAINER_MARKALL(&devicelist);
	reload_config(sip_reloadreason);

	/* Prune peers who still are supposed to be deleted */
	ASTOBJ_CONTAINER_PRUNE_MARKED(&devicelist, sip_destroy_device);
	if (option_debug > 3)
		ast_log(LOG_DEBUG, "--------------- Done destroying pruned peers\n");

	/* Send qualify (OPTIONS) to all peers */
	sip_poke_all_peers();

	/* Register with all services */
	sip_send_all_registers();

	if (option_debug > 3)
		ast_log(LOG_DEBUG, "--------------- SIP reload done\n");

	return 0;
}


/*! Check for a reload request */
int sip_reload_check()
{
	int reloading;

	ast_mutex_lock(&sip_reload_lock);
	reloading = sip_reloading;
	ast_mutex_unlock(&sip_reload_lock);
	sip_reloading = FALSE;
	return reloading;
}


/*! \brief Force reload of module from cli */
GNURK int sip_reload(int fd)
{

	ast_mutex_lock(&sip_reload_lock);
	if (sip_reloading) {
		ast_verbose("Previous SIP reload not yet done\n");
	} else {
		sip_reloading = TRUE;
		if (fd)
			sip_reloadreason = CHANNEL_CLI_RELOAD;
		else
			sip_reloadreason = CHANNEL_MODULE_RELOAD;
	}
	ast_mutex_unlock(&sip_reload_lock);
	restart_monitor();	/* Time to wake up our monitor thread */

	return 0;
}


/*! \brief  reload: Part of Asterisk module interface */
static int reload(void)
{
	return sip_reload(0);
}

/*! \brief  load_module: PBX load module - initialization */
static int load_module(void)
{
	ASTOBJ_CONTAINER_INIT(&devicelist);	/* Peer object list */
	ASTOBJ_CONTAINER_INIT(&regl);	/* Registry object list */

	if (!(sched = sched_context_create())) {
		ast_log(LOG_ERROR, "Unable to create scheduler context\n");
		return AST_MODULE_LOAD_FAILURE;
	}
	logdebug(4, "SIP3 :: Scheduler initialized...\n");

	if (!(io = io_context_create())) {
		ast_log(LOG_ERROR, "Unable to create I/O context\n");
		sched_context_destroy(sched);
		return AST_MODULE_LOAD_FAILURE;
	}
	logdebug(4, "SIP3 :: IO context initialized...\n");

	sip_reloadreason = CHANNEL_MODULE_LOAD;

	if(reload_config(sip_reloadreason)) {	/* Load the configuration from sip.conf */
		io_context_destroy(io);
		sched_context_destroy(sched);
		return AST_MODULE_LOAD_DECLINE;
	}

	logdebug(4, "SIP3 :: Configuration loaded\n");

	/* Make sure we can register our sip channel type */
	if (ast_channel_register(&sip_tech)) {
		ast_log(LOG_ERROR, "Unable to register channel type 'SIP'\n");
		io_context_destroy(io);
		sched_context_destroy(sched);
		
		/* Isn't there more to destroy here? */
		return AST_MODULE_LOAD_FAILURE;
	}
	logdebug(4, "SIP3 :: Registered channel to PBX.\n");

	/* Tell the RTP and UDPTL subdriver that we're here */
	register_rtp_and_udptl();	/* See sip3_sdprtp.c */
	logdebug(4, "SIP3 :: Initialized RTP and UDPTL. Ready for action\n");

	/* Register dialplan applications */
	ast_register_application(app_dtmfmode, sip_dtmfmode, synopsis_dtmfmode, descrip_dtmfmode);
	ast_register_application(app_sipaddheader, sip_addheader, synopsis_sipaddheader, descrip_sipaddheader);

	/* Register dialplan functions */
	ast_custom_function_register(&sip_header_function);
	ast_custom_function_register(&sippeer_function);
	ast_custom_function_register(&sipchaninfo_function);
	ast_custom_function_register(&checksipdomain_function);

	/* Register manager commands */
	sip_cli_and_manager_commands_register();
	logdebug(4, "SIP3 :: Registered CLI and manager commands\n");
	sip_poke_all_peers();	
	logdebug(4, "SIP3 :: Scheduled poke of all peers\n");
	sip_send_all_registers();
	logdebug(4, "SIP3 :: Scheduled registration of services\n");
	
	/* And start the monitor for the first time */
	restart_monitor();	

	logdebug(4, "SIP3 :: Monitor started. Ready for rock'n'roll! ---------------------------\n");

	return AST_MODULE_LOAD_SUCCESS;
}

static int unload_module(void)
{
	struct sip_dialog *p, *pl;
	
	/* First, take us out of the channel type list */
	ast_channel_unregister(&sip_tech);

	ast_custom_function_unregister(&sipchaninfo_function);
	ast_custom_function_unregister(&sippeer_function);
	ast_custom_function_unregister(&sip_header_function);
	ast_custom_function_unregister(&checksipdomain_function);

	ast_unregister_application(app_dtmfmode);
	ast_unregister_application(app_sipaddheader);
	sip_cli_and_manager_commands_unregister();

	unregister_rtp_and_udptl();	/* sip3_sdprtp.c */

	ast_manager_unregister("SIPpeers");
	ast_manager_unregister("SIPshowpeer");

	/* Hangup all dialogs if they have an owner */
	dialoglist_lock();
	for (p = dialoglist; p ; p = p->next) {
		if (p->owner)
			ast_softhangup(p->owner, AST_SOFTHANGUP_APPUNLOAD);
	}
	dialoglist_unlock();

	/* Kill the monitor thread */
	kill_monitor();

	/* Destroy all the dialogs and free their memory */
	dialoglist_lock();
	p = dialoglist;
	while (p) {
		pl = p;
		p = p->next;
		__sip_destroy(pl, TRUE, TRUE);
	}
	dialoglist_unlock();
	dialoglist = NULL;

	/* Free memory for local network address mask */
	ast_free_ha(sipnet.localaddr);

	/* Destroy all device configurations in the device list */
	ASTOBJ_CONTAINER_DESTROYALL(&devicelist, sip_destroy_device);
	ASTOBJ_CONTAINER_DESTROY(&devicelist);

	/* Destroy all entries in the registry list */
	ASTOBJ_CONTAINER_DESTROYALL(&regl, sip_registry_destroy);
	ASTOBJ_CONTAINER_DESTROY(&regl);

	clear_realm_authentication(authl);
	clear_sip_domains();				/* Clear the list of hosted domains */

	close(sipnet.sipsock);				/* Close the network socket */
	sched_context_destroy(sched);
		
	return 0;
}

AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "Session Initiation Protocol, chan_sip3 version (SIP)",
		.load = load_module,
		.unload = unload_module,
		.reload = reload,
	       );
