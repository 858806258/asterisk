<HTML>
    <HEAD>
      <TITLE>Asterisk.org: Developer Documentation (24 May 2007)</TITLE>
      <LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
    </HEAD>
    <BODY BGCOLOR="#FFFFFF">
<div><font size="2" align="right">Thu May 24 22:26:41 2007</font></div>

<h2>Asterisk developer's documentation</h2>
<hr/>
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir__2Fusr_2Flocal_2Fsrc_2Fasterisk_2Esvn_2Fastum_2Finclude_2F.html">include</a>&nbsp;&raquo&nbsp;<a class="el" href="dir__2Fusr_2Flocal_2Fsrc_2Fasterisk_2Esvn_2Fastum_2Finclude_2Fasterisk_2F.html">asterisk</a></div>
<h1>file.h</h1><a href="file_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Asterisk -- An open source telephony toolkit.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 1999 - 2006, Digium, Inc.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * Mark Spencer &lt;markster@digium.com&gt;</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * See http://www.asterisk.org for more information about</span>
<a name="l00009"></a>00009 <span class="comment"> * the Asterisk project. Please do not directly contact</span>
<a name="l00010"></a>00010 <span class="comment"> * any of the maintainers of this project for assistance;</span>
<a name="l00011"></a>00011 <span class="comment"> * the project provides a web site, mailing lists and IRC</span>
<a name="l00012"></a>00012 <span class="comment"> * channels for your use.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> * This program is free software, distributed under the terms of</span>
<a name="l00015"></a>00015 <span class="comment"> * the GNU General Public License Version 2. See the LICENSE file</span>
<a name="l00016"></a>00016 <span class="comment"> * at the top of the source tree.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">/*! \file</span>
<a name="l00020"></a>00020 <span class="comment"> * \brief Generic File Format Support.</span>
<a name="l00021"></a>00021 <span class="comment"> */</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#ifndef _ASTERISK_FILE_H</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#define _ASTERISK_FILE_H</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span>
<a name="l00026"></a>00026 <span class="preprocessor">#ifndef stdin</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#error You must include stdio.h before file.h!</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* !stdin */</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#include "<a class="code" href="channel_8h.html">asterisk/channel.h</a>"</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include "<a class="code" href="frame_8h.html">asterisk/frame.h</a>"</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#if defined(__cplusplus) || defined(c_plusplus)</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<a name="l00036"></a>00036 <span class="preprocessor">#endif</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span>
<a name="l00038"></a>00038 <span class="comment"></span>
<a name="l00039"></a>00039 <span class="comment">/*! Convenient for waiting */</span>
<a name="l00040"></a><a class="code" href="file_8h.html#4da2b9e8d896d755e4003168efa23b45">00040</a> <span class="preprocessor">#define AST_DIGIT_ANY "0123456789#*ABCD"</span>
<a name="l00041"></a><a class="code" href="file_8h.html#0e34acd0336a2f590edd93ad887f05be">00041</a> <span class="preprocessor"></span><span class="preprocessor">#define AST_DIGIT_ANYNUM "0123456789"</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">/*! structure used for lock and refcount of format handlers.</span>
<a name="l00044"></a>00044 <span class="comment"> * Should not be here, but this is a temporary workaround</span>
<a name="l00045"></a>00045 <span class="comment"> * until we implement a more general mechanism.</span>
<a name="l00046"></a>00046 <span class="comment"> * The format handler should include a pointer to</span>
<a name="l00047"></a>00047 <span class="comment"> * this structure.</span>
<a name="l00048"></a>00048 <span class="comment"> * As a trick, if usecnt is initialized with -1,</span>
<a name="l00049"></a>00049 <span class="comment"> * ast_format_register will init the mutex for you.</span>
<a name="l00050"></a>00050 <span class="comment"> */</span>
<a name="l00051"></a><a class="code" href="structast__format__lock.html">00051</a> <span class="keyword">struct </span><a class="code" href="structast__format__lock.html">ast_format_lock</a> {
<a name="l00052"></a><a class="code" href="structast__format__lock.html#dce7c4174ce9323904a934a486c41288">00052</a>    <a class="code" href="lock_8h.html#55c65f4d641fac96608dabb20791a062">ast_mutex_t</a> <a class="code" href="structast__format__lock.html#dce7c4174ce9323904a934a486c41288">lock</a>;
<a name="l00053"></a><a class="code" href="structast__format__lock.html#c01639e851808c10d4e71dfd92f00d76">00053</a>    <span class="keywordtype">int</span> <a class="code" href="structast__format__lock.html#c01639e851808c10d4e71dfd92f00d76">usecnt</a>; <span class="comment">/* number of active clients */</span>
<a name="l00054"></a>00054 };
<a name="l00055"></a>00055 <span class="comment"></span>
<a name="l00056"></a>00056 <span class="comment">/*!</span>
<a name="l00057"></a>00057 <span class="comment"> * Each supported file format is described by the following fields.</span>
<a name="l00058"></a>00058 <span class="comment"> * Not all are necessary, the support routine implement default</span>
<a name="l00059"></a>00059 <span class="comment"> * values for some of them.</span>
<a name="l00060"></a>00060 <span class="comment"> * A handler typically fills a structure initializing the desired</span>
<a name="l00061"></a>00061 <span class="comment"> * fields, and then calls ast_format_register() with the (readonly)</span>
<a name="l00062"></a>00062 <span class="comment"> * structure as an argument.</span>
<a name="l00063"></a>00063 <span class="comment"> */</span>
<a name="l00064"></a><a class="code" href="structast__format.html">00064</a> <span class="keyword">struct </span><a class="code" href="structast__format.html">ast_format</a> {
<a name="l00065"></a><a class="code" href="structast__format.html#23d5c5772e05e09c87f6323a95732f89">00065</a>    <span class="keywordtype">char</span> <a class="code" href="structast__format.html#23d5c5772e05e09c87f6323a95732f89">name</a>[80];    <span class="comment">/*! Name of format */</span>
<a name="l00066"></a><a class="code" href="structast__format.html#6d9c71cd7b5d178eff3ceaba74c32897">00066</a>    <span class="keywordtype">char</span> <a class="code" href="structast__format.html#6d9c71cd7b5d178eff3ceaba74c32897">exts</a>[80];    <span class="comment">/*! Extensions (separated by | if more than one) </span>
<a name="l00067"></a>00067 <span class="comment">               this format can read.  First is assumed for writing (e.g. .mp3) */</span>
<a name="l00068"></a><a class="code" href="structast__format.html#1ddcb92ade31c8fbd370001f9b29a7d9">00068</a>    <span class="keywordtype">int</span> <a class="code" href="structast__format.html#1ddcb92ade31c8fbd370001f9b29a7d9">format</a>;    <span class="comment">/*! Format of frames it uses/provides (one only) */</span><span class="comment"></span>
<a name="l00069"></a>00069 <span class="comment">   /*! Prepare an input stream for playback. Return 0 on success, -1 on error.</span>
<a name="l00070"></a>00070 <span class="comment">    * The FILE is already open (in s-&gt;f) so this function only needs to perform</span>
<a name="l00071"></a>00071 <span class="comment">    * any applicable validity checks on the file. If none is required, the</span>
<a name="l00072"></a>00072 <span class="comment">    * function can be omitted.</span>
<a name="l00073"></a>00073 <span class="comment">    */</span>
<a name="l00074"></a>00074    int (*<a class="code" href="structast__format.html#e7aaa27d4e47c1ff41f292ee6a248ccd">open</a>)(<span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="aesopt_8h.html#8d6242bc80162ac99dd4d368eabe77cc">s</a>);<span class="comment"></span>
<a name="l00075"></a>00075 <span class="comment">   /*! Prepare a stream for output, and comment it appropriately if applicable.</span>
<a name="l00076"></a>00076 <span class="comment">    *  Return 0 on success, -1 on error. Same as the open, the FILE is already</span>
<a name="l00077"></a>00077 <span class="comment">    * open so the function just needs to prepare any header and other fields,</span>
<a name="l00078"></a>00078 <span class="comment">    * if any. The function can be omitted if nothing is needed.</span>
<a name="l00079"></a>00079 <span class="comment">    */</span>
<a name="l00080"></a>00080    <span class="keywordtype">int</span> (*<a class="code" href="structast__format.html#673937cce5afa9a5637d6501f942c990">rewrite</a>)(<span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="aesopt_8h.html#8d6242bc80162ac99dd4d368eabe77cc">s</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *comment);<span class="comment"></span>
<a name="l00081"></a>00081 <span class="comment">   /*! Write a frame to a channel */</span>
<a name="l00082"></a>00082    <span class="keywordtype">int</span> (*<a class="code" href="structast__format.html#9c7728d73131f696c66f90b5a06492c9">write</a>)(<span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *, <span class="keyword">struct </span><a class="code" href="structast__frame.html">ast_frame</a> *);<span class="comment"></span>
<a name="l00083"></a>00083 <span class="comment">   /*! seek num samples into file, whence - like a normal seek but with offset in samples */</span>
<a name="l00084"></a>00084    <span class="keywordtype">int</span> (*<a class="code" href="structast__format.html#1ecca7b8374382e647398ed939b6ab8d">seek</a>)(<span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *, off_t, int);
<a name="l00085"></a>00085    <span class="keywordtype">int</span> (*<a class="code" href="structast__format.html#ca25eb0535d82c17027552e98e6b429e">trunc</a>)(<span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *fs);  <span class="comment">/*! trunc file to current position */</span>
<a name="l00086"></a>00086    off_t (*<a class="code" href="structast__format.html#a5c5c564c0fac936920dc29ed50f8bac">tell</a>)(<span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *fs); <span class="comment">/*! tell current position */</span><span class="comment"></span>
<a name="l00087"></a>00087 <span class="comment">   /*! Read the next frame from the filestream (if available) and report</span>
<a name="l00088"></a>00088 <span class="comment">    * when to get next frame (in samples)</span>
<a name="l00089"></a>00089 <span class="comment">    */</span>
<a name="l00090"></a>00090    <span class="keyword">struct</span> <a class="code" href="structast__frame.html">ast_frame</a> * (*<a class="code" href="structast__format.html#93ecff7ef453f32514e255a0ff2554da">read</a>)(<span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *, <span class="keywordtype">int</span> *whennext);<span class="comment"></span>
<a name="l00091"></a>00091 <span class="comment">   /*! Do any closing actions, if any. The descriptor and structure are closed</span>
<a name="l00092"></a>00092 <span class="comment">    * and destroyed by the generic routines, so they must not be done here. */</span>
<a name="l00093"></a>00093    <span class="keywordtype">void</span> (*<a class="code" href="structast__format.html#474d8ca4cf587f836fe15026852f7ed5">close</a>)(<span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *);
<a name="l00094"></a>00094    <span class="keywordtype">char</span> * (*<a class="code" href="structast__format.html#9bb59f68e7757107c049d6684fde16bc">getcomment</a>)(<span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *);     <span class="comment">/*! Retrieve file comment */</span>
<a name="l00095"></a>00095 
<a name="l00096"></a>00096    <a class="code" href="structast__format.html#1ceb4f4a9db3001f276d5e435d397955">AST_LIST_ENTRY</a>(<a class="code" href="structast__format.html">ast_format</a>) list;       <span class="comment">/*! Link */</span>
<a name="l00097"></a>00097 <span class="comment"></span>
<a name="l00098"></a>00098 <span class="comment">   /*!</span>
<a name="l00099"></a>00099 <span class="comment">    * If the handler needs a buffer (for read, typically)</span>
<a name="l00100"></a>00100 <span class="comment">    * and/or a private descriptor, put here the</span>
<a name="l00101"></a>00101 <span class="comment">    * required size (in bytes) and the support routine will allocate them</span>
<a name="l00102"></a>00102 <span class="comment">    * for you, pointed by s-&gt;buf and s-&gt;private, respectively.</span>
<a name="l00103"></a>00103 <span class="comment">    * When allocating a buffer, remember to leave AST_FRIENDLY_OFFSET</span>
<a name="l00104"></a>00104 <span class="comment">    * spare bytes at the bginning.</span>
<a name="l00105"></a>00105 <span class="comment">    */</span>
<a name="l00106"></a><a class="code" href="structast__format.html#278a7af3130e71a3c38651b19a88592f">00106</a>    <span class="keywordtype">int</span> <a class="code" href="structast__format.html#278a7af3130e71a3c38651b19a88592f">buf_size</a>;        <span class="comment">/*! size of frame buffer, if any, aligned to 8 bytes. */</span>
<a name="l00107"></a><a class="code" href="structast__format.html#28712dbb41522563998e67e445955d18">00107</a>    <span class="keywordtype">int</span> <a class="code" href="structast__format.html#28712dbb41522563998e67e445955d18">desc_size</a>;       <span class="comment">/*! size of private descriptor, if any */</span>
<a name="l00108"></a>00108 
<a name="l00109"></a><a class="code" href="structast__format.html#22884db148f0ffb0d830ba431102b0b5">00109</a>    <span class="keyword">struct </span><a class="code" href="structast__module.html">ast_module</a> *<a class="code" href="structast__format.html#22884db148f0ffb0d830ba431102b0b5">module</a>;
<a name="l00110"></a>00110 };
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">/*</span>
<a name="l00113"></a>00113 <span class="comment"> * This structure is allocated by file.c in one chunk,</span>
<a name="l00114"></a>00114 <span class="comment"> * together with buf_size and desc_size bytes of memory</span>
<a name="l00115"></a>00115 <span class="comment"> * to be used for private purposes (e.g. buffers etc.)</span>
<a name="l00116"></a>00116 <span class="comment"> */</span>
<a name="l00117"></a><a class="code" href="structast__filestream.html">00117</a> <span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> {<span class="comment"></span>
<a name="l00118"></a>00118 <span class="comment">   /*! Everybody reserves a block of AST_RESERVED_POINTERS pointers for us */</span>
<a name="l00119"></a><a class="code" href="structast__filestream.html#7631454338ff70b1a6b1262f5f36beac">00119</a>    <span class="keyword">struct </span><a class="code" href="structast__format.html">ast_format</a> *<a class="code" href="structast__filestream.html#7631454338ff70b1a6b1262f5f36beac">fmt</a>; <span class="comment">/* need to write to the lock and usecnt */</span>
<a name="l00120"></a><a class="code" href="structast__filestream.html#4e5868d676cb634aa75b125a0f741abf">00120</a>    <span class="keywordtype">int</span> <a class="code" href="structast__filestream.html#4e5868d676cb634aa75b125a0f741abf">flags</a>;
<a name="l00121"></a><a class="code" href="structast__filestream.html#15d61712450a686a7f365adf4fef581f">00121</a>    mode_t <a class="code" href="structast__filestream.html#15d61712450a686a7f365adf4fef581f">mode</a>;
<a name="l00122"></a><a class="code" href="structast__filestream.html#435ed7e9f07f740abf511a62c00eef6e">00122</a>    <span class="keywordtype">char</span> *<a class="code" href="structast__filestream.html#435ed7e9f07f740abf511a62c00eef6e">filename</a>;
<a name="l00123"></a><a class="code" href="structast__filestream.html#6964b5d4fdb02bab8cefc323bda1b18c">00123</a>    <span class="keywordtype">char</span> *<a class="code" href="structast__filestream.html#6964b5d4fdb02bab8cefc323bda1b18c">realfilename</a>;<span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">   /*! Video file stream */</span>
<a name="l00125"></a><a class="code" href="structast__filestream.html#ab2eb9f5e144510f91fcdbae6fdd4465">00125</a>    <span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="structast__filestream.html#ab2eb9f5e144510f91fcdbae6fdd4465">vfs</a>;<span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment">   /*! Transparently translate from another format -- just once */</span>
<a name="l00127"></a><a class="code" href="structast__filestream.html#4738019ef434f24099319565cd5185e5">00127</a>    <span class="keyword">struct </span><a class="code" href="structast__trans__pvt.html">ast_trans_pvt</a> *<a class="code" href="structast__filestream.html#4738019ef434f24099319565cd5185e5">trans</a>;
<a name="l00128"></a><a class="code" href="structast__filestream.html#e7d707a26e7f7b6ff52c489c60e429b1">00128</a>    <span class="keyword">struct </span>ast_tranlator_pvt *<a class="code" href="structast__filestream.html#e7d707a26e7f7b6ff52c489c60e429b1">tr</a>;
<a name="l00129"></a><a class="code" href="structast__filestream.html#36ba0a38d9ec42f9efd0400425b83214">00129</a>    <span class="keywordtype">int</span> <a class="code" href="structast__filestream.html#36ba0a38d9ec42f9efd0400425b83214">lastwriteformat</a>;
<a name="l00130"></a><a class="code" href="structast__filestream.html#72237796f66f299f9b946e07c3c2cb13">00130</a>    <span class="keywordtype">int</span> <a class="code" href="structast__filestream.html#72237796f66f299f9b946e07c3c2cb13">lasttimeout</a>;
<a name="l00131"></a><a class="code" href="structast__filestream.html#72122ce96bfec66e2396d2e25225d70a">00131</a>    <span class="keyword">struct </span><a class="code" href="structast__channel.html">ast_channel</a> *<a class="code" href="structast__filestream.html#72122ce96bfec66e2396d2e25225d70a">owner</a>;
<a name="l00132"></a><a class="code" href="structast__filestream.html#8fa14cdd754f91cc6554c9e71929cce7">00132</a>    FILE *<a class="code" href="structast__filestream.html#8fa14cdd754f91cc6554c9e71929cce7">f</a>;
<a name="l00133"></a><a class="code" href="structast__filestream.html#82a9e4d26595c87ab6e442391d8c5bba">00133</a>    <span class="keyword">struct </span><a class="code" href="structast__frame.html">ast_frame</a> fr; <span class="comment">/* frame produced by read, typically */</span>
<a name="l00134"></a><a class="code" href="structast__filestream.html#cb7e52b21171fb9a53b498202607f0bd">00134</a>    <span class="keywordtype">char</span> *<a class="code" href="structast__filestream.html#cb7e52b21171fb9a53b498202607f0bd">buf</a>;     <span class="comment">/* buffer pointed to by ast_frame; */</span>
<a name="l00135"></a><a class="code" href="structast__filestream.html#2c17c6393771ee3048ae34d6b380c5ec">00135</a>    <span class="keywordtype">void</span> *<span class="keyword">private</span>; <span class="comment">/* pointer to private buffer */</span>
<a name="l00136"></a>00136 };
<a name="l00137"></a>00137 
<a name="l00138"></a><a class="code" href="file_8h.html#c499fc238ba5577289a5455d9118a510">00138</a> <span class="preprocessor">#define SEEK_FORCECUR   10</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span>   <span class="comment"></span>
<a name="l00140"></a>00140 <span class="comment">/*! Register a new file format capability</span>
<a name="l00141"></a>00141 <span class="comment"> * Adds a format to Asterisk's format abilities.</span>
<a name="l00142"></a>00142 <span class="comment"> * returns 0 on success, -1 on failure</span>
<a name="l00143"></a>00143 <span class="comment"> */</span>
<a name="l00144"></a>00144 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#b6a20976ddfd8c7397485265fe9819de">__ast_format_register</a>(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structast__format.html">ast_format</a> *<a class="code" href="format__g726_8c.html#85b9b17a7dd34a3638c560bc9152473b">f</a>, <span class="keyword">struct</span> <a class="code" href="structast__module.html">ast_module</a> *mod);
<a name="l00145"></a><a class="code" href="file_8h.html#546700b1dc000dae7ed61721fa362bf8">00145</a> <span class="preprocessor">#define ast_format_register(f) __ast_format_register(f, ast_module_info-&gt;self)</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00147"></a>00147 <span class="comment">/*! Unregisters a file format */</span><span class="comment"></span>
<a name="l00148"></a>00148 <span class="comment">/*!</span>
<a name="l00149"></a>00149 <span class="comment"> * \param name the name of the format you wish to unregister</span>
<a name="l00150"></a>00150 <span class="comment"> * Unregisters a format based on the name of the format.</span>
<a name="l00151"></a>00151 <span class="comment"> * Returns 0 on success, -1 on failure to unregister</span>
<a name="l00152"></a>00152 <span class="comment"> */</span>
<a name="l00153"></a>00153 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#153a6a52d4750b28e5b3a3f1a7a93b7f">ast_format_unregister</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="callerid_8c.html#b068931cc450442b63f5b3d276ea4297">name</a>);
<a name="l00154"></a>00154 <span class="comment"></span>
<a name="l00155"></a>00155 <span class="comment">/*! Streams a file */</span><span class="comment"></span>
<a name="l00156"></a>00156 <span class="comment">/*!</span>
<a name="l00157"></a>00157 <span class="comment"> * \param c channel to stream the file to</span>
<a name="l00158"></a>00158 <span class="comment"> * \param filename the name of the file you wish to stream, minus the extension</span>
<a name="l00159"></a>00159 <span class="comment"> * \param preflang the preferred language you wish to have the file streamed to you in</span>
<a name="l00160"></a>00160 <span class="comment"> * Prepares a channel for the streaming of a file.  To start the stream, afterward do a ast_waitstream() on the channel</span>
<a name="l00161"></a>00161 <span class="comment"> * Also, it will stop any existing streams on the channel.</span>
<a name="l00162"></a>00162 <span class="comment"> * Returns 0 on success, or -1 on failure.</span>
<a name="l00163"></a>00163 <span class="comment"> */</span>
<a name="l00164"></a>00164 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#323e58584ef6ab2486be5b347b23ebe0">ast_streamfile</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html">ast_channel</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *preflang);
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <span class="comment">/*</span>
<a name="l00167"></a>00167 <span class="comment"> * if the file name is non-empty, try to play it.</span>
<a name="l00168"></a>00168 <span class="comment"> * Return 0 if success, -1 if error, digit if interrupted by a digit.</span>
<a name="l00169"></a>00169 <span class="comment"> * If digits == "" then we can simply check for non-zero.</span>
<a name="l00170"></a>00170 <span class="comment"> */</span>
<a name="l00171"></a>00171 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#65052c94377323821185d04e2600dda2">ast_stream_and_wait</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html">ast_channel</a> *<a class="code" href="adsistub_8c.html#26c322652770620e64ac90682eb6504c">chan</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="manager_8h.html#8c7dd922ad47494fc02c388e12c00eac">file</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *digits);
<a name="l00172"></a>00172 <span class="comment"></span>
<a name="l00173"></a>00173 <span class="comment">/*! Stops a stream */</span><span class="comment"></span>
<a name="l00174"></a>00174 <span class="comment">/*!</span>
<a name="l00175"></a>00175 <span class="comment"> * \param c The channel you wish to stop playback on</span>
<a name="l00176"></a>00176 <span class="comment"> * Stop playback of a stream </span>
<a name="l00177"></a>00177 <span class="comment"> * Returns 0 regardless</span>
<a name="l00178"></a>00178 <span class="comment"> */</span>
<a name="l00179"></a>00179 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#460c61941bbb0132a2513ec9d5529e0c">ast_stopstream</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html">ast_channel</a> *c);
<a name="l00180"></a>00180 <span class="comment"></span>
<a name="l00181"></a>00181 <span class="comment">/*! Checks for the existence of a given file */</span><span class="comment"></span>
<a name="l00182"></a>00182 <span class="comment">/*!</span>
<a name="l00183"></a>00183 <span class="comment"> * \param filename name of the file you wish to check, minus the extension</span>
<a name="l00184"></a>00184 <span class="comment"> * \param fmt the format you wish to check (the extension)</span>
<a name="l00185"></a>00185 <span class="comment"> * \param preflang (the preferred language you wisht to find the file in)</span>
<a name="l00186"></a>00186 <span class="comment"> * See if a given file exists in a given format.  If fmt is NULL,  any format is accepted.</span>
<a name="l00187"></a>00187 <span class="comment"> * Returns -1 if file does not exist, non-zero positive otherwise.</span>
<a name="l00188"></a>00188 <span class="comment"> */</span>
<a name="l00189"></a>00189 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#5a3ec0398dc377f7850e62edc9e093df">ast_fileexists</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="manager_8h.html#7631454338ff70b1a6b1262f5f36beac">fmt</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *preflang);
<a name="l00190"></a>00190 <span class="comment"></span>
<a name="l00191"></a>00191 <span class="comment">/*! Renames a file */</span><span class="comment"></span>
<a name="l00192"></a>00192 <span class="comment">/*! </span>
<a name="l00193"></a>00193 <span class="comment"> * \param oldname the name of the file you wish to act upon (minus the extension)</span>
<a name="l00194"></a>00194 <span class="comment"> * \param newname the name you wish to rename the file to (minus the extension)</span>
<a name="l00195"></a>00195 <span class="comment"> * \param fmt the format of the file</span>
<a name="l00196"></a>00196 <span class="comment"> * Rename a given file in a given format, or if fmt is NULL, then do so for all </span>
<a name="l00197"></a>00197 <span class="comment"> * Returns -1 on failure</span>
<a name="l00198"></a>00198 <span class="comment"> */</span>
<a name="l00199"></a>00199 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#6550c411c28c65446c5ad2a8307b50eb">ast_filerename</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *oldname, <span class="keyword">const</span> <span class="keywordtype">char</span> *newname, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="manager_8h.html#7631454338ff70b1a6b1262f5f36beac">fmt</a>);
<a name="l00200"></a>00200 <span class="comment"></span>
<a name="l00201"></a>00201 <span class="comment">/*! Deletes a file */</span><span class="comment"></span>
<a name="l00202"></a>00202 <span class="comment">/*! </span>
<a name="l00203"></a>00203 <span class="comment"> * \param filename name of the file you wish to delete (minus the extension)</span>
<a name="l00204"></a>00204 <span class="comment"> * \param fmt of the file</span>
<a name="l00205"></a>00205 <span class="comment"> * Delete a given file in a given format, or if fmt is NULL, then do so for all </span>
<a name="l00206"></a>00206 <span class="comment"> */</span>
<a name="l00207"></a>00207 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#5a0cbe1f8c9ff2126997209a785679d5">ast_filedelete</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="manager_8h.html#7631454338ff70b1a6b1262f5f36beac">fmt</a>);
<a name="l00208"></a>00208 <span class="comment"></span>
<a name="l00209"></a>00209 <span class="comment">/*! Copies a file */</span><span class="comment"></span>
<a name="l00210"></a>00210 <span class="comment">/*!</span>
<a name="l00211"></a>00211 <span class="comment"> * \param oldname name of the file you wish to copy (minus extension)</span>
<a name="l00212"></a>00212 <span class="comment"> * \param newname name you wish the file to be copied to (minus extension)</span>
<a name="l00213"></a>00213 <span class="comment"> * \param fmt the format of the file</span>
<a name="l00214"></a>00214 <span class="comment"> * Copy a given file in a given format, or if fmt is NULL, then do so for all </span>
<a name="l00215"></a>00215 <span class="comment"> */</span>
<a name="l00216"></a>00216 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#002e77f5a6dfbe096d6cca62c3493ec1">ast_filecopy</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *oldname, <span class="keyword">const</span> <span class="keywordtype">char</span> *newname, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="manager_8h.html#7631454338ff70b1a6b1262f5f36beac">fmt</a>);
<a name="l00217"></a>00217 <span class="comment"></span>
<a name="l00218"></a>00218 <span class="comment">/*! Waits for a stream to stop or digit to be pressed */</span><span class="comment"></span>
<a name="l00219"></a>00219 <span class="comment">/*!</span>
<a name="l00220"></a>00220 <span class="comment"> * \param c channel to waitstream on</span>
<a name="l00221"></a>00221 <span class="comment"> * \param breakon string of DTMF digits to break upon</span>
<a name="l00222"></a>00222 <span class="comment"> * Begins playback of a stream...</span>
<a name="l00223"></a>00223 <span class="comment"> * Wait for a stream to stop or for any one of a given digit to arrive,  Returns 0 </span>
<a name="l00224"></a>00224 <span class="comment"> * if the stream finishes, the character if it was interrupted, and -1 on error </span>
<a name="l00225"></a>00225 <span class="comment"> */</span>
<a name="l00226"></a>00226 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#634a25400a6a724d278b9129b9b5181b">ast_waitstream</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html">ast_channel</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *breakon);
<a name="l00227"></a>00227 <span class="comment"></span>
<a name="l00228"></a>00228 <span class="comment">/*! Waits for a stream to stop or digit matching a valid one digit exten to be pressed */</span><span class="comment"></span>
<a name="l00229"></a>00229 <span class="comment">/*!</span>
<a name="l00230"></a>00230 <span class="comment"> * \param c channel to waitstream on</span>
<a name="l00231"></a>00231 <span class="comment"> * \param context string of context to match digits to break upon</span>
<a name="l00232"></a>00232 <span class="comment"> * Begins playback of a stream...</span>
<a name="l00233"></a>00233 <span class="comment"> * Wait for a stream to stop or for any one of a valid extension digit to arrive,  Returns 0 </span>
<a name="l00234"></a>00234 <span class="comment"> * if the stream finishes, the character if it was interrupted, and -1 on error </span>
<a name="l00235"></a>00235 <span class="comment"> */</span>
<a name="l00236"></a>00236 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#24c25c9a9f196587f0ad5f466c059d22">ast_waitstream_exten</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html">ast_channel</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="chan__alsa_8c.html#c1ae8ba118483c4c23841d72b5e7ebbb">context</a>);
<a name="l00237"></a>00237 <span class="comment"></span>
<a name="l00238"></a>00238 <span class="comment">/*! Same as waitstream but allows stream to be forwarded or rewound */</span><span class="comment"></span>
<a name="l00239"></a>00239 <span class="comment">/*!</span>
<a name="l00240"></a>00240 <span class="comment"> * \param c channel to waitstream on</span>
<a name="l00241"></a>00241 <span class="comment"> * \param breakon string of DTMF digits to break upon</span>
<a name="l00242"></a>00242 <span class="comment"> * \param forward DTMF digit to fast forward upon</span>
<a name="l00243"></a>00243 <span class="comment"> * \param rewind DTMF digit to rewind upon</span>
<a name="l00244"></a>00244 <span class="comment"> * \param ms How many miliseconds to skip forward/back</span>
<a name="l00245"></a>00245 <span class="comment"> * Begins playback of a stream...</span>
<a name="l00246"></a>00246 <span class="comment"> * Wait for a stream to stop or for any one of a given digit to arrive,  Returns 0 </span>
<a name="l00247"></a>00247 <span class="comment"> * if the stream finishes, the character if it was interrupted, and -1 on error </span>
<a name="l00248"></a>00248 <span class="comment"> */</span>
<a name="l00249"></a>00249 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#0db2bacb7cd7648486a6eb2b679d64db">ast_waitstream_fr</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html">ast_channel</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *breakon, <span class="keyword">const</span> <span class="keywordtype">char</span> *forward, <span class="keyword">const</span> <span class="keywordtype">char</span> *rewind, <span class="keywordtype">int</span> ms);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="comment">/* Same as waitstream, but with audio output to fd and monitored fd checking.  Returns</span>
<a name="l00252"></a>00252 <span class="comment">   1 if monfd is ready for reading */</span>
<a name="l00253"></a>00253 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#7be3107f4ff5bc2975b1f52fa552cb6a">ast_waitstream_full</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html">ast_channel</a> *c, <span class="keyword">const</span> <span class="keywordtype">char</span> *breakon, <span class="keywordtype">int</span> audiofd, <span class="keywordtype">int</span> monfd);
<a name="l00254"></a>00254 <span class="comment"></span>
<a name="l00255"></a>00255 <span class="comment">/*! Starts reading from a file */</span><span class="comment"></span>
<a name="l00256"></a>00256 <span class="comment">/*!</span>
<a name="l00257"></a>00257 <span class="comment"> * \param filename the name of the file to read from</span>
<a name="l00258"></a>00258 <span class="comment"> * \param type format of file you wish to read from</span>
<a name="l00259"></a>00259 <span class="comment"> * \param comment comment to go with</span>
<a name="l00260"></a>00260 <span class="comment"> * \param flags file flags</span>
<a name="l00261"></a>00261 <span class="comment"> * \param check (unimplemented, hence negligible)</span>
<a name="l00262"></a>00262 <span class="comment"> * \param mode Open mode</span>
<a name="l00263"></a>00263 <span class="comment"> * Open an incoming file stream.  flags are flags for the open() command, and </span>
<a name="l00264"></a>00264 <span class="comment"> * if check is non-zero, then it will not read a file if there are any files that </span>
<a name="l00265"></a>00265 <span class="comment"> * start with that name and have an extension</span>
<a name="l00266"></a>00266 <span class="comment"> * Please note, this is a blocking function.  Program execution will not return until ast_waitstream completes it's execution.</span>
<a name="l00267"></a>00267 <span class="comment"> * Returns a struct ast_filestream on success, NULL on failure</span>
<a name="l00268"></a>00268 <span class="comment"> */</span>
<a name="l00269"></a>00269 <span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="file_8c.html#e87a1a55e2031e34919c906b497a554c">ast_readfile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structast__filestream.html#435ed7e9f07f740abf511a62c00eef6e">filename</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="rtp_8c.html#599dcce2998a6b40b1e38e8c6006cb0a">type</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *comment, <span class="keywordtype">int</span> <a class="code" href="structast__filestream.html#4e5868d676cb634aa75b125a0f741abf">flags</a>, <span class="keywordtype">int</span> check, mode_t <a class="code" href="structast__filestream.html#15d61712450a686a7f365adf4fef581f">mode</a>);
<a name="l00270"></a>00270 <span class="comment"></span>
<a name="l00271"></a>00271 <span class="comment">/*! Starts writing a file */</span><span class="comment"></span>
<a name="l00272"></a>00272 <span class="comment">/*!</span>
<a name="l00273"></a>00273 <span class="comment"> * \param filename the name of the file to write to</span>
<a name="l00274"></a>00274 <span class="comment"> * \param type format of file you wish to write out to</span>
<a name="l00275"></a>00275 <span class="comment"> * \param comment comment to go with</span>
<a name="l00276"></a>00276 <span class="comment"> * \param flags output file flags</span>
<a name="l00277"></a>00277 <span class="comment"> * \param check (unimplemented, hence negligible)</span>
<a name="l00278"></a>00278 <span class="comment"> * \param mode Open mode</span>
<a name="l00279"></a>00279 <span class="comment"> * Create an outgoing file stream.  oflags are flags for the open() command, and </span>
<a name="l00280"></a>00280 <span class="comment"> * if check is non-zero, then it will not write a file if there are any files that </span>
<a name="l00281"></a>00281 <span class="comment"> * start with that name and have an extension</span>
<a name="l00282"></a>00282 <span class="comment"> * Please note, this is a blocking function.  Program execution will not return until ast_waitstream completes it's execution.</span>
<a name="l00283"></a>00283 <span class="comment"> * Returns a struct ast_filestream on success, NULL on failure</span>
<a name="l00284"></a>00284 <span class="comment"> */</span>
<a name="l00285"></a>00285 <span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="file_8c.html#863a5fc977919f88d566c68efc408f7a">ast_writefile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structast__filestream.html#435ed7e9f07f740abf511a62c00eef6e">filename</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="rtp_8c.html#599dcce2998a6b40b1e38e8c6006cb0a">type</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *comment, <span class="keywordtype">int</span> <a class="code" href="structast__filestream.html#4e5868d676cb634aa75b125a0f741abf">flags</a>, <span class="keywordtype">int</span> check, mode_t <a class="code" href="structast__filestream.html#15d61712450a686a7f365adf4fef581f">mode</a>);
<a name="l00286"></a>00286 <span class="comment"></span>
<a name="l00287"></a>00287 <span class="comment">/*! Writes a frame to a stream */</span><span class="comment"></span>
<a name="l00288"></a>00288 <span class="comment">/*! </span>
<a name="l00289"></a>00289 <span class="comment"> * \param fs filestream to write to</span>
<a name="l00290"></a>00290 <span class="comment"> * \param f frame to write to the filestream</span>
<a name="l00291"></a>00291 <span class="comment"> * Send a frame to a filestream -- note: does NOT free the frame, call ast_frfree manually</span>
<a name="l00292"></a>00292 <span class="comment"> * Returns 0 on success, -1 on failure.</span>
<a name="l00293"></a>00293 <span class="comment"> */</span>
<a name="l00294"></a>00294 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#89845762896f1b8df8786e386b3a7493">ast_writestream</a>(<span class="keyword">struct</span> <a class="code" href="structast__filestream.html">ast_filestream</a> *fs, <span class="keyword">struct</span> <a class="code" href="structast__frame.html">ast_frame</a> *<a class="code" href="format__g726_8c.html#85b9b17a7dd34a3638c560bc9152473b">f</a>);
<a name="l00295"></a>00295 <span class="comment"></span>
<a name="l00296"></a>00296 <span class="comment">/*! Closes a stream */</span><span class="comment"></span>
<a name="l00297"></a>00297 <span class="comment">/*!</span>
<a name="l00298"></a>00298 <span class="comment"> * \param f filestream to close</span>
<a name="l00299"></a>00299 <span class="comment"> * Close a playback or recording stream</span>
<a name="l00300"></a>00300 <span class="comment"> * Returns 0 on success, -1 on failure</span>
<a name="l00301"></a>00301 <span class="comment"> */</span>
<a name="l00302"></a>00302 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#8d18ac7b6bb79201e6321c4b5cfadde2">ast_closestream</a>(<span class="keyword">struct</span> <a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="format__g726_8c.html#85b9b17a7dd34a3638c560bc9152473b">f</a>);
<a name="l00303"></a>00303 <span class="comment"></span>
<a name="l00304"></a>00304 <span class="comment">/*! Opens stream for use in seeking, playing */</span><span class="comment"></span>
<a name="l00305"></a>00305 <span class="comment">/*!</span>
<a name="l00306"></a>00306 <span class="comment"> * \param chan channel to work with</span>
<a name="l00307"></a>00307 <span class="comment"> * \param filename to use</span>
<a name="l00308"></a>00308 <span class="comment"> * \param preflang prefered language to use</span>
<a name="l00309"></a>00309 <span class="comment"> * Returns a ast_filestream pointer if it opens the file, NULL on error</span>
<a name="l00310"></a>00310 <span class="comment"> */</span>
<a name="l00311"></a>00311 <span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="file_8c.html#0bcbc0f6cab0bf6be159f0d5844e1b4b">ast_openstream</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html">ast_channel</a> *<a class="code" href="adsistub_8c.html#26c322652770620e64ac90682eb6504c">chan</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structast__filestream.html#435ed7e9f07f740abf511a62c00eef6e">filename</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *preflang);
<a name="l00312"></a>00312 <span class="comment"></span>
<a name="l00313"></a>00313 <span class="comment">/*! Opens stream for use in seeking, playing */</span><span class="comment"></span>
<a name="l00314"></a>00314 <span class="comment">/*!</span>
<a name="l00315"></a>00315 <span class="comment"> * \param chan channel to work with</span>
<a name="l00316"></a>00316 <span class="comment"> * \param filename to use</span>
<a name="l00317"></a>00317 <span class="comment"> * \param preflang prefered language to use</span>
<a name="l00318"></a>00318 <span class="comment"> * \param asis if set, don't clear generators</span>
<a name="l00319"></a>00319 <span class="comment"> * Returns a ast_filestream pointer if it opens the file, NULL on error</span>
<a name="l00320"></a>00320 <span class="comment"> */</span>
<a name="l00321"></a>00321 <span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="file_8c.html#b3c8b25cffdb8cddd9ece4671da30b03">ast_openstream_full</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html">ast_channel</a> *<a class="code" href="adsistub_8c.html#26c322652770620e64ac90682eb6504c">chan</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structast__filestream.html#435ed7e9f07f740abf511a62c00eef6e">filename</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *preflang, <span class="keywordtype">int</span> asis);<span class="comment"></span>
<a name="l00322"></a>00322 <span class="comment">/*! Opens stream for use in seeking, playing */</span><span class="comment"></span>
<a name="l00323"></a>00323 <span class="comment">/*!</span>
<a name="l00324"></a>00324 <span class="comment"> * \param chan channel to work with</span>
<a name="l00325"></a>00325 <span class="comment"> * \param filename to use</span>
<a name="l00326"></a>00326 <span class="comment"> * \param preflang prefered language to use</span>
<a name="l00327"></a>00327 <span class="comment"> * Returns a ast_filestream pointer if it opens the file, NULL on error</span>
<a name="l00328"></a>00328 <span class="comment"> */</span>
<a name="l00329"></a>00329 <span class="keyword">struct </span><a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="file_8c.html#226c58342b830e85eb5c359c6ab5a65f">ast_openvstream</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html">ast_channel</a> *<a class="code" href="adsistub_8c.html#26c322652770620e64ac90682eb6504c">chan</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structast__filestream.html#435ed7e9f07f740abf511a62c00eef6e">filename</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *preflang);
<a name="l00330"></a>00330 <span class="comment"></span>
<a name="l00331"></a>00331 <span class="comment">/*! Applys a open stream to a channel. */</span><span class="comment"></span>
<a name="l00332"></a>00332 <span class="comment">/*!</span>
<a name="l00333"></a>00333 <span class="comment"> * \param chan channel to work</span>
<a name="l00334"></a>00334 <span class="comment"> * \param s ast_filestream to apply</span>
<a name="l00335"></a>00335 <span class="comment"> * Returns 0 for success, -1 on failure</span>
<a name="l00336"></a>00336 <span class="comment"> */</span>
<a name="l00337"></a>00337 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#47ae0cfaee0f98a97bf732081a55fcdc">ast_applystream</a>(<span class="keyword">struct</span> <a class="code" href="structast__channel.html">ast_channel</a> *<a class="code" href="adsistub_8c.html#26c322652770620e64ac90682eb6504c">chan</a>, <span class="keyword">struct</span> <a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="aesopt_8h.html#8d6242bc80162ac99dd4d368eabe77cc">s</a>);
<a name="l00338"></a>00338 <span class="comment"></span>
<a name="l00339"></a>00339 <span class="comment">/*! play a open stream on a channel. */</span><span class="comment"></span>
<a name="l00340"></a>00340 <span class="comment">/*!</span>
<a name="l00341"></a>00341 <span class="comment"> * \param s filestream to play</span>
<a name="l00342"></a>00342 <span class="comment"> * Returns 0 for success, -1 on failure</span>
<a name="l00343"></a>00343 <span class="comment"> */</span>
<a name="l00344"></a>00344 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#96615b28d77eef740ce76e209aad7424">ast_playstream</a>(<span class="keyword">struct</span> <a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="aesopt_8h.html#8d6242bc80162ac99dd4d368eabe77cc">s</a>);
<a name="l00345"></a>00345 <span class="comment"></span>
<a name="l00346"></a>00346 <span class="comment">/*! Seeks into stream */</span><span class="comment"></span>
<a name="l00347"></a>00347 <span class="comment">/*!</span>
<a name="l00348"></a>00348 <span class="comment"> * \param fs ast_filestream to perform seek on</span>
<a name="l00349"></a>00349 <span class="comment"> * \param sample_offset numbers of samples to seek</span>
<a name="l00350"></a>00350 <span class="comment"> * \param whence SEEK_SET, SEEK_CUR, SEEK_END </span>
<a name="l00351"></a>00351 <span class="comment"> * Returns 0 for success, or -1 for error</span>
<a name="l00352"></a>00352 <span class="comment"> */</span>
<a name="l00353"></a>00353 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#02e10962dcfcb69e23bfaf15dce32393">ast_seekstream</a>(<span class="keyword">struct</span> <a class="code" href="structast__filestream.html">ast_filestream</a> *fs, off_t sample_offset, <span class="keywordtype">int</span> whence);
<a name="l00354"></a>00354 <span class="comment"></span>
<a name="l00355"></a>00355 <span class="comment">/*! Trunc stream at current location */</span><span class="comment"></span>
<a name="l00356"></a>00356 <span class="comment">/*!</span>
<a name="l00357"></a>00357 <span class="comment"> * \param fs filestream to act on</span>
<a name="l00358"></a>00358 <span class="comment"> * Returns 0 for success, or -1 for error</span>
<a name="l00359"></a>00359 <span class="comment"> */</span>
<a name="l00360"></a>00360 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#ce29e5d0bdd4ecde2928bc9055507bc0">ast_truncstream</a>(<span class="keyword">struct</span> <a class="code" href="structast__filestream.html">ast_filestream</a> *fs);
<a name="l00361"></a>00361 <span class="comment"></span>
<a name="l00362"></a>00362 <span class="comment">/*! Fast forward stream ms */</span><span class="comment"></span>
<a name="l00363"></a>00363 <span class="comment">/*!</span>
<a name="l00364"></a>00364 <span class="comment"> * \param fs filestream to act on</span>
<a name="l00365"></a>00365 <span class="comment"> * \param ms milliseconds to move</span>
<a name="l00366"></a>00366 <span class="comment"> * Returns 0 for success, or -1 for error</span>
<a name="l00367"></a>00367 <span class="comment"> */</span>
<a name="l00368"></a>00368 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#a89ae22b0f4ddc671b516808ebfc0679">ast_stream_fastforward</a>(<span class="keyword">struct</span> <a class="code" href="structast__filestream.html">ast_filestream</a> *fs, off_t ms);
<a name="l00369"></a>00369 <span class="comment"></span>
<a name="l00370"></a>00370 <span class="comment">/*! Rewind stream ms */</span><span class="comment"></span>
<a name="l00371"></a>00371 <span class="comment">/*!</span>
<a name="l00372"></a>00372 <span class="comment"> * \param fs filestream to act on</span>
<a name="l00373"></a>00373 <span class="comment"> * \param ms milliseconds to move</span>
<a name="l00374"></a>00374 <span class="comment"> * Returns 0 for success, or -1 for error</span>
<a name="l00375"></a>00375 <span class="comment"> */</span>
<a name="l00376"></a>00376 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#3a2eb1ab87bc99265738281b25fc6999">ast_stream_rewind</a>(<span class="keyword">struct</span> <a class="code" href="structast__filestream.html">ast_filestream</a> *fs, off_t ms);
<a name="l00377"></a>00377 <span class="comment"></span>
<a name="l00378"></a>00378 <span class="comment">/*! Tell where we are in a stream */</span><span class="comment"></span>
<a name="l00379"></a>00379 <span class="comment">/*!</span>
<a name="l00380"></a>00380 <span class="comment"> * \param fs fs to act on</span>
<a name="l00381"></a>00381 <span class="comment"> * Returns a long as a sample offset into stream</span>
<a name="l00382"></a>00382 <span class="comment"> */</span>
<a name="l00383"></a>00383 off_t <a class="code" href="file_8c.html#f71d7aa8f7ce1c8a5e60fe235ad4ea01">ast_tellstream</a>(<span class="keyword">struct</span> <a class="code" href="structast__filestream.html">ast_filestream</a> *fs);
<a name="l00384"></a>00384 <span class="comment"></span>
<a name="l00385"></a>00385 <span class="comment">/*! Read a frame from a filestream */</span><span class="comment"></span>
<a name="l00386"></a>00386 <span class="comment">/*!</span>
<a name="l00387"></a>00387 <span class="comment"> * \param s ast_filestream to act on</span>
<a name="l00388"></a>00388 <span class="comment"> * Returns a frame or NULL if read failed</span>
<a name="l00389"></a>00389 <span class="comment"> */</span> 
<a name="l00390"></a>00390 <span class="keyword">struct </span><a class="code" href="structast__frame.html">ast_frame</a> *<a class="code" href="file_8c.html#adedd7e446f209ba9d3f1ce00ea08697">ast_readframe</a>(<span class="keyword">struct</span> <a class="code" href="structast__filestream.html">ast_filestream</a> *<a class="code" href="aesopt_8h.html#8d6242bc80162ac99dd4d368eabe77cc">s</a>);
<a name="l00391"></a>00391 <span class="comment"></span>
<a name="l00392"></a>00392 <span class="comment">/*! Initialize file stuff */</span><span class="comment"></span>
<a name="l00393"></a>00393 <span class="comment">/*!</span>
<a name="l00394"></a>00394 <span class="comment"> * Initializes all the various file stuff.  Basically just registers the cli stuff</span>
<a name="l00395"></a>00395 <span class="comment"> * Returns 0 all the time</span>
<a name="l00396"></a>00396 <span class="comment"> */</span>
<a name="l00397"></a>00397 <span class="keywordtype">int</span> <a class="code" href="file_8c.html#c9bd705c9a99609486cdfdd5208f0a44">ast_file_init</a>(<span class="keywordtype">void</span>);
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 
<a name="l00400"></a><a class="code" href="file_8h.html#0c68a323cdb0e44364ab025c264ed168">00400</a> <span class="preprocessor">#define AST_RESERVED_POINTERS 20</span>
<a name="l00401"></a>00401 <span class="preprocessor"></span>
<a name="l00402"></a>00402 <span class="preprocessor">#if defined(__cplusplus) || defined(c_plusplus)</span>
<a name="l00403"></a>00403 <span class="preprocessor"></span>}
<a name="l00404"></a>00404 <span class="preprocessor">#endif</span>
<a name="l00405"></a>00405 <span class="preprocessor"></span>
<a name="l00406"></a>00406 <span class="preprocessor">#endif </span><span class="comment">/* _ASTERISK_FILE_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu May 24 22:26:41 2007 for Asterisk - the Open Source PBX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.5 </small></address>
</body>
</html>
