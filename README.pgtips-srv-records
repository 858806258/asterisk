Edvina AB
Olle E. Johansson

Project start: 2013-04-18
Update:        2013-08-27








SRV Support in the SIP channel of Asterisk
==========================================

The Asterisk SIP channel lacks full support of RFC 3263, Locating SIP services. This project
aims at fixing that.

For every transaction, a SIP client needs to build a list of SIP servers as discovered
by DNS lookup. The list needs to be prioritized and handled according to a set of
rules set by RFC 3263 and the RFCs referred to by that document.

- DNS Load balancing
  For servers in the same priority, select one based on the weight distribution indicated
  in the records
- DNS priority and failover
  Start with lowest priority and work upwards in the set of records.

In addition, address family needs to be handled properly. An IPv4 server needs to ignore
hosts with only IPv6 records and move on in the process of selecting a server and 
vice versa for IPv6 only hosts. 

This project is funded by Inteno Broadband Solutions AB, Sweden. http://www.intenogroup.com

Happy Earballs
==============
Dual stack hosts needs to contact both address families at the same time to minimize 
timeout effects on caller's call setup time.

This is not in scope for this project. Work is in progress in the SIP Forum IPv6 wg
to define a process for this situation.

Asterisk changes (brainstorm suggestion)
========================================

- Make sure that the SIP channel gets a list on a SRV lookup, not a single host.
- Add failover based on that list
- Make sure the list is searched on every transaction and have failover in a call
- Add peer matching (see below)


Peer matching
-------------
This is a bit more interesting. If you connect to a service provider and add
this to sip.conf

register=user:password@serviceprovider/1234


[serviceprovider]
type=peer
host=serviceproviderdomain.tld
context=bazinga

You expect to be able to receive calls from the service provider
using that peer. The service provider has a list of servers using IPv4
and IPv6 in the SRV records for that name. Should the Asterisk SIP channel
match the full list? I think it should.

Currently Asterisk will resolve to one IP address and use that for matching
of incoming calls, possibly deny calls from servers that does not match.
This is NOT the expected solution.

Failover
========
I see two situation for failover to the next host/ip in the SRV list:
- sip_xmit fails (no destination, icmp unreachable etc)
- timeout on Timer B

The Timeout case is handled by the retransmit engine. We need to
restart the timers and retransmissions with the same request.

The SIP_xmit can be handled in send_request(). This function doesn't
bother with failures at this time, strangely enough. What fails, fails,
and currently there's nothing to do about it.

We do need a function in main/srv.c to switch to the next entry and
move the "current" pointer.

Development Notes
=================

The SIP channel will have to be in control and get the full list of SRV
records. We can't hide this list.

DNSmanager can still maintain A/AAAA records if enabled, but not SRV
lists.

Not fixed here
==============
At IETF 87 in Berlin I had a meeting with two members of the IETF DNS directorate
to discuss SRV records. We discovered that SRV requires you to test ALL ip addresses
found (in families you support) for a host before moving to the next host. 
This means that if a host has multiple A or AAAA records, all of them should be
tested. This is not supported in Asterisk currently and this patch will not
fix that.


Todo:
=====
1. Expose SRV records to the SIP channel. Remove when response is received (1xx or higher).
	- The API is changed to support a module accessing SRV records.
2. Make sure SIP channel selects right with IPv4/IPv6. 
	- Done for [peers] in the sip.conf file.
	- Not done for calling a DNS name in the dial string (some code is there though)
3. Provide hooks for happy earballs if server is dual stack and we're dual stack
4. Implement failover to next server in list if transaction fails.
5. Make sure we use the DNS TTL properly
6. Use SRV for outbound proxys too, with failover
7. Add multiple IPs to the peer in an ACL list
	- Added a linked list
	- Needs to be added to peers by ip list for matching. Not done yet.
8. Add the same IPs to the AO2object for IP matching
9. Make sure the ACL list is updated by DNS manager
10. Change peer match by ip/port to use ACL list if available
11. Fix outbound proxy SRV support (proxy_update)
12. Avoid testing. Real developers don't test.
13. Don't open a bug tracker issue on this project.
14. De-install GDB. GDB is for weak developers.
15. Do not write any documentation, regardless of what people say. It's a SEP.
16. Stay calm and carry on.


Query on AO2 object stuff:
==========================
Olle:
I would like to be able to add all available IP addresses and ports for matching. Will that work with the ao2object list or will it
mess up the list to have many hash entries for the same object?

The way I would like to do this is to set up an ACL entry in the peer for the SRV record so we have a list to go through
and perform the matching on. If that list is empty, we will match as before.


Matt:
ao2 containers work fine with hash collisions. If a hash collision
occurs, a comparison callback is used to find the explicit object you're
searching for. They can also be used to store objects with duplicate keys.

The case of duplicate keys is a bit more complex however, as you have to
know that you won't get back a single object when you do a search. In
that case, your comparison callback (either the one supplied for the
container during its creation or one used in an ao2_callback) has to
return when it has a match (it returns CMP_MATCH) but not instruct the
ao2 library to stop (it doesn't return CMP_STOP). In addition, you have
to tell ao2_find or ao2_callback that you expect to get multiple objects
back by passing it OBJ_MULTIPLE. When you do that, it will return a new
ao2_iterator with all of the objects that matched.

There's a good example of doing multi-object matching and returning in
chan_sip's find_call - we do a multi-object match using an ao2_callback
to find all dialogs that match a call-id, then iterate over each object.

